Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AUTO
    BREAK
    CASE
    COMMENT
    CONTINUE
    DEFAULT
    DO
    ENUM
    GOTO
    LCOMMENT
    NUMBER
    REGISTER
    RESTRICT
    RETURN
    SIZEOF
    STATIC
    SWITCH
    TYPEDEF
    UNION
    _ALIGNAS
    _ALIGNOF
    _ATOMIC
    _BOOL
    _COMPLEX
    _GENERIC
    _IMAGERY
    _NORETURN
    _STATIC_ASSERT
    _THREAD_LOCAL

Grammar

Rule 0     S' -> node_list
Rule 1     node_list -> <empty>
Rule 2     node_list -> node_list node
Rule 3     node -> include
Rule 4     node -> define
Rule 5     node -> if
Rule 6     node -> func_def
Rule 7     node -> func_decl
Rule 8     node -> statement
Rule 9     node -> control_expr
Rule 10    node -> struct_def
Rule 11    literal -> FLOAT_L
Rule 12    literal -> INT_L
Rule 13    literal -> CHAR_L
Rule 14    literal -> STRING_L
Rule 15    literal -> NONDECIMAL_L
Rule 16    assign -> SIMPLE_ASSIGN
Rule 17    assign -> COMPLEX_ASSIGN
Rule 18    struct_type -> STRUCT ID
Rule 19    type_cast -> LPAREN dtype RPAREN
Rule 20    dtype -> CHAR
Rule 21    dtype -> DOUBLE
Rule 22    dtype -> FLOAT
Rule 23    dtype -> INT
Rule 24    dtype -> STRUCT
Rule 25    dtype -> VOID
Rule 26    dtype -> UINT8_T
Rule 27    dtype -> UINT16_T
Rule 28    dtype -> struct_type
Rule 29    dtype -> ID
Rule 30    dtype -> dtype ASTERISK
Rule 31    modifier -> CONST
Rule 32    modifier -> EXTERN
Rule 33    modifier -> INLINE
Rule 34    modifier -> LONG
Rule 35    modifier -> SHORT
Rule 36    modifier -> SIGNED
Rule 37    modifier -> UNSIGNED
Rule 38    modifier -> VOLATILE
Rule 39    name -> ID
Rule 40    name -> literal
Rule 41    name -> access
Rule 42    include -> INCLUDE
Rule 43    define -> DEFINE
Rule 44    if -> IFNDEF
Rule 45    if -> ENDIF
Rule 46    control -> WHILE
Rule 47    control -> IF
Rule 48    control -> ELSE
Rule 49    conditional -> EQ
Rule 50    conditional -> NEQ
Rule 51    conditional -> LT
Rule 52    conditional -> GT
Rule 53    conditional -> LE
Rule 54    conditional -> GE
Rule 55    conditional -> AND
Rule 56    conditional -> OR
Rule 57    conditional_expr -> name conditional expression
Rule 58    conditional_expr -> expression conditional name
Rule 59    conditional_expr -> expression conditional expression
Rule 60    conditional_expr -> name conditional name
Rule 61    conditional_expr -> name
Rule 62    for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
Rule 63    control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
Rule 64    control_expr -> control LBRACE node_list RBRACE
Rule 65    control_expr -> for_loop LBRACE node_list RBRACE
Rule 66    func_arg -> name
Rule 67    func_arg -> dtype name
Rule 68    func_arg -> dtype
Rule 69    func_arg -> type_cast name
Rule 70    func_arg -> type_cast expression
Rule 71    func_arg -> func_call
Rule 72    func_arg -> type_cast func_call
Rule 73    func_arglist -> <empty>
Rule 74    func_arglist -> func_arglist func_arg
Rule 75    func_arglist -> func_arglist func_arg COMMA
Rule 76    func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
Rule 77    func_call -> ID LPAREN func_arglist RPAREN
Rule 78    func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI
Rule 79    access -> name LBRACK name RBRACK
Rule 80    access -> name LBRACK expression RBRACK
Rule 81    access -> name MEMBER name
Rule 82    struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI
Rule 83    statement -> init_var
Rule 84    statement -> assign_var
Rule 85    statement -> declare_var
Rule 86    statement -> expression SEMI
Rule 87    statement -> func_call SEMI
Rule 88    expression -> LPAREN expression RPAREN
Rule 89    expression -> LPAREN name RPAREN
Rule 90    expression -> NEGATE expression
Rule 91    expression -> MINUS expression
Rule 92    expression -> NEGATE name
Rule 93    expression -> MINUS name
Rule 94    binop -> PLUS
Rule 95    binop -> MINUS
Rule 96    binop -> ASTERISK
Rule 97    binop -> DIVIDE
Rule 98    binop -> LSHIFT
Rule 99    binop -> RSHIFT
Rule 100   binop -> PERCENT
Rule 101   binop -> BITAND
Rule 102   binop -> BITOR
Rule 103   binop -> conditional
Rule 104   expression -> expression binop name
Rule 105   expression -> name binop expression
Rule 106   expression -> name binop name
Rule 107   expression -> expression binop expression
Rule 108   expression -> ID INCREMENT
Rule 109   declare_var -> dtype ID SEMI
Rule 110   declare_var -> modifier dtype ID SEMI
Rule 111   init_var_ls -> modifier dtype ID assign
Rule 112   init_var_ls -> dtype ID assign
Rule 113   init_var_ls -> modifier dtype ID LBRACK RBRACK assign
Rule 114   init_var_ls -> dtype ID LBRACK RBRACK assign
Rule 115   init_var_rs -> name SEMI
Rule 116   init_var_rs -> type_cast name SEMI
Rule 117   init_var_rs -> func_call SEMI
Rule 118   init_var -> init_var_ls init_var_rs
Rule 119   assign_var_ls -> name assign
Rule 120   assign_var_rs -> expression SEMI
Rule 121   assign_var_rs -> name SEMI
Rule 122   assign_var_rs -> func_call SEMI
Rule 123   assign_var_rs -> type_cast assign_var_rs SEMI
Rule 124   assign_var -> assign_var_ls assign_var_rs

Terminals, with rules where they appear

AND                  : 55
ASTERISK             : 30 96
AUTO                 : 
BITAND               : 101
BITOR                : 102
BREAK                : 
CASE                 : 
CHAR                 : 20
CHAR_L               : 13
COMMA                : 75
COMMENT              : 
COMPLEX_ASSIGN       : 17
CONST                : 31
CONTINUE             : 
DEFAULT              : 
DEFINE               : 43
DIVIDE               : 97
DO                   : 
DOUBLE               : 21
ELSE                 : 48
ENDIF                : 45
ENUM                 : 
EQ                   : 49
EXTERN               : 32
FLOAT                : 22
FLOAT_L              : 11
FOR                  : 62
GE                   : 54
GOTO                 : 
GT                   : 52
ID                   : 18 29 39 62 76 77 78 82 108 109 110 111 112 113 114
IF                   : 47
IFNDEF               : 44
INCLUDE              : 42
INCREMENT            : 62 108
INLINE               : 33
INT                  : 23
INT_L                : 12
LBRACE               : 63 64 65 76 82
LBRACK               : 79 80 113 114
LCOMMENT             : 
LE                   : 53
LONG                 : 34
LPAREN               : 19 62 63 76 77 78 88 89
LSHIFT               : 98
LT                   : 51
MEMBER               : 81
MINUS                : 91 93 95
NEGATE               : 90 92
NEQ                  : 50
NONDECIMAL_L         : 15
NUMBER               : 
OR                   : 56
PERCENT              : 100
PLUS                 : 94
RBRACE               : 63 64 65 76 82
RBRACK               : 79 80 113 114
REGISTER             : 
RESTRICT             : 
RETURN               : 
RPAREN               : 19 62 63 76 77 78 88 89
RSHIFT               : 99
SEMI                 : 62 78 82 86 87 109 110 115 116 117 120 121 122 123
SHORT                : 35
SIGNED               : 36
SIMPLE_ASSIGN        : 16
SIZEOF               : 
STATIC               : 
STRING_L             : 14
STRUCT               : 18 24 82
SWITCH               : 
TYPEDEF              : 
UINT16_T             : 27
UINT8_T              : 26
UNION                : 
UNSIGNED             : 37
VOID                 : 25
VOLATILE             : 38
WHILE                : 46
_ALIGNAS             : 
_ALIGNOF             : 
_ATOMIC              : 
_BOOL                : 
_COMPLEX             : 
_GENERIC             : 
_IMAGERY             : 
_NORETURN            : 
_STATIC_ASSERT       : 
_THREAD_LOCAL        : 
error                : 

Nonterminals, with rules where they appear

access               : 41
assign               : 111 112 113 114 119
assign_var           : 84
assign_var_ls        : 124
assign_var_rs        : 123 124
binop                : 104 105 106 107
conditional          : 57 58 59 60 103
conditional_expr     : 62 63
control              : 63 64
control_expr         : 9
declare_var          : 85
define               : 4
dtype                : 19 30 67 68 76 78 109 110 111 112 113 114
expression           : 57 58 59 59 70 80 86 88 90 91 104 105 107 107 120
for_loop             : 65
func_arg             : 74 75
func_arglist         : 74 75 76 77 78
func_call            : 71 72 87 117 122
func_decl            : 7
func_def             : 6
if                   : 5
include              : 3
init_var             : 62 83
init_var_ls          : 118
init_var_rs          : 118
literal              : 40
modifier             : 110 111 113
name                 : 57 58 60 60 61 66 67 69 79 79 80 81 81 89 92 93 104 105 106 106 115 116 119 121
node                 : 2
node_list            : 2 63 64 65 76 82 0
statement            : 8
struct_def           : 10
struct_type          : 28
type_cast            : 69 70 72 116 123

Parsing method: LALR

state 0

    (0) S' -> . node_list
    (1) node_list -> .
    (2) node_list -> . node_list node

    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)
    $end            reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 1

state 1

    (0) S' -> node_list .
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (42) include -> . INCLUDE
    (43) define -> . DEFINE
    (44) if -> . IFNDEF
    (45) if -> . ENDIF
    (76) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (78) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (83) statement -> . init_var
    (84) statement -> . assign_var
    (85) statement -> . declare_var
    (86) statement -> . expression SEMI
    (87) statement -> . func_call SEMI
    (63) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (64) control_expr -> . control LBRACE node_list RBRACE
    (65) control_expr -> . for_loop LBRACE node_list RBRACE
    (82) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (118) init_var -> . init_var_ls init_var_rs
    (124) assign_var -> . assign_var_ls assign_var_rs
    (109) declare_var -> . dtype ID SEMI
    (110) declare_var -> . modifier dtype ID SEMI
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (46) control -> . WHILE
    (47) control -> . IF
    (48) control -> . ELSE
    (62) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT ID
    (111) init_var_ls -> . modifier dtype ID assign
    (112) init_var_ls -> . dtype ID assign
    (113) init_var_ls -> . modifier dtype ID LBRACK RBRACK assign
    (114) init_var_ls -> . dtype ID LBRACK RBRACK assign
    (119) assign_var_ls -> . name assign
    (31) modifier -> . CONST
    (32) modifier -> . EXTERN
    (33) modifier -> . INLINE
    (34) modifier -> . LONG
    (35) modifier -> . SHORT
    (36) modifier -> . SIGNED
    (37) modifier -> . UNSIGNED
    (38) modifier -> . VOLATILE
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    STRUCT          shift and go to state 25
    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    ID              shift and go to state 16
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    WHILE           shift and go to state 40
    IF              shift and go to state 41
    ELSE            shift and go to state 42
    FOR             shift and go to state 43
    CONST           shift and go to state 44
    EXTERN          shift and go to state 45
    INLINE          shift and go to state 46
    LONG            shift and go to state 47
    SHORT           shift and go to state 48
    SIGNED          shift and go to state 49
    UNSIGNED        shift and go to state 50
    VOLATILE        shift and go to state 51
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    dtype                          shift and go to state 15
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    control                        shift and go to state 23
    for_loop                       shift and go to state 24
    struct_type                    shift and go to state 33
    init_var_ls                    shift and go to state 34
    assign_var_ls                  shift and go to state 35
    modifier                       shift and go to state 36
    name                           shift and go to state 37
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 2

    (2) node_list -> node_list node .

    INCLUDE         reduce using rule 2 (node_list -> node_list node .)
    DEFINE          reduce using rule 2 (node_list -> node_list node .)
    IFNDEF          reduce using rule 2 (node_list -> node_list node .)
    ENDIF           reduce using rule 2 (node_list -> node_list node .)
    STRUCT          reduce using rule 2 (node_list -> node_list node .)
    CHAR            reduce using rule 2 (node_list -> node_list node .)
    DOUBLE          reduce using rule 2 (node_list -> node_list node .)
    FLOAT           reduce using rule 2 (node_list -> node_list node .)
    INT             reduce using rule 2 (node_list -> node_list node .)
    VOID            reduce using rule 2 (node_list -> node_list node .)
    UINT8_T         reduce using rule 2 (node_list -> node_list node .)
    UINT16_T        reduce using rule 2 (node_list -> node_list node .)
    ID              reduce using rule 2 (node_list -> node_list node .)
    LPAREN          reduce using rule 2 (node_list -> node_list node .)
    NEGATE          reduce using rule 2 (node_list -> node_list node .)
    MINUS           reduce using rule 2 (node_list -> node_list node .)
    WHILE           reduce using rule 2 (node_list -> node_list node .)
    IF              reduce using rule 2 (node_list -> node_list node .)
    ELSE            reduce using rule 2 (node_list -> node_list node .)
    FOR             reduce using rule 2 (node_list -> node_list node .)
    CONST           reduce using rule 2 (node_list -> node_list node .)
    EXTERN          reduce using rule 2 (node_list -> node_list node .)
    INLINE          reduce using rule 2 (node_list -> node_list node .)
    LONG            reduce using rule 2 (node_list -> node_list node .)
    SHORT           reduce using rule 2 (node_list -> node_list node .)
    SIGNED          reduce using rule 2 (node_list -> node_list node .)
    UNSIGNED        reduce using rule 2 (node_list -> node_list node .)
    VOLATILE        reduce using rule 2 (node_list -> node_list node .)
    FLOAT_L         reduce using rule 2 (node_list -> node_list node .)
    INT_L           reduce using rule 2 (node_list -> node_list node .)
    CHAR_L          reduce using rule 2 (node_list -> node_list node .)
    STRING_L        reduce using rule 2 (node_list -> node_list node .)
    NONDECIMAL_L    reduce using rule 2 (node_list -> node_list node .)
    $end            reduce using rule 2 (node_list -> node_list node .)
    RBRACE          reduce using rule 2 (node_list -> node_list node .)


state 3

    (3) node -> include .

    INCLUDE         reduce using rule 3 (node -> include .)
    DEFINE          reduce using rule 3 (node -> include .)
    IFNDEF          reduce using rule 3 (node -> include .)
    ENDIF           reduce using rule 3 (node -> include .)
    STRUCT          reduce using rule 3 (node -> include .)
    CHAR            reduce using rule 3 (node -> include .)
    DOUBLE          reduce using rule 3 (node -> include .)
    FLOAT           reduce using rule 3 (node -> include .)
    INT             reduce using rule 3 (node -> include .)
    VOID            reduce using rule 3 (node -> include .)
    UINT8_T         reduce using rule 3 (node -> include .)
    UINT16_T        reduce using rule 3 (node -> include .)
    ID              reduce using rule 3 (node -> include .)
    LPAREN          reduce using rule 3 (node -> include .)
    NEGATE          reduce using rule 3 (node -> include .)
    MINUS           reduce using rule 3 (node -> include .)
    WHILE           reduce using rule 3 (node -> include .)
    IF              reduce using rule 3 (node -> include .)
    ELSE            reduce using rule 3 (node -> include .)
    FOR             reduce using rule 3 (node -> include .)
    CONST           reduce using rule 3 (node -> include .)
    EXTERN          reduce using rule 3 (node -> include .)
    INLINE          reduce using rule 3 (node -> include .)
    LONG            reduce using rule 3 (node -> include .)
    SHORT           reduce using rule 3 (node -> include .)
    SIGNED          reduce using rule 3 (node -> include .)
    UNSIGNED        reduce using rule 3 (node -> include .)
    VOLATILE        reduce using rule 3 (node -> include .)
    FLOAT_L         reduce using rule 3 (node -> include .)
    INT_L           reduce using rule 3 (node -> include .)
    CHAR_L          reduce using rule 3 (node -> include .)
    STRING_L        reduce using rule 3 (node -> include .)
    NONDECIMAL_L    reduce using rule 3 (node -> include .)
    $end            reduce using rule 3 (node -> include .)
    RBRACE          reduce using rule 3 (node -> include .)


state 4

    (4) node -> define .

    INCLUDE         reduce using rule 4 (node -> define .)
    DEFINE          reduce using rule 4 (node -> define .)
    IFNDEF          reduce using rule 4 (node -> define .)
    ENDIF           reduce using rule 4 (node -> define .)
    STRUCT          reduce using rule 4 (node -> define .)
    CHAR            reduce using rule 4 (node -> define .)
    DOUBLE          reduce using rule 4 (node -> define .)
    FLOAT           reduce using rule 4 (node -> define .)
    INT             reduce using rule 4 (node -> define .)
    VOID            reduce using rule 4 (node -> define .)
    UINT8_T         reduce using rule 4 (node -> define .)
    UINT16_T        reduce using rule 4 (node -> define .)
    ID              reduce using rule 4 (node -> define .)
    LPAREN          reduce using rule 4 (node -> define .)
    NEGATE          reduce using rule 4 (node -> define .)
    MINUS           reduce using rule 4 (node -> define .)
    WHILE           reduce using rule 4 (node -> define .)
    IF              reduce using rule 4 (node -> define .)
    ELSE            reduce using rule 4 (node -> define .)
    FOR             reduce using rule 4 (node -> define .)
    CONST           reduce using rule 4 (node -> define .)
    EXTERN          reduce using rule 4 (node -> define .)
    INLINE          reduce using rule 4 (node -> define .)
    LONG            reduce using rule 4 (node -> define .)
    SHORT           reduce using rule 4 (node -> define .)
    SIGNED          reduce using rule 4 (node -> define .)
    UNSIGNED        reduce using rule 4 (node -> define .)
    VOLATILE        reduce using rule 4 (node -> define .)
    FLOAT_L         reduce using rule 4 (node -> define .)
    INT_L           reduce using rule 4 (node -> define .)
    CHAR_L          reduce using rule 4 (node -> define .)
    STRING_L        reduce using rule 4 (node -> define .)
    NONDECIMAL_L    reduce using rule 4 (node -> define .)
    $end            reduce using rule 4 (node -> define .)
    RBRACE          reduce using rule 4 (node -> define .)


state 5

    (5) node -> if .

    INCLUDE         reduce using rule 5 (node -> if .)
    DEFINE          reduce using rule 5 (node -> if .)
    IFNDEF          reduce using rule 5 (node -> if .)
    ENDIF           reduce using rule 5 (node -> if .)
    STRUCT          reduce using rule 5 (node -> if .)
    CHAR            reduce using rule 5 (node -> if .)
    DOUBLE          reduce using rule 5 (node -> if .)
    FLOAT           reduce using rule 5 (node -> if .)
    INT             reduce using rule 5 (node -> if .)
    VOID            reduce using rule 5 (node -> if .)
    UINT8_T         reduce using rule 5 (node -> if .)
    UINT16_T        reduce using rule 5 (node -> if .)
    ID              reduce using rule 5 (node -> if .)
    LPAREN          reduce using rule 5 (node -> if .)
    NEGATE          reduce using rule 5 (node -> if .)
    MINUS           reduce using rule 5 (node -> if .)
    WHILE           reduce using rule 5 (node -> if .)
    IF              reduce using rule 5 (node -> if .)
    ELSE            reduce using rule 5 (node -> if .)
    FOR             reduce using rule 5 (node -> if .)
    CONST           reduce using rule 5 (node -> if .)
    EXTERN          reduce using rule 5 (node -> if .)
    INLINE          reduce using rule 5 (node -> if .)
    LONG            reduce using rule 5 (node -> if .)
    SHORT           reduce using rule 5 (node -> if .)
    SIGNED          reduce using rule 5 (node -> if .)
    UNSIGNED        reduce using rule 5 (node -> if .)
    VOLATILE        reduce using rule 5 (node -> if .)
    FLOAT_L         reduce using rule 5 (node -> if .)
    INT_L           reduce using rule 5 (node -> if .)
    CHAR_L          reduce using rule 5 (node -> if .)
    STRING_L        reduce using rule 5 (node -> if .)
    NONDECIMAL_L    reduce using rule 5 (node -> if .)
    $end            reduce using rule 5 (node -> if .)
    RBRACE          reduce using rule 5 (node -> if .)


state 6

    (6) node -> func_def .

    INCLUDE         reduce using rule 6 (node -> func_def .)
    DEFINE          reduce using rule 6 (node -> func_def .)
    IFNDEF          reduce using rule 6 (node -> func_def .)
    ENDIF           reduce using rule 6 (node -> func_def .)
    STRUCT          reduce using rule 6 (node -> func_def .)
    CHAR            reduce using rule 6 (node -> func_def .)
    DOUBLE          reduce using rule 6 (node -> func_def .)
    FLOAT           reduce using rule 6 (node -> func_def .)
    INT             reduce using rule 6 (node -> func_def .)
    VOID            reduce using rule 6 (node -> func_def .)
    UINT8_T         reduce using rule 6 (node -> func_def .)
    UINT16_T        reduce using rule 6 (node -> func_def .)
    ID              reduce using rule 6 (node -> func_def .)
    LPAREN          reduce using rule 6 (node -> func_def .)
    NEGATE          reduce using rule 6 (node -> func_def .)
    MINUS           reduce using rule 6 (node -> func_def .)
    WHILE           reduce using rule 6 (node -> func_def .)
    IF              reduce using rule 6 (node -> func_def .)
    ELSE            reduce using rule 6 (node -> func_def .)
    FOR             reduce using rule 6 (node -> func_def .)
    CONST           reduce using rule 6 (node -> func_def .)
    EXTERN          reduce using rule 6 (node -> func_def .)
    INLINE          reduce using rule 6 (node -> func_def .)
    LONG            reduce using rule 6 (node -> func_def .)
    SHORT           reduce using rule 6 (node -> func_def .)
    SIGNED          reduce using rule 6 (node -> func_def .)
    UNSIGNED        reduce using rule 6 (node -> func_def .)
    VOLATILE        reduce using rule 6 (node -> func_def .)
    FLOAT_L         reduce using rule 6 (node -> func_def .)
    INT_L           reduce using rule 6 (node -> func_def .)
    CHAR_L          reduce using rule 6 (node -> func_def .)
    STRING_L        reduce using rule 6 (node -> func_def .)
    NONDECIMAL_L    reduce using rule 6 (node -> func_def .)
    $end            reduce using rule 6 (node -> func_def .)
    RBRACE          reduce using rule 6 (node -> func_def .)


state 7

    (7) node -> func_decl .

    INCLUDE         reduce using rule 7 (node -> func_decl .)
    DEFINE          reduce using rule 7 (node -> func_decl .)
    IFNDEF          reduce using rule 7 (node -> func_decl .)
    ENDIF           reduce using rule 7 (node -> func_decl .)
    STRUCT          reduce using rule 7 (node -> func_decl .)
    CHAR            reduce using rule 7 (node -> func_decl .)
    DOUBLE          reduce using rule 7 (node -> func_decl .)
    FLOAT           reduce using rule 7 (node -> func_decl .)
    INT             reduce using rule 7 (node -> func_decl .)
    VOID            reduce using rule 7 (node -> func_decl .)
    UINT8_T         reduce using rule 7 (node -> func_decl .)
    UINT16_T        reduce using rule 7 (node -> func_decl .)
    ID              reduce using rule 7 (node -> func_decl .)
    LPAREN          reduce using rule 7 (node -> func_decl .)
    NEGATE          reduce using rule 7 (node -> func_decl .)
    MINUS           reduce using rule 7 (node -> func_decl .)
    WHILE           reduce using rule 7 (node -> func_decl .)
    IF              reduce using rule 7 (node -> func_decl .)
    ELSE            reduce using rule 7 (node -> func_decl .)
    FOR             reduce using rule 7 (node -> func_decl .)
    CONST           reduce using rule 7 (node -> func_decl .)
    EXTERN          reduce using rule 7 (node -> func_decl .)
    INLINE          reduce using rule 7 (node -> func_decl .)
    LONG            reduce using rule 7 (node -> func_decl .)
    SHORT           reduce using rule 7 (node -> func_decl .)
    SIGNED          reduce using rule 7 (node -> func_decl .)
    UNSIGNED        reduce using rule 7 (node -> func_decl .)
    VOLATILE        reduce using rule 7 (node -> func_decl .)
    FLOAT_L         reduce using rule 7 (node -> func_decl .)
    INT_L           reduce using rule 7 (node -> func_decl .)
    CHAR_L          reduce using rule 7 (node -> func_decl .)
    STRING_L        reduce using rule 7 (node -> func_decl .)
    NONDECIMAL_L    reduce using rule 7 (node -> func_decl .)
    $end            reduce using rule 7 (node -> func_decl .)
    RBRACE          reduce using rule 7 (node -> func_decl .)


state 8

    (8) node -> statement .

    INCLUDE         reduce using rule 8 (node -> statement .)
    DEFINE          reduce using rule 8 (node -> statement .)
    IFNDEF          reduce using rule 8 (node -> statement .)
    ENDIF           reduce using rule 8 (node -> statement .)
    STRUCT          reduce using rule 8 (node -> statement .)
    CHAR            reduce using rule 8 (node -> statement .)
    DOUBLE          reduce using rule 8 (node -> statement .)
    FLOAT           reduce using rule 8 (node -> statement .)
    INT             reduce using rule 8 (node -> statement .)
    VOID            reduce using rule 8 (node -> statement .)
    UINT8_T         reduce using rule 8 (node -> statement .)
    UINT16_T        reduce using rule 8 (node -> statement .)
    ID              reduce using rule 8 (node -> statement .)
    LPAREN          reduce using rule 8 (node -> statement .)
    NEGATE          reduce using rule 8 (node -> statement .)
    MINUS           reduce using rule 8 (node -> statement .)
    WHILE           reduce using rule 8 (node -> statement .)
    IF              reduce using rule 8 (node -> statement .)
    ELSE            reduce using rule 8 (node -> statement .)
    FOR             reduce using rule 8 (node -> statement .)
    CONST           reduce using rule 8 (node -> statement .)
    EXTERN          reduce using rule 8 (node -> statement .)
    INLINE          reduce using rule 8 (node -> statement .)
    LONG            reduce using rule 8 (node -> statement .)
    SHORT           reduce using rule 8 (node -> statement .)
    SIGNED          reduce using rule 8 (node -> statement .)
    UNSIGNED        reduce using rule 8 (node -> statement .)
    VOLATILE        reduce using rule 8 (node -> statement .)
    FLOAT_L         reduce using rule 8 (node -> statement .)
    INT_L           reduce using rule 8 (node -> statement .)
    CHAR_L          reduce using rule 8 (node -> statement .)
    STRING_L        reduce using rule 8 (node -> statement .)
    NONDECIMAL_L    reduce using rule 8 (node -> statement .)
    $end            reduce using rule 8 (node -> statement .)
    RBRACE          reduce using rule 8 (node -> statement .)


state 9

    (9) node -> control_expr .

    INCLUDE         reduce using rule 9 (node -> control_expr .)
    DEFINE          reduce using rule 9 (node -> control_expr .)
    IFNDEF          reduce using rule 9 (node -> control_expr .)
    ENDIF           reduce using rule 9 (node -> control_expr .)
    STRUCT          reduce using rule 9 (node -> control_expr .)
    CHAR            reduce using rule 9 (node -> control_expr .)
    DOUBLE          reduce using rule 9 (node -> control_expr .)
    FLOAT           reduce using rule 9 (node -> control_expr .)
    INT             reduce using rule 9 (node -> control_expr .)
    VOID            reduce using rule 9 (node -> control_expr .)
    UINT8_T         reduce using rule 9 (node -> control_expr .)
    UINT16_T        reduce using rule 9 (node -> control_expr .)
    ID              reduce using rule 9 (node -> control_expr .)
    LPAREN          reduce using rule 9 (node -> control_expr .)
    NEGATE          reduce using rule 9 (node -> control_expr .)
    MINUS           reduce using rule 9 (node -> control_expr .)
    WHILE           reduce using rule 9 (node -> control_expr .)
    IF              reduce using rule 9 (node -> control_expr .)
    ELSE            reduce using rule 9 (node -> control_expr .)
    FOR             reduce using rule 9 (node -> control_expr .)
    CONST           reduce using rule 9 (node -> control_expr .)
    EXTERN          reduce using rule 9 (node -> control_expr .)
    INLINE          reduce using rule 9 (node -> control_expr .)
    LONG            reduce using rule 9 (node -> control_expr .)
    SHORT           reduce using rule 9 (node -> control_expr .)
    SIGNED          reduce using rule 9 (node -> control_expr .)
    UNSIGNED        reduce using rule 9 (node -> control_expr .)
    VOLATILE        reduce using rule 9 (node -> control_expr .)
    FLOAT_L         reduce using rule 9 (node -> control_expr .)
    INT_L           reduce using rule 9 (node -> control_expr .)
    CHAR_L          reduce using rule 9 (node -> control_expr .)
    STRING_L        reduce using rule 9 (node -> control_expr .)
    NONDECIMAL_L    reduce using rule 9 (node -> control_expr .)
    $end            reduce using rule 9 (node -> control_expr .)
    RBRACE          reduce using rule 9 (node -> control_expr .)


state 10

    (10) node -> struct_def .

    INCLUDE         reduce using rule 10 (node -> struct_def .)
    DEFINE          reduce using rule 10 (node -> struct_def .)
    IFNDEF          reduce using rule 10 (node -> struct_def .)
    ENDIF           reduce using rule 10 (node -> struct_def .)
    STRUCT          reduce using rule 10 (node -> struct_def .)
    CHAR            reduce using rule 10 (node -> struct_def .)
    DOUBLE          reduce using rule 10 (node -> struct_def .)
    FLOAT           reduce using rule 10 (node -> struct_def .)
    INT             reduce using rule 10 (node -> struct_def .)
    VOID            reduce using rule 10 (node -> struct_def .)
    UINT8_T         reduce using rule 10 (node -> struct_def .)
    UINT16_T        reduce using rule 10 (node -> struct_def .)
    ID              reduce using rule 10 (node -> struct_def .)
    LPAREN          reduce using rule 10 (node -> struct_def .)
    NEGATE          reduce using rule 10 (node -> struct_def .)
    MINUS           reduce using rule 10 (node -> struct_def .)
    WHILE           reduce using rule 10 (node -> struct_def .)
    IF              reduce using rule 10 (node -> struct_def .)
    ELSE            reduce using rule 10 (node -> struct_def .)
    FOR             reduce using rule 10 (node -> struct_def .)
    CONST           reduce using rule 10 (node -> struct_def .)
    EXTERN          reduce using rule 10 (node -> struct_def .)
    INLINE          reduce using rule 10 (node -> struct_def .)
    LONG            reduce using rule 10 (node -> struct_def .)
    SHORT           reduce using rule 10 (node -> struct_def .)
    SIGNED          reduce using rule 10 (node -> struct_def .)
    UNSIGNED        reduce using rule 10 (node -> struct_def .)
    VOLATILE        reduce using rule 10 (node -> struct_def .)
    FLOAT_L         reduce using rule 10 (node -> struct_def .)
    INT_L           reduce using rule 10 (node -> struct_def .)
    CHAR_L          reduce using rule 10 (node -> struct_def .)
    STRING_L        reduce using rule 10 (node -> struct_def .)
    NONDECIMAL_L    reduce using rule 10 (node -> struct_def .)
    $end            reduce using rule 10 (node -> struct_def .)
    RBRACE          reduce using rule 10 (node -> struct_def .)


state 11

    (42) include -> INCLUDE .

    INCLUDE         reduce using rule 42 (include -> INCLUDE .)
    DEFINE          reduce using rule 42 (include -> INCLUDE .)
    IFNDEF          reduce using rule 42 (include -> INCLUDE .)
    ENDIF           reduce using rule 42 (include -> INCLUDE .)
    STRUCT          reduce using rule 42 (include -> INCLUDE .)
    CHAR            reduce using rule 42 (include -> INCLUDE .)
    DOUBLE          reduce using rule 42 (include -> INCLUDE .)
    FLOAT           reduce using rule 42 (include -> INCLUDE .)
    INT             reduce using rule 42 (include -> INCLUDE .)
    VOID            reduce using rule 42 (include -> INCLUDE .)
    UINT8_T         reduce using rule 42 (include -> INCLUDE .)
    UINT16_T        reduce using rule 42 (include -> INCLUDE .)
    ID              reduce using rule 42 (include -> INCLUDE .)
    LPAREN          reduce using rule 42 (include -> INCLUDE .)
    NEGATE          reduce using rule 42 (include -> INCLUDE .)
    MINUS           reduce using rule 42 (include -> INCLUDE .)
    WHILE           reduce using rule 42 (include -> INCLUDE .)
    IF              reduce using rule 42 (include -> INCLUDE .)
    ELSE            reduce using rule 42 (include -> INCLUDE .)
    FOR             reduce using rule 42 (include -> INCLUDE .)
    CONST           reduce using rule 42 (include -> INCLUDE .)
    EXTERN          reduce using rule 42 (include -> INCLUDE .)
    INLINE          reduce using rule 42 (include -> INCLUDE .)
    LONG            reduce using rule 42 (include -> INCLUDE .)
    SHORT           reduce using rule 42 (include -> INCLUDE .)
    SIGNED          reduce using rule 42 (include -> INCLUDE .)
    UNSIGNED        reduce using rule 42 (include -> INCLUDE .)
    VOLATILE        reduce using rule 42 (include -> INCLUDE .)
    FLOAT_L         reduce using rule 42 (include -> INCLUDE .)
    INT_L           reduce using rule 42 (include -> INCLUDE .)
    CHAR_L          reduce using rule 42 (include -> INCLUDE .)
    STRING_L        reduce using rule 42 (include -> INCLUDE .)
    NONDECIMAL_L    reduce using rule 42 (include -> INCLUDE .)
    $end            reduce using rule 42 (include -> INCLUDE .)
    RBRACE          reduce using rule 42 (include -> INCLUDE .)


state 12

    (43) define -> DEFINE .

    INCLUDE         reduce using rule 43 (define -> DEFINE .)
    DEFINE          reduce using rule 43 (define -> DEFINE .)
    IFNDEF          reduce using rule 43 (define -> DEFINE .)
    ENDIF           reduce using rule 43 (define -> DEFINE .)
    STRUCT          reduce using rule 43 (define -> DEFINE .)
    CHAR            reduce using rule 43 (define -> DEFINE .)
    DOUBLE          reduce using rule 43 (define -> DEFINE .)
    FLOAT           reduce using rule 43 (define -> DEFINE .)
    INT             reduce using rule 43 (define -> DEFINE .)
    VOID            reduce using rule 43 (define -> DEFINE .)
    UINT8_T         reduce using rule 43 (define -> DEFINE .)
    UINT16_T        reduce using rule 43 (define -> DEFINE .)
    ID              reduce using rule 43 (define -> DEFINE .)
    LPAREN          reduce using rule 43 (define -> DEFINE .)
    NEGATE          reduce using rule 43 (define -> DEFINE .)
    MINUS           reduce using rule 43 (define -> DEFINE .)
    WHILE           reduce using rule 43 (define -> DEFINE .)
    IF              reduce using rule 43 (define -> DEFINE .)
    ELSE            reduce using rule 43 (define -> DEFINE .)
    FOR             reduce using rule 43 (define -> DEFINE .)
    CONST           reduce using rule 43 (define -> DEFINE .)
    EXTERN          reduce using rule 43 (define -> DEFINE .)
    INLINE          reduce using rule 43 (define -> DEFINE .)
    LONG            reduce using rule 43 (define -> DEFINE .)
    SHORT           reduce using rule 43 (define -> DEFINE .)
    SIGNED          reduce using rule 43 (define -> DEFINE .)
    UNSIGNED        reduce using rule 43 (define -> DEFINE .)
    VOLATILE        reduce using rule 43 (define -> DEFINE .)
    FLOAT_L         reduce using rule 43 (define -> DEFINE .)
    INT_L           reduce using rule 43 (define -> DEFINE .)
    CHAR_L          reduce using rule 43 (define -> DEFINE .)
    STRING_L        reduce using rule 43 (define -> DEFINE .)
    NONDECIMAL_L    reduce using rule 43 (define -> DEFINE .)
    $end            reduce using rule 43 (define -> DEFINE .)
    RBRACE          reduce using rule 43 (define -> DEFINE .)


state 13

    (44) if -> IFNDEF .

    INCLUDE         reduce using rule 44 (if -> IFNDEF .)
    DEFINE          reduce using rule 44 (if -> IFNDEF .)
    IFNDEF          reduce using rule 44 (if -> IFNDEF .)
    ENDIF           reduce using rule 44 (if -> IFNDEF .)
    STRUCT          reduce using rule 44 (if -> IFNDEF .)
    CHAR            reduce using rule 44 (if -> IFNDEF .)
    DOUBLE          reduce using rule 44 (if -> IFNDEF .)
    FLOAT           reduce using rule 44 (if -> IFNDEF .)
    INT             reduce using rule 44 (if -> IFNDEF .)
    VOID            reduce using rule 44 (if -> IFNDEF .)
    UINT8_T         reduce using rule 44 (if -> IFNDEF .)
    UINT16_T        reduce using rule 44 (if -> IFNDEF .)
    ID              reduce using rule 44 (if -> IFNDEF .)
    LPAREN          reduce using rule 44 (if -> IFNDEF .)
    NEGATE          reduce using rule 44 (if -> IFNDEF .)
    MINUS           reduce using rule 44 (if -> IFNDEF .)
    WHILE           reduce using rule 44 (if -> IFNDEF .)
    IF              reduce using rule 44 (if -> IFNDEF .)
    ELSE            reduce using rule 44 (if -> IFNDEF .)
    FOR             reduce using rule 44 (if -> IFNDEF .)
    CONST           reduce using rule 44 (if -> IFNDEF .)
    EXTERN          reduce using rule 44 (if -> IFNDEF .)
    INLINE          reduce using rule 44 (if -> IFNDEF .)
    LONG            reduce using rule 44 (if -> IFNDEF .)
    SHORT           reduce using rule 44 (if -> IFNDEF .)
    SIGNED          reduce using rule 44 (if -> IFNDEF .)
    UNSIGNED        reduce using rule 44 (if -> IFNDEF .)
    VOLATILE        reduce using rule 44 (if -> IFNDEF .)
    FLOAT_L         reduce using rule 44 (if -> IFNDEF .)
    INT_L           reduce using rule 44 (if -> IFNDEF .)
    CHAR_L          reduce using rule 44 (if -> IFNDEF .)
    STRING_L        reduce using rule 44 (if -> IFNDEF .)
    NONDECIMAL_L    reduce using rule 44 (if -> IFNDEF .)
    $end            reduce using rule 44 (if -> IFNDEF .)
    RBRACE          reduce using rule 44 (if -> IFNDEF .)


state 14

    (45) if -> ENDIF .

    INCLUDE         reduce using rule 45 (if -> ENDIF .)
    DEFINE          reduce using rule 45 (if -> ENDIF .)
    IFNDEF          reduce using rule 45 (if -> ENDIF .)
    ENDIF           reduce using rule 45 (if -> ENDIF .)
    STRUCT          reduce using rule 45 (if -> ENDIF .)
    CHAR            reduce using rule 45 (if -> ENDIF .)
    DOUBLE          reduce using rule 45 (if -> ENDIF .)
    FLOAT           reduce using rule 45 (if -> ENDIF .)
    INT             reduce using rule 45 (if -> ENDIF .)
    VOID            reduce using rule 45 (if -> ENDIF .)
    UINT8_T         reduce using rule 45 (if -> ENDIF .)
    UINT16_T        reduce using rule 45 (if -> ENDIF .)
    ID              reduce using rule 45 (if -> ENDIF .)
    LPAREN          reduce using rule 45 (if -> ENDIF .)
    NEGATE          reduce using rule 45 (if -> ENDIF .)
    MINUS           reduce using rule 45 (if -> ENDIF .)
    WHILE           reduce using rule 45 (if -> ENDIF .)
    IF              reduce using rule 45 (if -> ENDIF .)
    ELSE            reduce using rule 45 (if -> ENDIF .)
    FOR             reduce using rule 45 (if -> ENDIF .)
    CONST           reduce using rule 45 (if -> ENDIF .)
    EXTERN          reduce using rule 45 (if -> ENDIF .)
    INLINE          reduce using rule 45 (if -> ENDIF .)
    LONG            reduce using rule 45 (if -> ENDIF .)
    SHORT           reduce using rule 45 (if -> ENDIF .)
    SIGNED          reduce using rule 45 (if -> ENDIF .)
    UNSIGNED        reduce using rule 45 (if -> ENDIF .)
    VOLATILE        reduce using rule 45 (if -> ENDIF .)
    FLOAT_L         reduce using rule 45 (if -> ENDIF .)
    INT_L           reduce using rule 45 (if -> ENDIF .)
    CHAR_L          reduce using rule 45 (if -> ENDIF .)
    STRING_L        reduce using rule 45 (if -> ENDIF .)
    NONDECIMAL_L    reduce using rule 45 (if -> ENDIF .)
    $end            reduce using rule 45 (if -> ENDIF .)
    RBRACE          reduce using rule 45 (if -> ENDIF .)


state 15

    (76) func_def -> dtype . ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (78) func_decl -> dtype . ID LPAREN func_arglist RPAREN SEMI
    (30) dtype -> dtype . ASTERISK
    (109) declare_var -> dtype . ID SEMI
    (112) init_var_ls -> dtype . ID assign
    (114) init_var_ls -> dtype . ID LBRACK RBRACK assign

    ID              shift and go to state 59
    ASTERISK        shift and go to state 60


state 16

    (29) dtype -> ID .
    (108) expression -> ID . INCREMENT
    (77) func_call -> ID . LPAREN func_arglist RPAREN
    (39) name -> ID .

  ! reduce/reduce conflict for ASTERISK resolved using rule 29 (dtype -> ID .)
    ID              reduce using rule 29 (dtype -> ID .)
    ASTERISK        reduce using rule 29 (dtype -> ID .)
    INCREMENT       shift and go to state 61
    LPAREN          shift and go to state 62
    LBRACK          reduce using rule 39 (name -> ID .)
    MEMBER          reduce using rule 39 (name -> ID .)
    PLUS            reduce using rule 39 (name -> ID .)
    MINUS           reduce using rule 39 (name -> ID .)
    DIVIDE          reduce using rule 39 (name -> ID .)
    LSHIFT          reduce using rule 39 (name -> ID .)
    RSHIFT          reduce using rule 39 (name -> ID .)
    PERCENT         reduce using rule 39 (name -> ID .)
    BITAND          reduce using rule 39 (name -> ID .)
    BITOR           reduce using rule 39 (name -> ID .)
    SIMPLE_ASSIGN   reduce using rule 39 (name -> ID .)
    COMPLEX_ASSIGN  reduce using rule 39 (name -> ID .)
    EQ              reduce using rule 39 (name -> ID .)
    NEQ             reduce using rule 39 (name -> ID .)
    LT              reduce using rule 39 (name -> ID .)
    GT              reduce using rule 39 (name -> ID .)
    LE              reduce using rule 39 (name -> ID .)
    GE              reduce using rule 39 (name -> ID .)
    AND             reduce using rule 39 (name -> ID .)
    OR              reduce using rule 39 (name -> ID .)

  ! ASTERISK        [ reduce using rule 39 (name -> ID .) ]


state 17

    (88) expression -> LPAREN . expression RPAREN
    (89) expression -> LPAREN . name RPAREN
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    ID              shift and go to state 65
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    expression                     shift and go to state 63
    name                           shift and go to state 64
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 18

    (83) statement -> init_var .

    INCLUDE         reduce using rule 83 (statement -> init_var .)
    DEFINE          reduce using rule 83 (statement -> init_var .)
    IFNDEF          reduce using rule 83 (statement -> init_var .)
    ENDIF           reduce using rule 83 (statement -> init_var .)
    STRUCT          reduce using rule 83 (statement -> init_var .)
    CHAR            reduce using rule 83 (statement -> init_var .)
    DOUBLE          reduce using rule 83 (statement -> init_var .)
    FLOAT           reduce using rule 83 (statement -> init_var .)
    INT             reduce using rule 83 (statement -> init_var .)
    VOID            reduce using rule 83 (statement -> init_var .)
    UINT8_T         reduce using rule 83 (statement -> init_var .)
    UINT16_T        reduce using rule 83 (statement -> init_var .)
    ID              reduce using rule 83 (statement -> init_var .)
    LPAREN          reduce using rule 83 (statement -> init_var .)
    NEGATE          reduce using rule 83 (statement -> init_var .)
    MINUS           reduce using rule 83 (statement -> init_var .)
    WHILE           reduce using rule 83 (statement -> init_var .)
    IF              reduce using rule 83 (statement -> init_var .)
    ELSE            reduce using rule 83 (statement -> init_var .)
    FOR             reduce using rule 83 (statement -> init_var .)
    CONST           reduce using rule 83 (statement -> init_var .)
    EXTERN          reduce using rule 83 (statement -> init_var .)
    INLINE          reduce using rule 83 (statement -> init_var .)
    LONG            reduce using rule 83 (statement -> init_var .)
    SHORT           reduce using rule 83 (statement -> init_var .)
    SIGNED          reduce using rule 83 (statement -> init_var .)
    UNSIGNED        reduce using rule 83 (statement -> init_var .)
    VOLATILE        reduce using rule 83 (statement -> init_var .)
    FLOAT_L         reduce using rule 83 (statement -> init_var .)
    INT_L           reduce using rule 83 (statement -> init_var .)
    CHAR_L          reduce using rule 83 (statement -> init_var .)
    STRING_L        reduce using rule 83 (statement -> init_var .)
    NONDECIMAL_L    reduce using rule 83 (statement -> init_var .)
    $end            reduce using rule 83 (statement -> init_var .)
    RBRACE          reduce using rule 83 (statement -> init_var .)


state 19

    (84) statement -> assign_var .

    INCLUDE         reduce using rule 84 (statement -> assign_var .)
    DEFINE          reduce using rule 84 (statement -> assign_var .)
    IFNDEF          reduce using rule 84 (statement -> assign_var .)
    ENDIF           reduce using rule 84 (statement -> assign_var .)
    STRUCT          reduce using rule 84 (statement -> assign_var .)
    CHAR            reduce using rule 84 (statement -> assign_var .)
    DOUBLE          reduce using rule 84 (statement -> assign_var .)
    FLOAT           reduce using rule 84 (statement -> assign_var .)
    INT             reduce using rule 84 (statement -> assign_var .)
    VOID            reduce using rule 84 (statement -> assign_var .)
    UINT8_T         reduce using rule 84 (statement -> assign_var .)
    UINT16_T        reduce using rule 84 (statement -> assign_var .)
    ID              reduce using rule 84 (statement -> assign_var .)
    LPAREN          reduce using rule 84 (statement -> assign_var .)
    NEGATE          reduce using rule 84 (statement -> assign_var .)
    MINUS           reduce using rule 84 (statement -> assign_var .)
    WHILE           reduce using rule 84 (statement -> assign_var .)
    IF              reduce using rule 84 (statement -> assign_var .)
    ELSE            reduce using rule 84 (statement -> assign_var .)
    FOR             reduce using rule 84 (statement -> assign_var .)
    CONST           reduce using rule 84 (statement -> assign_var .)
    EXTERN          reduce using rule 84 (statement -> assign_var .)
    INLINE          reduce using rule 84 (statement -> assign_var .)
    LONG            reduce using rule 84 (statement -> assign_var .)
    SHORT           reduce using rule 84 (statement -> assign_var .)
    SIGNED          reduce using rule 84 (statement -> assign_var .)
    UNSIGNED        reduce using rule 84 (statement -> assign_var .)
    VOLATILE        reduce using rule 84 (statement -> assign_var .)
    FLOAT_L         reduce using rule 84 (statement -> assign_var .)
    INT_L           reduce using rule 84 (statement -> assign_var .)
    CHAR_L          reduce using rule 84 (statement -> assign_var .)
    STRING_L        reduce using rule 84 (statement -> assign_var .)
    NONDECIMAL_L    reduce using rule 84 (statement -> assign_var .)
    $end            reduce using rule 84 (statement -> assign_var .)
    RBRACE          reduce using rule 84 (statement -> assign_var .)


state 20

    (85) statement -> declare_var .

    INCLUDE         reduce using rule 85 (statement -> declare_var .)
    DEFINE          reduce using rule 85 (statement -> declare_var .)
    IFNDEF          reduce using rule 85 (statement -> declare_var .)
    ENDIF           reduce using rule 85 (statement -> declare_var .)
    STRUCT          reduce using rule 85 (statement -> declare_var .)
    CHAR            reduce using rule 85 (statement -> declare_var .)
    DOUBLE          reduce using rule 85 (statement -> declare_var .)
    FLOAT           reduce using rule 85 (statement -> declare_var .)
    INT             reduce using rule 85 (statement -> declare_var .)
    VOID            reduce using rule 85 (statement -> declare_var .)
    UINT8_T         reduce using rule 85 (statement -> declare_var .)
    UINT16_T        reduce using rule 85 (statement -> declare_var .)
    ID              reduce using rule 85 (statement -> declare_var .)
    LPAREN          reduce using rule 85 (statement -> declare_var .)
    NEGATE          reduce using rule 85 (statement -> declare_var .)
    MINUS           reduce using rule 85 (statement -> declare_var .)
    WHILE           reduce using rule 85 (statement -> declare_var .)
    IF              reduce using rule 85 (statement -> declare_var .)
    ELSE            reduce using rule 85 (statement -> declare_var .)
    FOR             reduce using rule 85 (statement -> declare_var .)
    CONST           reduce using rule 85 (statement -> declare_var .)
    EXTERN          reduce using rule 85 (statement -> declare_var .)
    INLINE          reduce using rule 85 (statement -> declare_var .)
    LONG            reduce using rule 85 (statement -> declare_var .)
    SHORT           reduce using rule 85 (statement -> declare_var .)
    SIGNED          reduce using rule 85 (statement -> declare_var .)
    UNSIGNED        reduce using rule 85 (statement -> declare_var .)
    VOLATILE        reduce using rule 85 (statement -> declare_var .)
    FLOAT_L         reduce using rule 85 (statement -> declare_var .)
    INT_L           reduce using rule 85 (statement -> declare_var .)
    CHAR_L          reduce using rule 85 (statement -> declare_var .)
    STRING_L        reduce using rule 85 (statement -> declare_var .)
    NONDECIMAL_L    reduce using rule 85 (statement -> declare_var .)
    $end            reduce using rule 85 (statement -> declare_var .)
    RBRACE          reduce using rule 85 (statement -> declare_var .)


state 21

    (86) statement -> expression . SEMI
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    SEMI            shift and go to state 66
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    binop                          shift and go to state 67
    conditional                    shift and go to state 77

state 22

    (87) statement -> func_call . SEMI

    SEMI            shift and go to state 86


state 23

    (63) control_expr -> control . LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (64) control_expr -> control . LBRACE node_list RBRACE

    LPAREN          shift and go to state 87
    LBRACE          shift and go to state 88


state 24

    (65) control_expr -> for_loop . LBRACE node_list RBRACE

    LBRACE          shift and go to state 89


state 25

    (82) struct_def -> STRUCT . ID LBRACE node_list RBRACE SEMI
    (24) dtype -> STRUCT .
    (18) struct_type -> STRUCT . ID

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 90
    ASTERISK        reduce using rule 24 (dtype -> STRUCT .)

  ! ID              [ reduce using rule 24 (dtype -> STRUCT .) ]


state 26

    (20) dtype -> CHAR .

    ID              reduce using rule 20 (dtype -> CHAR .)
    ASTERISK        reduce using rule 20 (dtype -> CHAR .)
    RPAREN          reduce using rule 20 (dtype -> CHAR .)
    FLOAT_L         reduce using rule 20 (dtype -> CHAR .)
    INT_L           reduce using rule 20 (dtype -> CHAR .)
    CHAR_L          reduce using rule 20 (dtype -> CHAR .)
    STRING_L        reduce using rule 20 (dtype -> CHAR .)
    NONDECIMAL_L    reduce using rule 20 (dtype -> CHAR .)
    COMMA           reduce using rule 20 (dtype -> CHAR .)
    CHAR            reduce using rule 20 (dtype -> CHAR .)
    DOUBLE          reduce using rule 20 (dtype -> CHAR .)
    FLOAT           reduce using rule 20 (dtype -> CHAR .)
    INT             reduce using rule 20 (dtype -> CHAR .)
    STRUCT          reduce using rule 20 (dtype -> CHAR .)
    VOID            reduce using rule 20 (dtype -> CHAR .)
    UINT8_T         reduce using rule 20 (dtype -> CHAR .)
    UINT16_T        reduce using rule 20 (dtype -> CHAR .)
    LPAREN          reduce using rule 20 (dtype -> CHAR .)


state 27

    (21) dtype -> DOUBLE .

    ID              reduce using rule 21 (dtype -> DOUBLE .)
    ASTERISK        reduce using rule 21 (dtype -> DOUBLE .)
    RPAREN          reduce using rule 21 (dtype -> DOUBLE .)
    FLOAT_L         reduce using rule 21 (dtype -> DOUBLE .)
    INT_L           reduce using rule 21 (dtype -> DOUBLE .)
    CHAR_L          reduce using rule 21 (dtype -> DOUBLE .)
    STRING_L        reduce using rule 21 (dtype -> DOUBLE .)
    NONDECIMAL_L    reduce using rule 21 (dtype -> DOUBLE .)
    COMMA           reduce using rule 21 (dtype -> DOUBLE .)
    CHAR            reduce using rule 21 (dtype -> DOUBLE .)
    DOUBLE          reduce using rule 21 (dtype -> DOUBLE .)
    FLOAT           reduce using rule 21 (dtype -> DOUBLE .)
    INT             reduce using rule 21 (dtype -> DOUBLE .)
    STRUCT          reduce using rule 21 (dtype -> DOUBLE .)
    VOID            reduce using rule 21 (dtype -> DOUBLE .)
    UINT8_T         reduce using rule 21 (dtype -> DOUBLE .)
    UINT16_T        reduce using rule 21 (dtype -> DOUBLE .)
    LPAREN          reduce using rule 21 (dtype -> DOUBLE .)


state 28

    (22) dtype -> FLOAT .

    ID              reduce using rule 22 (dtype -> FLOAT .)
    ASTERISK        reduce using rule 22 (dtype -> FLOAT .)
    RPAREN          reduce using rule 22 (dtype -> FLOAT .)
    FLOAT_L         reduce using rule 22 (dtype -> FLOAT .)
    INT_L           reduce using rule 22 (dtype -> FLOAT .)
    CHAR_L          reduce using rule 22 (dtype -> FLOAT .)
    STRING_L        reduce using rule 22 (dtype -> FLOAT .)
    NONDECIMAL_L    reduce using rule 22 (dtype -> FLOAT .)
    COMMA           reduce using rule 22 (dtype -> FLOAT .)
    CHAR            reduce using rule 22 (dtype -> FLOAT .)
    DOUBLE          reduce using rule 22 (dtype -> FLOAT .)
    FLOAT           reduce using rule 22 (dtype -> FLOAT .)
    INT             reduce using rule 22 (dtype -> FLOAT .)
    STRUCT          reduce using rule 22 (dtype -> FLOAT .)
    VOID            reduce using rule 22 (dtype -> FLOAT .)
    UINT8_T         reduce using rule 22 (dtype -> FLOAT .)
    UINT16_T        reduce using rule 22 (dtype -> FLOAT .)
    LPAREN          reduce using rule 22 (dtype -> FLOAT .)


state 29

    (23) dtype -> INT .

    ID              reduce using rule 23 (dtype -> INT .)
    ASTERISK        reduce using rule 23 (dtype -> INT .)
    RPAREN          reduce using rule 23 (dtype -> INT .)
    FLOAT_L         reduce using rule 23 (dtype -> INT .)
    INT_L           reduce using rule 23 (dtype -> INT .)
    CHAR_L          reduce using rule 23 (dtype -> INT .)
    STRING_L        reduce using rule 23 (dtype -> INT .)
    NONDECIMAL_L    reduce using rule 23 (dtype -> INT .)
    COMMA           reduce using rule 23 (dtype -> INT .)
    CHAR            reduce using rule 23 (dtype -> INT .)
    DOUBLE          reduce using rule 23 (dtype -> INT .)
    FLOAT           reduce using rule 23 (dtype -> INT .)
    INT             reduce using rule 23 (dtype -> INT .)
    STRUCT          reduce using rule 23 (dtype -> INT .)
    VOID            reduce using rule 23 (dtype -> INT .)
    UINT8_T         reduce using rule 23 (dtype -> INT .)
    UINT16_T        reduce using rule 23 (dtype -> INT .)
    LPAREN          reduce using rule 23 (dtype -> INT .)


state 30

    (25) dtype -> VOID .

    ID              reduce using rule 25 (dtype -> VOID .)
    ASTERISK        reduce using rule 25 (dtype -> VOID .)
    RPAREN          reduce using rule 25 (dtype -> VOID .)
    FLOAT_L         reduce using rule 25 (dtype -> VOID .)
    INT_L           reduce using rule 25 (dtype -> VOID .)
    CHAR_L          reduce using rule 25 (dtype -> VOID .)
    STRING_L        reduce using rule 25 (dtype -> VOID .)
    NONDECIMAL_L    reduce using rule 25 (dtype -> VOID .)
    COMMA           reduce using rule 25 (dtype -> VOID .)
    CHAR            reduce using rule 25 (dtype -> VOID .)
    DOUBLE          reduce using rule 25 (dtype -> VOID .)
    FLOAT           reduce using rule 25 (dtype -> VOID .)
    INT             reduce using rule 25 (dtype -> VOID .)
    STRUCT          reduce using rule 25 (dtype -> VOID .)
    VOID            reduce using rule 25 (dtype -> VOID .)
    UINT8_T         reduce using rule 25 (dtype -> VOID .)
    UINT16_T        reduce using rule 25 (dtype -> VOID .)
    LPAREN          reduce using rule 25 (dtype -> VOID .)


state 31

    (26) dtype -> UINT8_T .

    ID              reduce using rule 26 (dtype -> UINT8_T .)
    ASTERISK        reduce using rule 26 (dtype -> UINT8_T .)
    RPAREN          reduce using rule 26 (dtype -> UINT8_T .)
    FLOAT_L         reduce using rule 26 (dtype -> UINT8_T .)
    INT_L           reduce using rule 26 (dtype -> UINT8_T .)
    CHAR_L          reduce using rule 26 (dtype -> UINT8_T .)
    STRING_L        reduce using rule 26 (dtype -> UINT8_T .)
    NONDECIMAL_L    reduce using rule 26 (dtype -> UINT8_T .)
    COMMA           reduce using rule 26 (dtype -> UINT8_T .)
    CHAR            reduce using rule 26 (dtype -> UINT8_T .)
    DOUBLE          reduce using rule 26 (dtype -> UINT8_T .)
    FLOAT           reduce using rule 26 (dtype -> UINT8_T .)
    INT             reduce using rule 26 (dtype -> UINT8_T .)
    STRUCT          reduce using rule 26 (dtype -> UINT8_T .)
    VOID            reduce using rule 26 (dtype -> UINT8_T .)
    UINT8_T         reduce using rule 26 (dtype -> UINT8_T .)
    UINT16_T        reduce using rule 26 (dtype -> UINT8_T .)
    LPAREN          reduce using rule 26 (dtype -> UINT8_T .)


state 32

    (27) dtype -> UINT16_T .

    ID              reduce using rule 27 (dtype -> UINT16_T .)
    ASTERISK        reduce using rule 27 (dtype -> UINT16_T .)
    RPAREN          reduce using rule 27 (dtype -> UINT16_T .)
    FLOAT_L         reduce using rule 27 (dtype -> UINT16_T .)
    INT_L           reduce using rule 27 (dtype -> UINT16_T .)
    CHAR_L          reduce using rule 27 (dtype -> UINT16_T .)
    STRING_L        reduce using rule 27 (dtype -> UINT16_T .)
    NONDECIMAL_L    reduce using rule 27 (dtype -> UINT16_T .)
    COMMA           reduce using rule 27 (dtype -> UINT16_T .)
    CHAR            reduce using rule 27 (dtype -> UINT16_T .)
    DOUBLE          reduce using rule 27 (dtype -> UINT16_T .)
    FLOAT           reduce using rule 27 (dtype -> UINT16_T .)
    INT             reduce using rule 27 (dtype -> UINT16_T .)
    STRUCT          reduce using rule 27 (dtype -> UINT16_T .)
    VOID            reduce using rule 27 (dtype -> UINT16_T .)
    UINT8_T         reduce using rule 27 (dtype -> UINT16_T .)
    UINT16_T        reduce using rule 27 (dtype -> UINT16_T .)
    LPAREN          reduce using rule 27 (dtype -> UINT16_T .)


state 33

    (28) dtype -> struct_type .

    ID              reduce using rule 28 (dtype -> struct_type .)
    ASTERISK        reduce using rule 28 (dtype -> struct_type .)
    RPAREN          reduce using rule 28 (dtype -> struct_type .)
    FLOAT_L         reduce using rule 28 (dtype -> struct_type .)
    INT_L           reduce using rule 28 (dtype -> struct_type .)
    CHAR_L          reduce using rule 28 (dtype -> struct_type .)
    STRING_L        reduce using rule 28 (dtype -> struct_type .)
    NONDECIMAL_L    reduce using rule 28 (dtype -> struct_type .)
    COMMA           reduce using rule 28 (dtype -> struct_type .)
    CHAR            reduce using rule 28 (dtype -> struct_type .)
    DOUBLE          reduce using rule 28 (dtype -> struct_type .)
    FLOAT           reduce using rule 28 (dtype -> struct_type .)
    INT             reduce using rule 28 (dtype -> struct_type .)
    STRUCT          reduce using rule 28 (dtype -> struct_type .)
    VOID            reduce using rule 28 (dtype -> struct_type .)
    UINT8_T         reduce using rule 28 (dtype -> struct_type .)
    UINT16_T        reduce using rule 28 (dtype -> struct_type .)
    LPAREN          reduce using rule 28 (dtype -> struct_type .)


state 34

    (118) init_var -> init_var_ls . init_var_rs
    (115) init_var_rs -> . name SEMI
    (116) init_var_rs -> . type_cast name SEMI
    (117) init_var_rs -> . func_call SEMI
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (19) type_cast -> . LPAREN dtype RPAREN
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    ID              shift and go to state 95
    LPAREN          shift and go to state 96
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    init_var_rs                    shift and go to state 91
    name                           shift and go to state 92
    type_cast                      shift and go to state 93
    func_call                      shift and go to state 94
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 35

    (124) assign_var -> assign_var_ls . assign_var_rs
    (120) assign_var_rs -> . expression SEMI
    (121) assign_var_rs -> . name SEMI
    (122) assign_var_rs -> . func_call SEMI
    (123) assign_var_rs -> . type_cast assign_var_rs SEMI
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (19) type_cast -> . LPAREN dtype RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    LPAREN          shift and go to state 102
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    ID              shift and go to state 103
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    assign_var_rs                  shift and go to state 97
    expression                     shift and go to state 98
    name                           shift and go to state 99
    func_call                      shift and go to state 100
    type_cast                      shift and go to state 101
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 36

    (110) declare_var -> modifier . dtype ID SEMI
    (111) init_var_ls -> modifier . dtype ID assign
    (113) init_var_ls -> modifier . dtype ID LBRACK RBRACK assign
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (18) struct_type -> . STRUCT ID

    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    STRUCT          shift and go to state 106
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    ID              shift and go to state 105

    dtype                          shift and go to state 104
    struct_type                    shift and go to state 33

state 37

    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (119) assign_var_ls -> name . assign
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (16) assign -> . SIMPLE_ASSIGN
    (17) assign -> . COMPLEX_ASSIGN
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    SIMPLE_ASSIGN   shift and go to state 111
    COMPLEX_ASSIGN  shift and go to state 112
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    binop                          shift and go to state 107
    assign                         shift and go to state 108
    conditional                    shift and go to state 77

state 38

    (90) expression -> NEGATE . expression
    (92) expression -> NEGATE . name
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    ID              shift and go to state 65
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    expression                     shift and go to state 113
    name                           shift and go to state 114
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 39

    (91) expression -> MINUS . expression
    (93) expression -> MINUS . name
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    ID              shift and go to state 65
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    expression                     shift and go to state 115
    name                           shift and go to state 116
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 40

    (46) control -> WHILE .

    LPAREN          reduce using rule 46 (control -> WHILE .)
    LBRACE          reduce using rule 46 (control -> WHILE .)


state 41

    (47) control -> IF .

    LPAREN          reduce using rule 47 (control -> IF .)
    LBRACE          reduce using rule 47 (control -> IF .)


state 42

    (48) control -> ELSE .

    LPAREN          reduce using rule 48 (control -> ELSE .)
    LBRACE          reduce using rule 48 (control -> ELSE .)


state 43

    (62) for_loop -> FOR . LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN

    LPAREN          shift and go to state 117


state 44

    (31) modifier -> CONST .

    CHAR            reduce using rule 31 (modifier -> CONST .)
    DOUBLE          reduce using rule 31 (modifier -> CONST .)
    FLOAT           reduce using rule 31 (modifier -> CONST .)
    INT             reduce using rule 31 (modifier -> CONST .)
    STRUCT          reduce using rule 31 (modifier -> CONST .)
    VOID            reduce using rule 31 (modifier -> CONST .)
    UINT8_T         reduce using rule 31 (modifier -> CONST .)
    UINT16_T        reduce using rule 31 (modifier -> CONST .)
    ID              reduce using rule 31 (modifier -> CONST .)


state 45

    (32) modifier -> EXTERN .

    CHAR            reduce using rule 32 (modifier -> EXTERN .)
    DOUBLE          reduce using rule 32 (modifier -> EXTERN .)
    FLOAT           reduce using rule 32 (modifier -> EXTERN .)
    INT             reduce using rule 32 (modifier -> EXTERN .)
    STRUCT          reduce using rule 32 (modifier -> EXTERN .)
    VOID            reduce using rule 32 (modifier -> EXTERN .)
    UINT8_T         reduce using rule 32 (modifier -> EXTERN .)
    UINT16_T        reduce using rule 32 (modifier -> EXTERN .)
    ID              reduce using rule 32 (modifier -> EXTERN .)


state 46

    (33) modifier -> INLINE .

    CHAR            reduce using rule 33 (modifier -> INLINE .)
    DOUBLE          reduce using rule 33 (modifier -> INLINE .)
    FLOAT           reduce using rule 33 (modifier -> INLINE .)
    INT             reduce using rule 33 (modifier -> INLINE .)
    STRUCT          reduce using rule 33 (modifier -> INLINE .)
    VOID            reduce using rule 33 (modifier -> INLINE .)
    UINT8_T         reduce using rule 33 (modifier -> INLINE .)
    UINT16_T        reduce using rule 33 (modifier -> INLINE .)
    ID              reduce using rule 33 (modifier -> INLINE .)


state 47

    (34) modifier -> LONG .

    CHAR            reduce using rule 34 (modifier -> LONG .)
    DOUBLE          reduce using rule 34 (modifier -> LONG .)
    FLOAT           reduce using rule 34 (modifier -> LONG .)
    INT             reduce using rule 34 (modifier -> LONG .)
    STRUCT          reduce using rule 34 (modifier -> LONG .)
    VOID            reduce using rule 34 (modifier -> LONG .)
    UINT8_T         reduce using rule 34 (modifier -> LONG .)
    UINT16_T        reduce using rule 34 (modifier -> LONG .)
    ID              reduce using rule 34 (modifier -> LONG .)


state 48

    (35) modifier -> SHORT .

    CHAR            reduce using rule 35 (modifier -> SHORT .)
    DOUBLE          reduce using rule 35 (modifier -> SHORT .)
    FLOAT           reduce using rule 35 (modifier -> SHORT .)
    INT             reduce using rule 35 (modifier -> SHORT .)
    STRUCT          reduce using rule 35 (modifier -> SHORT .)
    VOID            reduce using rule 35 (modifier -> SHORT .)
    UINT8_T         reduce using rule 35 (modifier -> SHORT .)
    UINT16_T        reduce using rule 35 (modifier -> SHORT .)
    ID              reduce using rule 35 (modifier -> SHORT .)


state 49

    (36) modifier -> SIGNED .

    CHAR            reduce using rule 36 (modifier -> SIGNED .)
    DOUBLE          reduce using rule 36 (modifier -> SIGNED .)
    FLOAT           reduce using rule 36 (modifier -> SIGNED .)
    INT             reduce using rule 36 (modifier -> SIGNED .)
    STRUCT          reduce using rule 36 (modifier -> SIGNED .)
    VOID            reduce using rule 36 (modifier -> SIGNED .)
    UINT8_T         reduce using rule 36 (modifier -> SIGNED .)
    UINT16_T        reduce using rule 36 (modifier -> SIGNED .)
    ID              reduce using rule 36 (modifier -> SIGNED .)


state 50

    (37) modifier -> UNSIGNED .

    CHAR            reduce using rule 37 (modifier -> UNSIGNED .)
    DOUBLE          reduce using rule 37 (modifier -> UNSIGNED .)
    FLOAT           reduce using rule 37 (modifier -> UNSIGNED .)
    INT             reduce using rule 37 (modifier -> UNSIGNED .)
    STRUCT          reduce using rule 37 (modifier -> UNSIGNED .)
    VOID            reduce using rule 37 (modifier -> UNSIGNED .)
    UINT8_T         reduce using rule 37 (modifier -> UNSIGNED .)
    UINT16_T        reduce using rule 37 (modifier -> UNSIGNED .)
    ID              reduce using rule 37 (modifier -> UNSIGNED .)


state 51

    (38) modifier -> VOLATILE .

    CHAR            reduce using rule 38 (modifier -> VOLATILE .)
    DOUBLE          reduce using rule 38 (modifier -> VOLATILE .)
    FLOAT           reduce using rule 38 (modifier -> VOLATILE .)
    INT             reduce using rule 38 (modifier -> VOLATILE .)
    STRUCT          reduce using rule 38 (modifier -> VOLATILE .)
    VOID            reduce using rule 38 (modifier -> VOLATILE .)
    UINT8_T         reduce using rule 38 (modifier -> VOLATILE .)
    UINT16_T        reduce using rule 38 (modifier -> VOLATILE .)
    ID              reduce using rule 38 (modifier -> VOLATILE .)


state 52

    (40) name -> literal .

    LBRACK          reduce using rule 40 (name -> literal .)
    MEMBER          reduce using rule 40 (name -> literal .)
    PLUS            reduce using rule 40 (name -> literal .)
    MINUS           reduce using rule 40 (name -> literal .)
    ASTERISK        reduce using rule 40 (name -> literal .)
    DIVIDE          reduce using rule 40 (name -> literal .)
    LSHIFT          reduce using rule 40 (name -> literal .)
    RSHIFT          reduce using rule 40 (name -> literal .)
    PERCENT         reduce using rule 40 (name -> literal .)
    BITAND          reduce using rule 40 (name -> literal .)
    BITOR           reduce using rule 40 (name -> literal .)
    SIMPLE_ASSIGN   reduce using rule 40 (name -> literal .)
    COMPLEX_ASSIGN  reduce using rule 40 (name -> literal .)
    EQ              reduce using rule 40 (name -> literal .)
    NEQ             reduce using rule 40 (name -> literal .)
    LT              reduce using rule 40 (name -> literal .)
    GT              reduce using rule 40 (name -> literal .)
    LE              reduce using rule 40 (name -> literal .)
    GE              reduce using rule 40 (name -> literal .)
    AND             reduce using rule 40 (name -> literal .)
    OR              reduce using rule 40 (name -> literal .)
    RPAREN          reduce using rule 40 (name -> literal .)
    SEMI            reduce using rule 40 (name -> literal .)
    RBRACK          reduce using rule 40 (name -> literal .)
    COMMA           reduce using rule 40 (name -> literal .)
    ID              reduce using rule 40 (name -> literal .)
    CHAR            reduce using rule 40 (name -> literal .)
    DOUBLE          reduce using rule 40 (name -> literal .)
    FLOAT           reduce using rule 40 (name -> literal .)
    INT             reduce using rule 40 (name -> literal .)
    STRUCT          reduce using rule 40 (name -> literal .)
    VOID            reduce using rule 40 (name -> literal .)
    UINT8_T         reduce using rule 40 (name -> literal .)
    UINT16_T        reduce using rule 40 (name -> literal .)
    LPAREN          reduce using rule 40 (name -> literal .)
    FLOAT_L         reduce using rule 40 (name -> literal .)
    INT_L           reduce using rule 40 (name -> literal .)
    CHAR_L          reduce using rule 40 (name -> literal .)
    STRING_L        reduce using rule 40 (name -> literal .)
    NONDECIMAL_L    reduce using rule 40 (name -> literal .)


state 53

    (41) name -> access .

    LBRACK          reduce using rule 41 (name -> access .)
    MEMBER          reduce using rule 41 (name -> access .)
    PLUS            reduce using rule 41 (name -> access .)
    MINUS           reduce using rule 41 (name -> access .)
    ASTERISK        reduce using rule 41 (name -> access .)
    DIVIDE          reduce using rule 41 (name -> access .)
    LSHIFT          reduce using rule 41 (name -> access .)
    RSHIFT          reduce using rule 41 (name -> access .)
    PERCENT         reduce using rule 41 (name -> access .)
    BITAND          reduce using rule 41 (name -> access .)
    BITOR           reduce using rule 41 (name -> access .)
    SIMPLE_ASSIGN   reduce using rule 41 (name -> access .)
    COMPLEX_ASSIGN  reduce using rule 41 (name -> access .)
    EQ              reduce using rule 41 (name -> access .)
    NEQ             reduce using rule 41 (name -> access .)
    LT              reduce using rule 41 (name -> access .)
    GT              reduce using rule 41 (name -> access .)
    LE              reduce using rule 41 (name -> access .)
    GE              reduce using rule 41 (name -> access .)
    AND             reduce using rule 41 (name -> access .)
    OR              reduce using rule 41 (name -> access .)
    RPAREN          reduce using rule 41 (name -> access .)
    SEMI            reduce using rule 41 (name -> access .)
    RBRACK          reduce using rule 41 (name -> access .)
    COMMA           reduce using rule 41 (name -> access .)
    ID              reduce using rule 41 (name -> access .)
    CHAR            reduce using rule 41 (name -> access .)
    DOUBLE          reduce using rule 41 (name -> access .)
    FLOAT           reduce using rule 41 (name -> access .)
    INT             reduce using rule 41 (name -> access .)
    STRUCT          reduce using rule 41 (name -> access .)
    VOID            reduce using rule 41 (name -> access .)
    UINT8_T         reduce using rule 41 (name -> access .)
    UINT16_T        reduce using rule 41 (name -> access .)
    LPAREN          reduce using rule 41 (name -> access .)
    FLOAT_L         reduce using rule 41 (name -> access .)
    INT_L           reduce using rule 41 (name -> access .)
    CHAR_L          reduce using rule 41 (name -> access .)
    STRING_L        reduce using rule 41 (name -> access .)
    NONDECIMAL_L    reduce using rule 41 (name -> access .)


state 54

    (11) literal -> FLOAT_L .

    LBRACK          reduce using rule 11 (literal -> FLOAT_L .)
    MEMBER          reduce using rule 11 (literal -> FLOAT_L .)
    PLUS            reduce using rule 11 (literal -> FLOAT_L .)
    MINUS           reduce using rule 11 (literal -> FLOAT_L .)
    ASTERISK        reduce using rule 11 (literal -> FLOAT_L .)
    DIVIDE          reduce using rule 11 (literal -> FLOAT_L .)
    LSHIFT          reduce using rule 11 (literal -> FLOAT_L .)
    RSHIFT          reduce using rule 11 (literal -> FLOAT_L .)
    PERCENT         reduce using rule 11 (literal -> FLOAT_L .)
    BITAND          reduce using rule 11 (literal -> FLOAT_L .)
    BITOR           reduce using rule 11 (literal -> FLOAT_L .)
    SIMPLE_ASSIGN   reduce using rule 11 (literal -> FLOAT_L .)
    COMPLEX_ASSIGN  reduce using rule 11 (literal -> FLOAT_L .)
    EQ              reduce using rule 11 (literal -> FLOAT_L .)
    NEQ             reduce using rule 11 (literal -> FLOAT_L .)
    LT              reduce using rule 11 (literal -> FLOAT_L .)
    GT              reduce using rule 11 (literal -> FLOAT_L .)
    LE              reduce using rule 11 (literal -> FLOAT_L .)
    GE              reduce using rule 11 (literal -> FLOAT_L .)
    AND             reduce using rule 11 (literal -> FLOAT_L .)
    OR              reduce using rule 11 (literal -> FLOAT_L .)
    RPAREN          reduce using rule 11 (literal -> FLOAT_L .)
    SEMI            reduce using rule 11 (literal -> FLOAT_L .)
    RBRACK          reduce using rule 11 (literal -> FLOAT_L .)
    COMMA           reduce using rule 11 (literal -> FLOAT_L .)
    ID              reduce using rule 11 (literal -> FLOAT_L .)
    CHAR            reduce using rule 11 (literal -> FLOAT_L .)
    DOUBLE          reduce using rule 11 (literal -> FLOAT_L .)
    FLOAT           reduce using rule 11 (literal -> FLOAT_L .)
    INT             reduce using rule 11 (literal -> FLOAT_L .)
    STRUCT          reduce using rule 11 (literal -> FLOAT_L .)
    VOID            reduce using rule 11 (literal -> FLOAT_L .)
    UINT8_T         reduce using rule 11 (literal -> FLOAT_L .)
    UINT16_T        reduce using rule 11 (literal -> FLOAT_L .)
    LPAREN          reduce using rule 11 (literal -> FLOAT_L .)
    FLOAT_L         reduce using rule 11 (literal -> FLOAT_L .)
    INT_L           reduce using rule 11 (literal -> FLOAT_L .)
    CHAR_L          reduce using rule 11 (literal -> FLOAT_L .)
    STRING_L        reduce using rule 11 (literal -> FLOAT_L .)
    NONDECIMAL_L    reduce using rule 11 (literal -> FLOAT_L .)


state 55

    (12) literal -> INT_L .

    LBRACK          reduce using rule 12 (literal -> INT_L .)
    MEMBER          reduce using rule 12 (literal -> INT_L .)
    PLUS            reduce using rule 12 (literal -> INT_L .)
    MINUS           reduce using rule 12 (literal -> INT_L .)
    ASTERISK        reduce using rule 12 (literal -> INT_L .)
    DIVIDE          reduce using rule 12 (literal -> INT_L .)
    LSHIFT          reduce using rule 12 (literal -> INT_L .)
    RSHIFT          reduce using rule 12 (literal -> INT_L .)
    PERCENT         reduce using rule 12 (literal -> INT_L .)
    BITAND          reduce using rule 12 (literal -> INT_L .)
    BITOR           reduce using rule 12 (literal -> INT_L .)
    SIMPLE_ASSIGN   reduce using rule 12 (literal -> INT_L .)
    COMPLEX_ASSIGN  reduce using rule 12 (literal -> INT_L .)
    EQ              reduce using rule 12 (literal -> INT_L .)
    NEQ             reduce using rule 12 (literal -> INT_L .)
    LT              reduce using rule 12 (literal -> INT_L .)
    GT              reduce using rule 12 (literal -> INT_L .)
    LE              reduce using rule 12 (literal -> INT_L .)
    GE              reduce using rule 12 (literal -> INT_L .)
    AND             reduce using rule 12 (literal -> INT_L .)
    OR              reduce using rule 12 (literal -> INT_L .)
    RPAREN          reduce using rule 12 (literal -> INT_L .)
    SEMI            reduce using rule 12 (literal -> INT_L .)
    RBRACK          reduce using rule 12 (literal -> INT_L .)
    COMMA           reduce using rule 12 (literal -> INT_L .)
    ID              reduce using rule 12 (literal -> INT_L .)
    CHAR            reduce using rule 12 (literal -> INT_L .)
    DOUBLE          reduce using rule 12 (literal -> INT_L .)
    FLOAT           reduce using rule 12 (literal -> INT_L .)
    INT             reduce using rule 12 (literal -> INT_L .)
    STRUCT          reduce using rule 12 (literal -> INT_L .)
    VOID            reduce using rule 12 (literal -> INT_L .)
    UINT8_T         reduce using rule 12 (literal -> INT_L .)
    UINT16_T        reduce using rule 12 (literal -> INT_L .)
    LPAREN          reduce using rule 12 (literal -> INT_L .)
    FLOAT_L         reduce using rule 12 (literal -> INT_L .)
    INT_L           reduce using rule 12 (literal -> INT_L .)
    CHAR_L          reduce using rule 12 (literal -> INT_L .)
    STRING_L        reduce using rule 12 (literal -> INT_L .)
    NONDECIMAL_L    reduce using rule 12 (literal -> INT_L .)


state 56

    (13) literal -> CHAR_L .

    LBRACK          reduce using rule 13 (literal -> CHAR_L .)
    MEMBER          reduce using rule 13 (literal -> CHAR_L .)
    PLUS            reduce using rule 13 (literal -> CHAR_L .)
    MINUS           reduce using rule 13 (literal -> CHAR_L .)
    ASTERISK        reduce using rule 13 (literal -> CHAR_L .)
    DIVIDE          reduce using rule 13 (literal -> CHAR_L .)
    LSHIFT          reduce using rule 13 (literal -> CHAR_L .)
    RSHIFT          reduce using rule 13 (literal -> CHAR_L .)
    PERCENT         reduce using rule 13 (literal -> CHAR_L .)
    BITAND          reduce using rule 13 (literal -> CHAR_L .)
    BITOR           reduce using rule 13 (literal -> CHAR_L .)
    SIMPLE_ASSIGN   reduce using rule 13 (literal -> CHAR_L .)
    COMPLEX_ASSIGN  reduce using rule 13 (literal -> CHAR_L .)
    EQ              reduce using rule 13 (literal -> CHAR_L .)
    NEQ             reduce using rule 13 (literal -> CHAR_L .)
    LT              reduce using rule 13 (literal -> CHAR_L .)
    GT              reduce using rule 13 (literal -> CHAR_L .)
    LE              reduce using rule 13 (literal -> CHAR_L .)
    GE              reduce using rule 13 (literal -> CHAR_L .)
    AND             reduce using rule 13 (literal -> CHAR_L .)
    OR              reduce using rule 13 (literal -> CHAR_L .)
    RPAREN          reduce using rule 13 (literal -> CHAR_L .)
    SEMI            reduce using rule 13 (literal -> CHAR_L .)
    RBRACK          reduce using rule 13 (literal -> CHAR_L .)
    COMMA           reduce using rule 13 (literal -> CHAR_L .)
    ID              reduce using rule 13 (literal -> CHAR_L .)
    CHAR            reduce using rule 13 (literal -> CHAR_L .)
    DOUBLE          reduce using rule 13 (literal -> CHAR_L .)
    FLOAT           reduce using rule 13 (literal -> CHAR_L .)
    INT             reduce using rule 13 (literal -> CHAR_L .)
    STRUCT          reduce using rule 13 (literal -> CHAR_L .)
    VOID            reduce using rule 13 (literal -> CHAR_L .)
    UINT8_T         reduce using rule 13 (literal -> CHAR_L .)
    UINT16_T        reduce using rule 13 (literal -> CHAR_L .)
    LPAREN          reduce using rule 13 (literal -> CHAR_L .)
    FLOAT_L         reduce using rule 13 (literal -> CHAR_L .)
    INT_L           reduce using rule 13 (literal -> CHAR_L .)
    CHAR_L          reduce using rule 13 (literal -> CHAR_L .)
    STRING_L        reduce using rule 13 (literal -> CHAR_L .)
    NONDECIMAL_L    reduce using rule 13 (literal -> CHAR_L .)


state 57

    (14) literal -> STRING_L .

    LBRACK          reduce using rule 14 (literal -> STRING_L .)
    MEMBER          reduce using rule 14 (literal -> STRING_L .)
    PLUS            reduce using rule 14 (literal -> STRING_L .)
    MINUS           reduce using rule 14 (literal -> STRING_L .)
    ASTERISK        reduce using rule 14 (literal -> STRING_L .)
    DIVIDE          reduce using rule 14 (literal -> STRING_L .)
    LSHIFT          reduce using rule 14 (literal -> STRING_L .)
    RSHIFT          reduce using rule 14 (literal -> STRING_L .)
    PERCENT         reduce using rule 14 (literal -> STRING_L .)
    BITAND          reduce using rule 14 (literal -> STRING_L .)
    BITOR           reduce using rule 14 (literal -> STRING_L .)
    SIMPLE_ASSIGN   reduce using rule 14 (literal -> STRING_L .)
    COMPLEX_ASSIGN  reduce using rule 14 (literal -> STRING_L .)
    EQ              reduce using rule 14 (literal -> STRING_L .)
    NEQ             reduce using rule 14 (literal -> STRING_L .)
    LT              reduce using rule 14 (literal -> STRING_L .)
    GT              reduce using rule 14 (literal -> STRING_L .)
    LE              reduce using rule 14 (literal -> STRING_L .)
    GE              reduce using rule 14 (literal -> STRING_L .)
    AND             reduce using rule 14 (literal -> STRING_L .)
    OR              reduce using rule 14 (literal -> STRING_L .)
    RPAREN          reduce using rule 14 (literal -> STRING_L .)
    SEMI            reduce using rule 14 (literal -> STRING_L .)
    RBRACK          reduce using rule 14 (literal -> STRING_L .)
    COMMA           reduce using rule 14 (literal -> STRING_L .)
    ID              reduce using rule 14 (literal -> STRING_L .)
    CHAR            reduce using rule 14 (literal -> STRING_L .)
    DOUBLE          reduce using rule 14 (literal -> STRING_L .)
    FLOAT           reduce using rule 14 (literal -> STRING_L .)
    INT             reduce using rule 14 (literal -> STRING_L .)
    STRUCT          reduce using rule 14 (literal -> STRING_L .)
    VOID            reduce using rule 14 (literal -> STRING_L .)
    UINT8_T         reduce using rule 14 (literal -> STRING_L .)
    UINT16_T        reduce using rule 14 (literal -> STRING_L .)
    LPAREN          reduce using rule 14 (literal -> STRING_L .)
    FLOAT_L         reduce using rule 14 (literal -> STRING_L .)
    INT_L           reduce using rule 14 (literal -> STRING_L .)
    CHAR_L          reduce using rule 14 (literal -> STRING_L .)
    STRING_L        reduce using rule 14 (literal -> STRING_L .)
    NONDECIMAL_L    reduce using rule 14 (literal -> STRING_L .)


state 58

    (15) literal -> NONDECIMAL_L .

    LBRACK          reduce using rule 15 (literal -> NONDECIMAL_L .)
    MEMBER          reduce using rule 15 (literal -> NONDECIMAL_L .)
    PLUS            reduce using rule 15 (literal -> NONDECIMAL_L .)
    MINUS           reduce using rule 15 (literal -> NONDECIMAL_L .)
    ASTERISK        reduce using rule 15 (literal -> NONDECIMAL_L .)
    DIVIDE          reduce using rule 15 (literal -> NONDECIMAL_L .)
    LSHIFT          reduce using rule 15 (literal -> NONDECIMAL_L .)
    RSHIFT          reduce using rule 15 (literal -> NONDECIMAL_L .)
    PERCENT         reduce using rule 15 (literal -> NONDECIMAL_L .)
    BITAND          reduce using rule 15 (literal -> NONDECIMAL_L .)
    BITOR           reduce using rule 15 (literal -> NONDECIMAL_L .)
    SIMPLE_ASSIGN   reduce using rule 15 (literal -> NONDECIMAL_L .)
    COMPLEX_ASSIGN  reduce using rule 15 (literal -> NONDECIMAL_L .)
    EQ              reduce using rule 15 (literal -> NONDECIMAL_L .)
    NEQ             reduce using rule 15 (literal -> NONDECIMAL_L .)
    LT              reduce using rule 15 (literal -> NONDECIMAL_L .)
    GT              reduce using rule 15 (literal -> NONDECIMAL_L .)
    LE              reduce using rule 15 (literal -> NONDECIMAL_L .)
    GE              reduce using rule 15 (literal -> NONDECIMAL_L .)
    AND             reduce using rule 15 (literal -> NONDECIMAL_L .)
    OR              reduce using rule 15 (literal -> NONDECIMAL_L .)
    RPAREN          reduce using rule 15 (literal -> NONDECIMAL_L .)
    SEMI            reduce using rule 15 (literal -> NONDECIMAL_L .)
    RBRACK          reduce using rule 15 (literal -> NONDECIMAL_L .)
    COMMA           reduce using rule 15 (literal -> NONDECIMAL_L .)
    ID              reduce using rule 15 (literal -> NONDECIMAL_L .)
    CHAR            reduce using rule 15 (literal -> NONDECIMAL_L .)
    DOUBLE          reduce using rule 15 (literal -> NONDECIMAL_L .)
    FLOAT           reduce using rule 15 (literal -> NONDECIMAL_L .)
    INT             reduce using rule 15 (literal -> NONDECIMAL_L .)
    STRUCT          reduce using rule 15 (literal -> NONDECIMAL_L .)
    VOID            reduce using rule 15 (literal -> NONDECIMAL_L .)
    UINT8_T         reduce using rule 15 (literal -> NONDECIMAL_L .)
    UINT16_T        reduce using rule 15 (literal -> NONDECIMAL_L .)
    LPAREN          reduce using rule 15 (literal -> NONDECIMAL_L .)
    FLOAT_L         reduce using rule 15 (literal -> NONDECIMAL_L .)
    INT_L           reduce using rule 15 (literal -> NONDECIMAL_L .)
    CHAR_L          reduce using rule 15 (literal -> NONDECIMAL_L .)
    STRING_L        reduce using rule 15 (literal -> NONDECIMAL_L .)
    NONDECIMAL_L    reduce using rule 15 (literal -> NONDECIMAL_L .)


state 59

    (76) func_def -> dtype ID . LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (78) func_decl -> dtype ID . LPAREN func_arglist RPAREN SEMI
    (109) declare_var -> dtype ID . SEMI
    (112) init_var_ls -> dtype ID . assign
    (114) init_var_ls -> dtype ID . LBRACK RBRACK assign
    (16) assign -> . SIMPLE_ASSIGN
    (17) assign -> . COMPLEX_ASSIGN

    LPAREN          shift and go to state 118
    SEMI            shift and go to state 119
    LBRACK          shift and go to state 121
    SIMPLE_ASSIGN   shift and go to state 111
    COMPLEX_ASSIGN  shift and go to state 112

    assign                         shift and go to state 120

state 60

    (30) dtype -> dtype ASTERISK .

    ID              reduce using rule 30 (dtype -> dtype ASTERISK .)
    ASTERISK        reduce using rule 30 (dtype -> dtype ASTERISK .)
    RPAREN          reduce using rule 30 (dtype -> dtype ASTERISK .)
    FLOAT_L         reduce using rule 30 (dtype -> dtype ASTERISK .)
    INT_L           reduce using rule 30 (dtype -> dtype ASTERISK .)
    CHAR_L          reduce using rule 30 (dtype -> dtype ASTERISK .)
    STRING_L        reduce using rule 30 (dtype -> dtype ASTERISK .)
    NONDECIMAL_L    reduce using rule 30 (dtype -> dtype ASTERISK .)
    COMMA           reduce using rule 30 (dtype -> dtype ASTERISK .)
    CHAR            reduce using rule 30 (dtype -> dtype ASTERISK .)
    DOUBLE          reduce using rule 30 (dtype -> dtype ASTERISK .)
    FLOAT           reduce using rule 30 (dtype -> dtype ASTERISK .)
    INT             reduce using rule 30 (dtype -> dtype ASTERISK .)
    STRUCT          reduce using rule 30 (dtype -> dtype ASTERISK .)
    VOID            reduce using rule 30 (dtype -> dtype ASTERISK .)
    UINT8_T         reduce using rule 30 (dtype -> dtype ASTERISK .)
    UINT16_T        reduce using rule 30 (dtype -> dtype ASTERISK .)
    LPAREN          reduce using rule 30 (dtype -> dtype ASTERISK .)


state 61

    (108) expression -> ID INCREMENT .

    SEMI            reduce using rule 108 (expression -> ID INCREMENT .)
    PLUS            reduce using rule 108 (expression -> ID INCREMENT .)
    MINUS           reduce using rule 108 (expression -> ID INCREMENT .)
    ASTERISK        reduce using rule 108 (expression -> ID INCREMENT .)
    DIVIDE          reduce using rule 108 (expression -> ID INCREMENT .)
    LSHIFT          reduce using rule 108 (expression -> ID INCREMENT .)
    RSHIFT          reduce using rule 108 (expression -> ID INCREMENT .)
    PERCENT         reduce using rule 108 (expression -> ID INCREMENT .)
    BITAND          reduce using rule 108 (expression -> ID INCREMENT .)
    BITOR           reduce using rule 108 (expression -> ID INCREMENT .)
    EQ              reduce using rule 108 (expression -> ID INCREMENT .)
    NEQ             reduce using rule 108 (expression -> ID INCREMENT .)
    LT              reduce using rule 108 (expression -> ID INCREMENT .)
    GT              reduce using rule 108 (expression -> ID INCREMENT .)
    LE              reduce using rule 108 (expression -> ID INCREMENT .)
    GE              reduce using rule 108 (expression -> ID INCREMENT .)
    AND             reduce using rule 108 (expression -> ID INCREMENT .)
    OR              reduce using rule 108 (expression -> ID INCREMENT .)
    RPAREN          reduce using rule 108 (expression -> ID INCREMENT .)
    RBRACK          reduce using rule 108 (expression -> ID INCREMENT .)
    COMMA           reduce using rule 108 (expression -> ID INCREMENT .)
    ID              reduce using rule 108 (expression -> ID INCREMENT .)
    CHAR            reduce using rule 108 (expression -> ID INCREMENT .)
    DOUBLE          reduce using rule 108 (expression -> ID INCREMENT .)
    FLOAT           reduce using rule 108 (expression -> ID INCREMENT .)
    INT             reduce using rule 108 (expression -> ID INCREMENT .)
    STRUCT          reduce using rule 108 (expression -> ID INCREMENT .)
    VOID            reduce using rule 108 (expression -> ID INCREMENT .)
    UINT8_T         reduce using rule 108 (expression -> ID INCREMENT .)
    UINT16_T        reduce using rule 108 (expression -> ID INCREMENT .)
    LPAREN          reduce using rule 108 (expression -> ID INCREMENT .)
    FLOAT_L         reduce using rule 108 (expression -> ID INCREMENT .)
    INT_L           reduce using rule 108 (expression -> ID INCREMENT .)
    CHAR_L          reduce using rule 108 (expression -> ID INCREMENT .)
    STRING_L        reduce using rule 108 (expression -> ID INCREMENT .)
    NONDECIMAL_L    reduce using rule 108 (expression -> ID INCREMENT .)


state 62

    (77) func_call -> ID LPAREN . func_arglist RPAREN
    (73) func_arglist -> .
    (74) func_arglist -> . func_arglist func_arg
    (75) func_arglist -> . func_arglist func_arg COMMA

    RPAREN          reduce using rule 73 (func_arglist -> .)
    ID              reduce using rule 73 (func_arglist -> .)
    CHAR            reduce using rule 73 (func_arglist -> .)
    DOUBLE          reduce using rule 73 (func_arglist -> .)
    FLOAT           reduce using rule 73 (func_arglist -> .)
    INT             reduce using rule 73 (func_arglist -> .)
    STRUCT          reduce using rule 73 (func_arglist -> .)
    VOID            reduce using rule 73 (func_arglist -> .)
    UINT8_T         reduce using rule 73 (func_arglist -> .)
    UINT16_T        reduce using rule 73 (func_arglist -> .)
    LPAREN          reduce using rule 73 (func_arglist -> .)
    FLOAT_L         reduce using rule 73 (func_arglist -> .)
    INT_L           reduce using rule 73 (func_arglist -> .)
    CHAR_L          reduce using rule 73 (func_arglist -> .)
    STRING_L        reduce using rule 73 (func_arglist -> .)
    NONDECIMAL_L    reduce using rule 73 (func_arglist -> .)

    func_arglist                   shift and go to state 122

state 63

    (88) expression -> LPAREN expression . RPAREN
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    RPAREN          shift and go to state 123
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    binop                          shift and go to state 67
    conditional                    shift and go to state 77

state 64

    (89) expression -> LPAREN name . RPAREN
    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    RPAREN          shift and go to state 124
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    binop                          shift and go to state 107
    conditional                    shift and go to state 77

state 65

    (108) expression -> ID . INCREMENT
    (39) name -> ID .

    INCREMENT       shift and go to state 61
    RPAREN          reduce using rule 39 (name -> ID .)
    LBRACK          reduce using rule 39 (name -> ID .)
    MEMBER          reduce using rule 39 (name -> ID .)
    PLUS            reduce using rule 39 (name -> ID .)
    MINUS           reduce using rule 39 (name -> ID .)
    ASTERISK        reduce using rule 39 (name -> ID .)
    DIVIDE          reduce using rule 39 (name -> ID .)
    LSHIFT          reduce using rule 39 (name -> ID .)
    RSHIFT          reduce using rule 39 (name -> ID .)
    PERCENT         reduce using rule 39 (name -> ID .)
    BITAND          reduce using rule 39 (name -> ID .)
    BITOR           reduce using rule 39 (name -> ID .)
    EQ              reduce using rule 39 (name -> ID .)
    NEQ             reduce using rule 39 (name -> ID .)
    LT              reduce using rule 39 (name -> ID .)
    GT              reduce using rule 39 (name -> ID .)
    LE              reduce using rule 39 (name -> ID .)
    GE              reduce using rule 39 (name -> ID .)
    AND             reduce using rule 39 (name -> ID .)
    OR              reduce using rule 39 (name -> ID .)
    SEMI            reduce using rule 39 (name -> ID .)
    RBRACK          reduce using rule 39 (name -> ID .)
    COMMA           reduce using rule 39 (name -> ID .)
    ID              reduce using rule 39 (name -> ID .)
    CHAR            reduce using rule 39 (name -> ID .)
    DOUBLE          reduce using rule 39 (name -> ID .)
    FLOAT           reduce using rule 39 (name -> ID .)
    INT             reduce using rule 39 (name -> ID .)
    STRUCT          reduce using rule 39 (name -> ID .)
    VOID            reduce using rule 39 (name -> ID .)
    UINT8_T         reduce using rule 39 (name -> ID .)
    UINT16_T        reduce using rule 39 (name -> ID .)
    LPAREN          reduce using rule 39 (name -> ID .)
    FLOAT_L         reduce using rule 39 (name -> ID .)
    INT_L           reduce using rule 39 (name -> ID .)
    CHAR_L          reduce using rule 39 (name -> ID .)
    STRING_L        reduce using rule 39 (name -> ID .)
    NONDECIMAL_L    reduce using rule 39 (name -> ID .)


state 66

    (86) statement -> expression SEMI .

    INCLUDE         reduce using rule 86 (statement -> expression SEMI .)
    DEFINE          reduce using rule 86 (statement -> expression SEMI .)
    IFNDEF          reduce using rule 86 (statement -> expression SEMI .)
    ENDIF           reduce using rule 86 (statement -> expression SEMI .)
    STRUCT          reduce using rule 86 (statement -> expression SEMI .)
    CHAR            reduce using rule 86 (statement -> expression SEMI .)
    DOUBLE          reduce using rule 86 (statement -> expression SEMI .)
    FLOAT           reduce using rule 86 (statement -> expression SEMI .)
    INT             reduce using rule 86 (statement -> expression SEMI .)
    VOID            reduce using rule 86 (statement -> expression SEMI .)
    UINT8_T         reduce using rule 86 (statement -> expression SEMI .)
    UINT16_T        reduce using rule 86 (statement -> expression SEMI .)
    ID              reduce using rule 86 (statement -> expression SEMI .)
    LPAREN          reduce using rule 86 (statement -> expression SEMI .)
    NEGATE          reduce using rule 86 (statement -> expression SEMI .)
    MINUS           reduce using rule 86 (statement -> expression SEMI .)
    WHILE           reduce using rule 86 (statement -> expression SEMI .)
    IF              reduce using rule 86 (statement -> expression SEMI .)
    ELSE            reduce using rule 86 (statement -> expression SEMI .)
    FOR             reduce using rule 86 (statement -> expression SEMI .)
    CONST           reduce using rule 86 (statement -> expression SEMI .)
    EXTERN          reduce using rule 86 (statement -> expression SEMI .)
    INLINE          reduce using rule 86 (statement -> expression SEMI .)
    LONG            reduce using rule 86 (statement -> expression SEMI .)
    SHORT           reduce using rule 86 (statement -> expression SEMI .)
    SIGNED          reduce using rule 86 (statement -> expression SEMI .)
    UNSIGNED        reduce using rule 86 (statement -> expression SEMI .)
    VOLATILE        reduce using rule 86 (statement -> expression SEMI .)
    FLOAT_L         reduce using rule 86 (statement -> expression SEMI .)
    INT_L           reduce using rule 86 (statement -> expression SEMI .)
    CHAR_L          reduce using rule 86 (statement -> expression SEMI .)
    STRING_L        reduce using rule 86 (statement -> expression SEMI .)
    NONDECIMAL_L    reduce using rule 86 (statement -> expression SEMI .)
    $end            reduce using rule 86 (statement -> expression SEMI .)
    RBRACE          reduce using rule 86 (statement -> expression SEMI .)


state 67

    (104) expression -> expression binop . name
    (107) expression -> expression binop . expression
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    ID              shift and go to state 127
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    expression                     shift and go to state 125
    name                           shift and go to state 126
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 68

    (94) binop -> PLUS .

    ID              reduce using rule 94 (binop -> PLUS .)
    LPAREN          reduce using rule 94 (binop -> PLUS .)
    NEGATE          reduce using rule 94 (binop -> PLUS .)
    MINUS           reduce using rule 94 (binop -> PLUS .)
    FLOAT_L         reduce using rule 94 (binop -> PLUS .)
    INT_L           reduce using rule 94 (binop -> PLUS .)
    CHAR_L          reduce using rule 94 (binop -> PLUS .)
    STRING_L        reduce using rule 94 (binop -> PLUS .)
    NONDECIMAL_L    reduce using rule 94 (binop -> PLUS .)


state 69

    (95) binop -> MINUS .

    ID              reduce using rule 95 (binop -> MINUS .)
    LPAREN          reduce using rule 95 (binop -> MINUS .)
    NEGATE          reduce using rule 95 (binop -> MINUS .)
    MINUS           reduce using rule 95 (binop -> MINUS .)
    FLOAT_L         reduce using rule 95 (binop -> MINUS .)
    INT_L           reduce using rule 95 (binop -> MINUS .)
    CHAR_L          reduce using rule 95 (binop -> MINUS .)
    STRING_L        reduce using rule 95 (binop -> MINUS .)
    NONDECIMAL_L    reduce using rule 95 (binop -> MINUS .)


state 70

    (96) binop -> ASTERISK .

    ID              reduce using rule 96 (binop -> ASTERISK .)
    LPAREN          reduce using rule 96 (binop -> ASTERISK .)
    NEGATE          reduce using rule 96 (binop -> ASTERISK .)
    MINUS           reduce using rule 96 (binop -> ASTERISK .)
    FLOAT_L         reduce using rule 96 (binop -> ASTERISK .)
    INT_L           reduce using rule 96 (binop -> ASTERISK .)
    CHAR_L          reduce using rule 96 (binop -> ASTERISK .)
    STRING_L        reduce using rule 96 (binop -> ASTERISK .)
    NONDECIMAL_L    reduce using rule 96 (binop -> ASTERISK .)


state 71

    (97) binop -> DIVIDE .

    ID              reduce using rule 97 (binop -> DIVIDE .)
    LPAREN          reduce using rule 97 (binop -> DIVIDE .)
    NEGATE          reduce using rule 97 (binop -> DIVIDE .)
    MINUS           reduce using rule 97 (binop -> DIVIDE .)
    FLOAT_L         reduce using rule 97 (binop -> DIVIDE .)
    INT_L           reduce using rule 97 (binop -> DIVIDE .)
    CHAR_L          reduce using rule 97 (binop -> DIVIDE .)
    STRING_L        reduce using rule 97 (binop -> DIVIDE .)
    NONDECIMAL_L    reduce using rule 97 (binop -> DIVIDE .)


state 72

    (98) binop -> LSHIFT .

    ID              reduce using rule 98 (binop -> LSHIFT .)
    LPAREN          reduce using rule 98 (binop -> LSHIFT .)
    NEGATE          reduce using rule 98 (binop -> LSHIFT .)
    MINUS           reduce using rule 98 (binop -> LSHIFT .)
    FLOAT_L         reduce using rule 98 (binop -> LSHIFT .)
    INT_L           reduce using rule 98 (binop -> LSHIFT .)
    CHAR_L          reduce using rule 98 (binop -> LSHIFT .)
    STRING_L        reduce using rule 98 (binop -> LSHIFT .)
    NONDECIMAL_L    reduce using rule 98 (binop -> LSHIFT .)


state 73

    (99) binop -> RSHIFT .

    ID              reduce using rule 99 (binop -> RSHIFT .)
    LPAREN          reduce using rule 99 (binop -> RSHIFT .)
    NEGATE          reduce using rule 99 (binop -> RSHIFT .)
    MINUS           reduce using rule 99 (binop -> RSHIFT .)
    FLOAT_L         reduce using rule 99 (binop -> RSHIFT .)
    INT_L           reduce using rule 99 (binop -> RSHIFT .)
    CHAR_L          reduce using rule 99 (binop -> RSHIFT .)
    STRING_L        reduce using rule 99 (binop -> RSHIFT .)
    NONDECIMAL_L    reduce using rule 99 (binop -> RSHIFT .)


state 74

    (100) binop -> PERCENT .

    ID              reduce using rule 100 (binop -> PERCENT .)
    LPAREN          reduce using rule 100 (binop -> PERCENT .)
    NEGATE          reduce using rule 100 (binop -> PERCENT .)
    MINUS           reduce using rule 100 (binop -> PERCENT .)
    FLOAT_L         reduce using rule 100 (binop -> PERCENT .)
    INT_L           reduce using rule 100 (binop -> PERCENT .)
    CHAR_L          reduce using rule 100 (binop -> PERCENT .)
    STRING_L        reduce using rule 100 (binop -> PERCENT .)
    NONDECIMAL_L    reduce using rule 100 (binop -> PERCENT .)


state 75

    (101) binop -> BITAND .

    ID              reduce using rule 101 (binop -> BITAND .)
    LPAREN          reduce using rule 101 (binop -> BITAND .)
    NEGATE          reduce using rule 101 (binop -> BITAND .)
    MINUS           reduce using rule 101 (binop -> BITAND .)
    FLOAT_L         reduce using rule 101 (binop -> BITAND .)
    INT_L           reduce using rule 101 (binop -> BITAND .)
    CHAR_L          reduce using rule 101 (binop -> BITAND .)
    STRING_L        reduce using rule 101 (binop -> BITAND .)
    NONDECIMAL_L    reduce using rule 101 (binop -> BITAND .)


state 76

    (102) binop -> BITOR .

    ID              reduce using rule 102 (binop -> BITOR .)
    LPAREN          reduce using rule 102 (binop -> BITOR .)
    NEGATE          reduce using rule 102 (binop -> BITOR .)
    MINUS           reduce using rule 102 (binop -> BITOR .)
    FLOAT_L         reduce using rule 102 (binop -> BITOR .)
    INT_L           reduce using rule 102 (binop -> BITOR .)
    CHAR_L          reduce using rule 102 (binop -> BITOR .)
    STRING_L        reduce using rule 102 (binop -> BITOR .)
    NONDECIMAL_L    reduce using rule 102 (binop -> BITOR .)


state 77

    (103) binop -> conditional .

    ID              reduce using rule 103 (binop -> conditional .)
    LPAREN          reduce using rule 103 (binop -> conditional .)
    NEGATE          reduce using rule 103 (binop -> conditional .)
    MINUS           reduce using rule 103 (binop -> conditional .)
    FLOAT_L         reduce using rule 103 (binop -> conditional .)
    INT_L           reduce using rule 103 (binop -> conditional .)
    CHAR_L          reduce using rule 103 (binop -> conditional .)
    STRING_L        reduce using rule 103 (binop -> conditional .)
    NONDECIMAL_L    reduce using rule 103 (binop -> conditional .)


state 78

    (49) conditional -> EQ .

    ID              reduce using rule 49 (conditional -> EQ .)
    LPAREN          reduce using rule 49 (conditional -> EQ .)
    NEGATE          reduce using rule 49 (conditional -> EQ .)
    MINUS           reduce using rule 49 (conditional -> EQ .)
    FLOAT_L         reduce using rule 49 (conditional -> EQ .)
    INT_L           reduce using rule 49 (conditional -> EQ .)
    CHAR_L          reduce using rule 49 (conditional -> EQ .)
    STRING_L        reduce using rule 49 (conditional -> EQ .)
    NONDECIMAL_L    reduce using rule 49 (conditional -> EQ .)


state 79

    (50) conditional -> NEQ .

    ID              reduce using rule 50 (conditional -> NEQ .)
    LPAREN          reduce using rule 50 (conditional -> NEQ .)
    NEGATE          reduce using rule 50 (conditional -> NEQ .)
    MINUS           reduce using rule 50 (conditional -> NEQ .)
    FLOAT_L         reduce using rule 50 (conditional -> NEQ .)
    INT_L           reduce using rule 50 (conditional -> NEQ .)
    CHAR_L          reduce using rule 50 (conditional -> NEQ .)
    STRING_L        reduce using rule 50 (conditional -> NEQ .)
    NONDECIMAL_L    reduce using rule 50 (conditional -> NEQ .)


state 80

    (51) conditional -> LT .

    ID              reduce using rule 51 (conditional -> LT .)
    LPAREN          reduce using rule 51 (conditional -> LT .)
    NEGATE          reduce using rule 51 (conditional -> LT .)
    MINUS           reduce using rule 51 (conditional -> LT .)
    FLOAT_L         reduce using rule 51 (conditional -> LT .)
    INT_L           reduce using rule 51 (conditional -> LT .)
    CHAR_L          reduce using rule 51 (conditional -> LT .)
    STRING_L        reduce using rule 51 (conditional -> LT .)
    NONDECIMAL_L    reduce using rule 51 (conditional -> LT .)


state 81

    (52) conditional -> GT .

    ID              reduce using rule 52 (conditional -> GT .)
    LPAREN          reduce using rule 52 (conditional -> GT .)
    NEGATE          reduce using rule 52 (conditional -> GT .)
    MINUS           reduce using rule 52 (conditional -> GT .)
    FLOAT_L         reduce using rule 52 (conditional -> GT .)
    INT_L           reduce using rule 52 (conditional -> GT .)
    CHAR_L          reduce using rule 52 (conditional -> GT .)
    STRING_L        reduce using rule 52 (conditional -> GT .)
    NONDECIMAL_L    reduce using rule 52 (conditional -> GT .)


state 82

    (53) conditional -> LE .

    ID              reduce using rule 53 (conditional -> LE .)
    LPAREN          reduce using rule 53 (conditional -> LE .)
    NEGATE          reduce using rule 53 (conditional -> LE .)
    MINUS           reduce using rule 53 (conditional -> LE .)
    FLOAT_L         reduce using rule 53 (conditional -> LE .)
    INT_L           reduce using rule 53 (conditional -> LE .)
    CHAR_L          reduce using rule 53 (conditional -> LE .)
    STRING_L        reduce using rule 53 (conditional -> LE .)
    NONDECIMAL_L    reduce using rule 53 (conditional -> LE .)


state 83

    (54) conditional -> GE .

    ID              reduce using rule 54 (conditional -> GE .)
    LPAREN          reduce using rule 54 (conditional -> GE .)
    NEGATE          reduce using rule 54 (conditional -> GE .)
    MINUS           reduce using rule 54 (conditional -> GE .)
    FLOAT_L         reduce using rule 54 (conditional -> GE .)
    INT_L           reduce using rule 54 (conditional -> GE .)
    CHAR_L          reduce using rule 54 (conditional -> GE .)
    STRING_L        reduce using rule 54 (conditional -> GE .)
    NONDECIMAL_L    reduce using rule 54 (conditional -> GE .)


state 84

    (55) conditional -> AND .

    ID              reduce using rule 55 (conditional -> AND .)
    LPAREN          reduce using rule 55 (conditional -> AND .)
    NEGATE          reduce using rule 55 (conditional -> AND .)
    MINUS           reduce using rule 55 (conditional -> AND .)
    FLOAT_L         reduce using rule 55 (conditional -> AND .)
    INT_L           reduce using rule 55 (conditional -> AND .)
    CHAR_L          reduce using rule 55 (conditional -> AND .)
    STRING_L        reduce using rule 55 (conditional -> AND .)
    NONDECIMAL_L    reduce using rule 55 (conditional -> AND .)


state 85

    (56) conditional -> OR .

    ID              reduce using rule 56 (conditional -> OR .)
    LPAREN          reduce using rule 56 (conditional -> OR .)
    NEGATE          reduce using rule 56 (conditional -> OR .)
    MINUS           reduce using rule 56 (conditional -> OR .)
    FLOAT_L         reduce using rule 56 (conditional -> OR .)
    INT_L           reduce using rule 56 (conditional -> OR .)
    CHAR_L          reduce using rule 56 (conditional -> OR .)
    STRING_L        reduce using rule 56 (conditional -> OR .)
    NONDECIMAL_L    reduce using rule 56 (conditional -> OR .)


state 86

    (87) statement -> func_call SEMI .

    INCLUDE         reduce using rule 87 (statement -> func_call SEMI .)
    DEFINE          reduce using rule 87 (statement -> func_call SEMI .)
    IFNDEF          reduce using rule 87 (statement -> func_call SEMI .)
    ENDIF           reduce using rule 87 (statement -> func_call SEMI .)
    STRUCT          reduce using rule 87 (statement -> func_call SEMI .)
    CHAR            reduce using rule 87 (statement -> func_call SEMI .)
    DOUBLE          reduce using rule 87 (statement -> func_call SEMI .)
    FLOAT           reduce using rule 87 (statement -> func_call SEMI .)
    INT             reduce using rule 87 (statement -> func_call SEMI .)
    VOID            reduce using rule 87 (statement -> func_call SEMI .)
    UINT8_T         reduce using rule 87 (statement -> func_call SEMI .)
    UINT16_T        reduce using rule 87 (statement -> func_call SEMI .)
    ID              reduce using rule 87 (statement -> func_call SEMI .)
    LPAREN          reduce using rule 87 (statement -> func_call SEMI .)
    NEGATE          reduce using rule 87 (statement -> func_call SEMI .)
    MINUS           reduce using rule 87 (statement -> func_call SEMI .)
    WHILE           reduce using rule 87 (statement -> func_call SEMI .)
    IF              reduce using rule 87 (statement -> func_call SEMI .)
    ELSE            reduce using rule 87 (statement -> func_call SEMI .)
    FOR             reduce using rule 87 (statement -> func_call SEMI .)
    CONST           reduce using rule 87 (statement -> func_call SEMI .)
    EXTERN          reduce using rule 87 (statement -> func_call SEMI .)
    INLINE          reduce using rule 87 (statement -> func_call SEMI .)
    LONG            reduce using rule 87 (statement -> func_call SEMI .)
    SHORT           reduce using rule 87 (statement -> func_call SEMI .)
    SIGNED          reduce using rule 87 (statement -> func_call SEMI .)
    UNSIGNED        reduce using rule 87 (statement -> func_call SEMI .)
    VOLATILE        reduce using rule 87 (statement -> func_call SEMI .)
    FLOAT_L         reduce using rule 87 (statement -> func_call SEMI .)
    INT_L           reduce using rule 87 (statement -> func_call SEMI .)
    CHAR_L          reduce using rule 87 (statement -> func_call SEMI .)
    STRING_L        reduce using rule 87 (statement -> func_call SEMI .)
    NONDECIMAL_L    reduce using rule 87 (statement -> func_call SEMI .)
    $end            reduce using rule 87 (statement -> func_call SEMI .)
    RBRACE          reduce using rule 87 (statement -> func_call SEMI .)


state 87

    (63) control_expr -> control LPAREN . conditional_expr RPAREN LBRACE node_list RBRACE
    (57) conditional_expr -> . name conditional expression
    (58) conditional_expr -> . expression conditional name
    (59) conditional_expr -> . expression conditional expression
    (60) conditional_expr -> . name conditional name
    (61) conditional_expr -> . name
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    ID              shift and go to state 127
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    conditional_expr               shift and go to state 128
    name                           shift and go to state 129
    expression                     shift and go to state 130
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 88

    (64) control_expr -> control LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 131

state 89

    (65) control_expr -> for_loop LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 132

state 90

    (82) struct_def -> STRUCT ID . LBRACE node_list RBRACE SEMI
    (18) struct_type -> STRUCT ID .

    LBRACE          shift and go to state 133
    ID              reduce using rule 18 (struct_type -> STRUCT ID .)
    ASTERISK        reduce using rule 18 (struct_type -> STRUCT ID .)


state 91

    (118) init_var -> init_var_ls init_var_rs .

    INCLUDE         reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    DEFINE          reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    IFNDEF          reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    ENDIF           reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    STRUCT          reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    CHAR            reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    DOUBLE          reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    FLOAT           reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    INT             reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    VOID            reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    UINT8_T         reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    UINT16_T        reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    ID              reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    LPAREN          reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    NEGATE          reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    MINUS           reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    WHILE           reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    IF              reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    ELSE            reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    FOR             reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    CONST           reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    EXTERN          reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    INLINE          reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    LONG            reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    SHORT           reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    SIGNED          reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    UNSIGNED        reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    VOLATILE        reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    FLOAT_L         reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    INT_L           reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    CHAR_L          reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    STRING_L        reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    NONDECIMAL_L    reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    $end            reduce using rule 118 (init_var -> init_var_ls init_var_rs .)
    RBRACE          reduce using rule 118 (init_var -> init_var_ls init_var_rs .)


state 92

    (115) init_var_rs -> name . SEMI
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name

    SEMI            shift and go to state 134
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110


state 93

    (116) init_var_rs -> type_cast . name SEMI
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    ID              shift and go to state 136
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    name                           shift and go to state 135
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 94

    (117) init_var_rs -> func_call . SEMI

    SEMI            shift and go to state 137


state 95

    (39) name -> ID .
    (77) func_call -> ID . LPAREN func_arglist RPAREN

    SEMI            reduce using rule 39 (name -> ID .)
    LBRACK          reduce using rule 39 (name -> ID .)
    MEMBER          reduce using rule 39 (name -> ID .)
    LPAREN          shift and go to state 62


state 96

    (19) type_cast -> LPAREN . dtype RPAREN
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (18) struct_type -> . STRUCT ID

    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    STRUCT          shift and go to state 106
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    ID              shift and go to state 105

    dtype                          shift and go to state 138
    struct_type                    shift and go to state 33

state 97

    (124) assign_var -> assign_var_ls assign_var_rs .

    INCLUDE         reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    DEFINE          reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    IFNDEF          reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    ENDIF           reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    STRUCT          reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    CHAR            reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    DOUBLE          reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    FLOAT           reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    INT             reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    VOID            reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    UINT8_T         reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    UINT16_T        reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    ID              reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    LPAREN          reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    NEGATE          reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    MINUS           reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    WHILE           reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    IF              reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    ELSE            reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    FOR             reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    CONST           reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    EXTERN          reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    INLINE          reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    LONG            reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    SHORT           reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    SIGNED          reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    UNSIGNED        reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    VOLATILE        reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    FLOAT_L         reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    INT_L           reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    CHAR_L          reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    STRING_L        reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    NONDECIMAL_L    reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    $end            reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)
    RBRACE          reduce using rule 124 (assign_var -> assign_var_ls assign_var_rs .)


state 98

    (120) assign_var_rs -> expression . SEMI
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    SEMI            shift and go to state 139
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    binop                          shift and go to state 67
    conditional                    shift and go to state 77

state 99

    (121) assign_var_rs -> name . SEMI
    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    SEMI            shift and go to state 140
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    binop                          shift and go to state 107
    conditional                    shift and go to state 77

state 100

    (122) assign_var_rs -> func_call . SEMI

    SEMI            shift and go to state 141


state 101

    (123) assign_var_rs -> type_cast . assign_var_rs SEMI
    (120) assign_var_rs -> . expression SEMI
    (121) assign_var_rs -> . name SEMI
    (122) assign_var_rs -> . func_call SEMI
    (123) assign_var_rs -> . type_cast assign_var_rs SEMI
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (19) type_cast -> . LPAREN dtype RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    LPAREN          shift and go to state 102
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    ID              shift and go to state 103
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    type_cast                      shift and go to state 101
    assign_var_rs                  shift and go to state 142
    expression                     shift and go to state 98
    name                           shift and go to state 99
    func_call                      shift and go to state 100
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 102

    (88) expression -> LPAREN . expression RPAREN
    (89) expression -> LPAREN . name RPAREN
    (19) type_cast -> LPAREN . dtype RPAREN
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name
    (18) struct_type -> . STRUCT ID

    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    ID              shift and go to state 143
    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    STRUCT          shift and go to state 106
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    expression                     shift and go to state 63
    name                           shift and go to state 64
    dtype                          shift and go to state 138
    literal                        shift and go to state 52
    access                         shift and go to state 53
    struct_type                    shift and go to state 33

state 103

    (108) expression -> ID . INCREMENT
    (39) name -> ID .
    (77) func_call -> ID . LPAREN func_arglist RPAREN

    INCREMENT       shift and go to state 61
    SEMI            reduce using rule 39 (name -> ID .)
    LBRACK          reduce using rule 39 (name -> ID .)
    MEMBER          reduce using rule 39 (name -> ID .)
    PLUS            reduce using rule 39 (name -> ID .)
    MINUS           reduce using rule 39 (name -> ID .)
    ASTERISK        reduce using rule 39 (name -> ID .)
    DIVIDE          reduce using rule 39 (name -> ID .)
    LSHIFT          reduce using rule 39 (name -> ID .)
    RSHIFT          reduce using rule 39 (name -> ID .)
    PERCENT         reduce using rule 39 (name -> ID .)
    BITAND          reduce using rule 39 (name -> ID .)
    BITOR           reduce using rule 39 (name -> ID .)
    EQ              reduce using rule 39 (name -> ID .)
    NEQ             reduce using rule 39 (name -> ID .)
    LT              reduce using rule 39 (name -> ID .)
    GT              reduce using rule 39 (name -> ID .)
    LE              reduce using rule 39 (name -> ID .)
    GE              reduce using rule 39 (name -> ID .)
    AND             reduce using rule 39 (name -> ID .)
    OR              reduce using rule 39 (name -> ID .)
    LPAREN          shift and go to state 62


state 104

    (110) declare_var -> modifier dtype . ID SEMI
    (111) init_var_ls -> modifier dtype . ID assign
    (113) init_var_ls -> modifier dtype . ID LBRACK RBRACK assign
    (30) dtype -> dtype . ASTERISK

    ID              shift and go to state 144
    ASTERISK        shift and go to state 60


state 105

    (29) dtype -> ID .

    ID              reduce using rule 29 (dtype -> ID .)
    ASTERISK        reduce using rule 29 (dtype -> ID .)
    RPAREN          reduce using rule 29 (dtype -> ID .)


state 106

    (24) dtype -> STRUCT .
    (18) struct_type -> STRUCT . ID

  ! shift/reduce conflict for ID resolved as shift
    ASTERISK        reduce using rule 24 (dtype -> STRUCT .)
    RPAREN          reduce using rule 24 (dtype -> STRUCT .)
    FLOAT_L         reduce using rule 24 (dtype -> STRUCT .)
    INT_L           reduce using rule 24 (dtype -> STRUCT .)
    CHAR_L          reduce using rule 24 (dtype -> STRUCT .)
    STRING_L        reduce using rule 24 (dtype -> STRUCT .)
    NONDECIMAL_L    reduce using rule 24 (dtype -> STRUCT .)
    COMMA           reduce using rule 24 (dtype -> STRUCT .)
    CHAR            reduce using rule 24 (dtype -> STRUCT .)
    DOUBLE          reduce using rule 24 (dtype -> STRUCT .)
    FLOAT           reduce using rule 24 (dtype -> STRUCT .)
    INT             reduce using rule 24 (dtype -> STRUCT .)
    STRUCT          reduce using rule 24 (dtype -> STRUCT .)
    VOID            reduce using rule 24 (dtype -> STRUCT .)
    UINT8_T         reduce using rule 24 (dtype -> STRUCT .)
    UINT16_T        reduce using rule 24 (dtype -> STRUCT .)
    LPAREN          reduce using rule 24 (dtype -> STRUCT .)
    ID              shift and go to state 145

  ! ID              [ reduce using rule 24 (dtype -> STRUCT .) ]


state 107

    (105) expression -> name binop . expression
    (106) expression -> name binop . name
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    ID              shift and go to state 65
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    name                           shift and go to state 146
    expression                     shift and go to state 147
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 108

    (119) assign_var_ls -> name assign .

    LPAREN          reduce using rule 119 (assign_var_ls -> name assign .)
    NEGATE          reduce using rule 119 (assign_var_ls -> name assign .)
    MINUS           reduce using rule 119 (assign_var_ls -> name assign .)
    ID              reduce using rule 119 (assign_var_ls -> name assign .)
    FLOAT_L         reduce using rule 119 (assign_var_ls -> name assign .)
    INT_L           reduce using rule 119 (assign_var_ls -> name assign .)
    CHAR_L          reduce using rule 119 (assign_var_ls -> name assign .)
    STRING_L        reduce using rule 119 (assign_var_ls -> name assign .)
    NONDECIMAL_L    reduce using rule 119 (assign_var_ls -> name assign .)


state 109

    (79) access -> name LBRACK . name RBRACK
    (80) access -> name LBRACK . expression RBRACK
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    ID              shift and go to state 127
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    name                           shift and go to state 148
    expression                     shift and go to state 149
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 110

    (81) access -> name MEMBER . name
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    ID              shift and go to state 136
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    name                           shift and go to state 150
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 111

    (16) assign -> SIMPLE_ASSIGN .

    LPAREN          reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    NEGATE          reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    MINUS           reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    ID              reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    FLOAT_L         reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    INT_L           reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    CHAR_L          reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    STRING_L        reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    NONDECIMAL_L    reduce using rule 16 (assign -> SIMPLE_ASSIGN .)


state 112

    (17) assign -> COMPLEX_ASSIGN .

    LPAREN          reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    NEGATE          reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    MINUS           reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    ID              reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    FLOAT_L         reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    INT_L           reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    CHAR_L          reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    STRING_L        reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    NONDECIMAL_L    reduce using rule 17 (assign -> COMPLEX_ASSIGN .)


state 113

    (90) expression -> NEGATE expression .
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
  ! shift/reduce conflict for BITAND resolved as shift
  ! shift/reduce conflict for BITOR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 90 (expression -> NEGATE expression .)
    RPAREN          reduce using rule 90 (expression -> NEGATE expression .)
    RBRACK          reduce using rule 90 (expression -> NEGATE expression .)
    COMMA           reduce using rule 90 (expression -> NEGATE expression .)
    ID              reduce using rule 90 (expression -> NEGATE expression .)
    CHAR            reduce using rule 90 (expression -> NEGATE expression .)
    DOUBLE          reduce using rule 90 (expression -> NEGATE expression .)
    FLOAT           reduce using rule 90 (expression -> NEGATE expression .)
    INT             reduce using rule 90 (expression -> NEGATE expression .)
    STRUCT          reduce using rule 90 (expression -> NEGATE expression .)
    VOID            reduce using rule 90 (expression -> NEGATE expression .)
    UINT8_T         reduce using rule 90 (expression -> NEGATE expression .)
    UINT16_T        reduce using rule 90 (expression -> NEGATE expression .)
    LPAREN          reduce using rule 90 (expression -> NEGATE expression .)
    FLOAT_L         reduce using rule 90 (expression -> NEGATE expression .)
    INT_L           reduce using rule 90 (expression -> NEGATE expression .)
    CHAR_L          reduce using rule 90 (expression -> NEGATE expression .)
    STRING_L        reduce using rule 90 (expression -> NEGATE expression .)
    NONDECIMAL_L    reduce using rule 90 (expression -> NEGATE expression .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

  ! PLUS            [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! MINUS           [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! ASTERISK        [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! DIVIDE          [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! LSHIFT          [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! RSHIFT          [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! PERCENT         [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! BITAND          [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! BITOR           [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! EQ              [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! NEQ             [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! LT              [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! GT              [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! LE              [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! GE              [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! AND             [ reduce using rule 90 (expression -> NEGATE expression .) ]
  ! OR              [ reduce using rule 90 (expression -> NEGATE expression .) ]

    binop                          shift and go to state 67
    conditional                    shift and go to state 77

state 114

    (92) expression -> NEGATE name .
    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
  ! shift/reduce conflict for BITAND resolved as shift
  ! shift/reduce conflict for BITOR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 92 (expression -> NEGATE name .)
    RPAREN          reduce using rule 92 (expression -> NEGATE name .)
    RBRACK          reduce using rule 92 (expression -> NEGATE name .)
    COMMA           reduce using rule 92 (expression -> NEGATE name .)
    ID              reduce using rule 92 (expression -> NEGATE name .)
    CHAR            reduce using rule 92 (expression -> NEGATE name .)
    DOUBLE          reduce using rule 92 (expression -> NEGATE name .)
    FLOAT           reduce using rule 92 (expression -> NEGATE name .)
    INT             reduce using rule 92 (expression -> NEGATE name .)
    STRUCT          reduce using rule 92 (expression -> NEGATE name .)
    VOID            reduce using rule 92 (expression -> NEGATE name .)
    UINT8_T         reduce using rule 92 (expression -> NEGATE name .)
    UINT16_T        reduce using rule 92 (expression -> NEGATE name .)
    LPAREN          reduce using rule 92 (expression -> NEGATE name .)
    FLOAT_L         reduce using rule 92 (expression -> NEGATE name .)
    INT_L           reduce using rule 92 (expression -> NEGATE name .)
    CHAR_L          reduce using rule 92 (expression -> NEGATE name .)
    STRING_L        reduce using rule 92 (expression -> NEGATE name .)
    NONDECIMAL_L    reduce using rule 92 (expression -> NEGATE name .)
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

  ! PLUS            [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! MINUS           [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! ASTERISK        [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! DIVIDE          [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! LSHIFT          [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! RSHIFT          [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! PERCENT         [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! BITAND          [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! BITOR           [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! EQ              [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! NEQ             [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! LT              [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! GT              [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! LE              [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! GE              [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! AND             [ reduce using rule 92 (expression -> NEGATE name .) ]
  ! OR              [ reduce using rule 92 (expression -> NEGATE name .) ]

    binop                          shift and go to state 107
    conditional                    shift and go to state 77

state 115

    (91) expression -> MINUS expression .
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
  ! shift/reduce conflict for BITAND resolved as shift
  ! shift/reduce conflict for BITOR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 91 (expression -> MINUS expression .)
    RPAREN          reduce using rule 91 (expression -> MINUS expression .)
    RBRACK          reduce using rule 91 (expression -> MINUS expression .)
    COMMA           reduce using rule 91 (expression -> MINUS expression .)
    ID              reduce using rule 91 (expression -> MINUS expression .)
    CHAR            reduce using rule 91 (expression -> MINUS expression .)
    DOUBLE          reduce using rule 91 (expression -> MINUS expression .)
    FLOAT           reduce using rule 91 (expression -> MINUS expression .)
    INT             reduce using rule 91 (expression -> MINUS expression .)
    STRUCT          reduce using rule 91 (expression -> MINUS expression .)
    VOID            reduce using rule 91 (expression -> MINUS expression .)
    UINT8_T         reduce using rule 91 (expression -> MINUS expression .)
    UINT16_T        reduce using rule 91 (expression -> MINUS expression .)
    LPAREN          reduce using rule 91 (expression -> MINUS expression .)
    FLOAT_L         reduce using rule 91 (expression -> MINUS expression .)
    INT_L           reduce using rule 91 (expression -> MINUS expression .)
    CHAR_L          reduce using rule 91 (expression -> MINUS expression .)
    STRING_L        reduce using rule 91 (expression -> MINUS expression .)
    NONDECIMAL_L    reduce using rule 91 (expression -> MINUS expression .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

  ! PLUS            [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! MINUS           [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! ASTERISK        [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! LSHIFT          [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! RSHIFT          [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! PERCENT         [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! BITAND          [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! BITOR           [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! EQ              [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! NEQ             [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! LT              [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! GT              [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! LE              [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! GE              [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! AND             [ reduce using rule 91 (expression -> MINUS expression .) ]
  ! OR              [ reduce using rule 91 (expression -> MINUS expression .) ]

    binop                          shift and go to state 67
    conditional                    shift and go to state 77

state 116

    (93) expression -> MINUS name .
    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
  ! shift/reduce conflict for BITAND resolved as shift
  ! shift/reduce conflict for BITOR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 93 (expression -> MINUS name .)
    RPAREN          reduce using rule 93 (expression -> MINUS name .)
    RBRACK          reduce using rule 93 (expression -> MINUS name .)
    COMMA           reduce using rule 93 (expression -> MINUS name .)
    ID              reduce using rule 93 (expression -> MINUS name .)
    CHAR            reduce using rule 93 (expression -> MINUS name .)
    DOUBLE          reduce using rule 93 (expression -> MINUS name .)
    FLOAT           reduce using rule 93 (expression -> MINUS name .)
    INT             reduce using rule 93 (expression -> MINUS name .)
    STRUCT          reduce using rule 93 (expression -> MINUS name .)
    VOID            reduce using rule 93 (expression -> MINUS name .)
    UINT8_T         reduce using rule 93 (expression -> MINUS name .)
    UINT16_T        reduce using rule 93 (expression -> MINUS name .)
    LPAREN          reduce using rule 93 (expression -> MINUS name .)
    FLOAT_L         reduce using rule 93 (expression -> MINUS name .)
    INT_L           reduce using rule 93 (expression -> MINUS name .)
    CHAR_L          reduce using rule 93 (expression -> MINUS name .)
    STRING_L        reduce using rule 93 (expression -> MINUS name .)
    NONDECIMAL_L    reduce using rule 93 (expression -> MINUS name .)
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

  ! PLUS            [ reduce using rule 93 (expression -> MINUS name .) ]
  ! MINUS           [ reduce using rule 93 (expression -> MINUS name .) ]
  ! ASTERISK        [ reduce using rule 93 (expression -> MINUS name .) ]
  ! DIVIDE          [ reduce using rule 93 (expression -> MINUS name .) ]
  ! LSHIFT          [ reduce using rule 93 (expression -> MINUS name .) ]
  ! RSHIFT          [ reduce using rule 93 (expression -> MINUS name .) ]
  ! PERCENT         [ reduce using rule 93 (expression -> MINUS name .) ]
  ! BITAND          [ reduce using rule 93 (expression -> MINUS name .) ]
  ! BITOR           [ reduce using rule 93 (expression -> MINUS name .) ]
  ! EQ              [ reduce using rule 93 (expression -> MINUS name .) ]
  ! NEQ             [ reduce using rule 93 (expression -> MINUS name .) ]
  ! LT              [ reduce using rule 93 (expression -> MINUS name .) ]
  ! GT              [ reduce using rule 93 (expression -> MINUS name .) ]
  ! LE              [ reduce using rule 93 (expression -> MINUS name .) ]
  ! GE              [ reduce using rule 93 (expression -> MINUS name .) ]
  ! AND             [ reduce using rule 93 (expression -> MINUS name .) ]
  ! OR              [ reduce using rule 93 (expression -> MINUS name .) ]

    binop                          shift and go to state 107
    conditional                    shift and go to state 77

state 117

    (62) for_loop -> FOR LPAREN . init_var conditional_expr SEMI ID INCREMENT RPAREN
    (118) init_var -> . init_var_ls init_var_rs
    (111) init_var_ls -> . modifier dtype ID assign
    (112) init_var_ls -> . dtype ID assign
    (113) init_var_ls -> . modifier dtype ID LBRACK RBRACK assign
    (114) init_var_ls -> . dtype ID LBRACK RBRACK assign
    (31) modifier -> . CONST
    (32) modifier -> . EXTERN
    (33) modifier -> . INLINE
    (34) modifier -> . LONG
    (35) modifier -> . SHORT
    (36) modifier -> . SIGNED
    (37) modifier -> . UNSIGNED
    (38) modifier -> . VOLATILE
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (18) struct_type -> . STRUCT ID

    CONST           shift and go to state 44
    EXTERN          shift and go to state 45
    INLINE          shift and go to state 46
    LONG            shift and go to state 47
    SHORT           shift and go to state 48
    SIGNED          shift and go to state 49
    UNSIGNED        shift and go to state 50
    VOLATILE        shift and go to state 51
    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    STRUCT          shift and go to state 106
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    ID              shift and go to state 105

    init_var                       shift and go to state 151
    init_var_ls                    shift and go to state 34
    modifier                       shift and go to state 152
    dtype                          shift and go to state 153
    struct_type                    shift and go to state 33

state 118

    (76) func_def -> dtype ID LPAREN . func_arglist RPAREN LBRACE node_list RBRACE
    (78) func_decl -> dtype ID LPAREN . func_arglist RPAREN SEMI
    (73) func_arglist -> .
    (74) func_arglist -> . func_arglist func_arg
    (75) func_arglist -> . func_arglist func_arg COMMA

    RPAREN          reduce using rule 73 (func_arglist -> .)
    ID              reduce using rule 73 (func_arglist -> .)
    CHAR            reduce using rule 73 (func_arglist -> .)
    DOUBLE          reduce using rule 73 (func_arglist -> .)
    FLOAT           reduce using rule 73 (func_arglist -> .)
    INT             reduce using rule 73 (func_arglist -> .)
    STRUCT          reduce using rule 73 (func_arglist -> .)
    VOID            reduce using rule 73 (func_arglist -> .)
    UINT8_T         reduce using rule 73 (func_arglist -> .)
    UINT16_T        reduce using rule 73 (func_arglist -> .)
    LPAREN          reduce using rule 73 (func_arglist -> .)
    FLOAT_L         reduce using rule 73 (func_arglist -> .)
    INT_L           reduce using rule 73 (func_arglist -> .)
    CHAR_L          reduce using rule 73 (func_arglist -> .)
    STRING_L        reduce using rule 73 (func_arglist -> .)
    NONDECIMAL_L    reduce using rule 73 (func_arglist -> .)

    func_arglist                   shift and go to state 154

state 119

    (109) declare_var -> dtype ID SEMI .

    INCLUDE         reduce using rule 109 (declare_var -> dtype ID SEMI .)
    DEFINE          reduce using rule 109 (declare_var -> dtype ID SEMI .)
    IFNDEF          reduce using rule 109 (declare_var -> dtype ID SEMI .)
    ENDIF           reduce using rule 109 (declare_var -> dtype ID SEMI .)
    STRUCT          reduce using rule 109 (declare_var -> dtype ID SEMI .)
    CHAR            reduce using rule 109 (declare_var -> dtype ID SEMI .)
    DOUBLE          reduce using rule 109 (declare_var -> dtype ID SEMI .)
    FLOAT           reduce using rule 109 (declare_var -> dtype ID SEMI .)
    INT             reduce using rule 109 (declare_var -> dtype ID SEMI .)
    VOID            reduce using rule 109 (declare_var -> dtype ID SEMI .)
    UINT8_T         reduce using rule 109 (declare_var -> dtype ID SEMI .)
    UINT16_T        reduce using rule 109 (declare_var -> dtype ID SEMI .)
    ID              reduce using rule 109 (declare_var -> dtype ID SEMI .)
    LPAREN          reduce using rule 109 (declare_var -> dtype ID SEMI .)
    NEGATE          reduce using rule 109 (declare_var -> dtype ID SEMI .)
    MINUS           reduce using rule 109 (declare_var -> dtype ID SEMI .)
    WHILE           reduce using rule 109 (declare_var -> dtype ID SEMI .)
    IF              reduce using rule 109 (declare_var -> dtype ID SEMI .)
    ELSE            reduce using rule 109 (declare_var -> dtype ID SEMI .)
    FOR             reduce using rule 109 (declare_var -> dtype ID SEMI .)
    CONST           reduce using rule 109 (declare_var -> dtype ID SEMI .)
    EXTERN          reduce using rule 109 (declare_var -> dtype ID SEMI .)
    INLINE          reduce using rule 109 (declare_var -> dtype ID SEMI .)
    LONG            reduce using rule 109 (declare_var -> dtype ID SEMI .)
    SHORT           reduce using rule 109 (declare_var -> dtype ID SEMI .)
    SIGNED          reduce using rule 109 (declare_var -> dtype ID SEMI .)
    UNSIGNED        reduce using rule 109 (declare_var -> dtype ID SEMI .)
    VOLATILE        reduce using rule 109 (declare_var -> dtype ID SEMI .)
    FLOAT_L         reduce using rule 109 (declare_var -> dtype ID SEMI .)
    INT_L           reduce using rule 109 (declare_var -> dtype ID SEMI .)
    CHAR_L          reduce using rule 109 (declare_var -> dtype ID SEMI .)
    STRING_L        reduce using rule 109 (declare_var -> dtype ID SEMI .)
    NONDECIMAL_L    reduce using rule 109 (declare_var -> dtype ID SEMI .)
    $end            reduce using rule 109 (declare_var -> dtype ID SEMI .)
    RBRACE          reduce using rule 109 (declare_var -> dtype ID SEMI .)


state 120

    (112) init_var_ls -> dtype ID assign .

    ID              reduce using rule 112 (init_var_ls -> dtype ID assign .)
    LPAREN          reduce using rule 112 (init_var_ls -> dtype ID assign .)
    FLOAT_L         reduce using rule 112 (init_var_ls -> dtype ID assign .)
    INT_L           reduce using rule 112 (init_var_ls -> dtype ID assign .)
    CHAR_L          reduce using rule 112 (init_var_ls -> dtype ID assign .)
    STRING_L        reduce using rule 112 (init_var_ls -> dtype ID assign .)
    NONDECIMAL_L    reduce using rule 112 (init_var_ls -> dtype ID assign .)


state 121

    (114) init_var_ls -> dtype ID LBRACK . RBRACK assign

    RBRACK          shift and go to state 155


state 122

    (77) func_call -> ID LPAREN func_arglist . RPAREN
    (74) func_arglist -> func_arglist . func_arg
    (75) func_arglist -> func_arglist . func_arg COMMA
    (66) func_arg -> . name
    (67) func_arg -> . dtype name
    (68) func_arg -> . dtype
    (69) func_arg -> . type_cast name
    (70) func_arg -> . type_cast expression
    (71) func_arg -> . func_call
    (72) func_arg -> . type_cast func_call
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (19) type_cast -> . LPAREN dtype RPAREN
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name
    (18) struct_type -> . STRUCT ID

    RPAREN          shift and go to state 157
    ID              shift and go to state 156
    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    STRUCT          shift and go to state 106
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    LPAREN          shift and go to state 96
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    func_arg                       shift and go to state 158
    name                           shift and go to state 159
    dtype                          shift and go to state 160
    type_cast                      shift and go to state 161
    func_call                      shift and go to state 162
    literal                        shift and go to state 52
    access                         shift and go to state 53
    struct_type                    shift and go to state 33

state 123

    (88) expression -> LPAREN expression RPAREN .

    SEMI            reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    ASTERISK        reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    PERCENT         reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    BITAND          reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    BITOR           reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    RBRACK          reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    ID              reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    CHAR            reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    DOUBLE          reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    INT             reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    STRUCT          reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    VOID            reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    UINT8_T         reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    UINT16_T        reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    FLOAT_L         reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    INT_L           reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    CHAR_L          reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    STRING_L        reduce using rule 88 (expression -> LPAREN expression RPAREN .)
    NONDECIMAL_L    reduce using rule 88 (expression -> LPAREN expression RPAREN .)


state 124

    (89) expression -> LPAREN name RPAREN .

    SEMI            reduce using rule 89 (expression -> LPAREN name RPAREN .)
    PLUS            reduce using rule 89 (expression -> LPAREN name RPAREN .)
    MINUS           reduce using rule 89 (expression -> LPAREN name RPAREN .)
    ASTERISK        reduce using rule 89 (expression -> LPAREN name RPAREN .)
    DIVIDE          reduce using rule 89 (expression -> LPAREN name RPAREN .)
    LSHIFT          reduce using rule 89 (expression -> LPAREN name RPAREN .)
    RSHIFT          reduce using rule 89 (expression -> LPAREN name RPAREN .)
    PERCENT         reduce using rule 89 (expression -> LPAREN name RPAREN .)
    BITAND          reduce using rule 89 (expression -> LPAREN name RPAREN .)
    BITOR           reduce using rule 89 (expression -> LPAREN name RPAREN .)
    EQ              reduce using rule 89 (expression -> LPAREN name RPAREN .)
    NEQ             reduce using rule 89 (expression -> LPAREN name RPAREN .)
    LT              reduce using rule 89 (expression -> LPAREN name RPAREN .)
    GT              reduce using rule 89 (expression -> LPAREN name RPAREN .)
    LE              reduce using rule 89 (expression -> LPAREN name RPAREN .)
    GE              reduce using rule 89 (expression -> LPAREN name RPAREN .)
    AND             reduce using rule 89 (expression -> LPAREN name RPAREN .)
    OR              reduce using rule 89 (expression -> LPAREN name RPAREN .)
    RPAREN          reduce using rule 89 (expression -> LPAREN name RPAREN .)
    RBRACK          reduce using rule 89 (expression -> LPAREN name RPAREN .)
    COMMA           reduce using rule 89 (expression -> LPAREN name RPAREN .)
    ID              reduce using rule 89 (expression -> LPAREN name RPAREN .)
    CHAR            reduce using rule 89 (expression -> LPAREN name RPAREN .)
    DOUBLE          reduce using rule 89 (expression -> LPAREN name RPAREN .)
    FLOAT           reduce using rule 89 (expression -> LPAREN name RPAREN .)
    INT             reduce using rule 89 (expression -> LPAREN name RPAREN .)
    STRUCT          reduce using rule 89 (expression -> LPAREN name RPAREN .)
    VOID            reduce using rule 89 (expression -> LPAREN name RPAREN .)
    UINT8_T         reduce using rule 89 (expression -> LPAREN name RPAREN .)
    UINT16_T        reduce using rule 89 (expression -> LPAREN name RPAREN .)
    LPAREN          reduce using rule 89 (expression -> LPAREN name RPAREN .)
    FLOAT_L         reduce using rule 89 (expression -> LPAREN name RPAREN .)
    INT_L           reduce using rule 89 (expression -> LPAREN name RPAREN .)
    CHAR_L          reduce using rule 89 (expression -> LPAREN name RPAREN .)
    STRING_L        reduce using rule 89 (expression -> LPAREN name RPAREN .)
    NONDECIMAL_L    reduce using rule 89 (expression -> LPAREN name RPAREN .)


state 125

    (107) expression -> expression binop expression .
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
  ! shift/reduce conflict for BITAND resolved as shift
  ! shift/reduce conflict for BITOR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 107 (expression -> expression binop expression .)
    RPAREN          reduce using rule 107 (expression -> expression binop expression .)
    RBRACK          reduce using rule 107 (expression -> expression binop expression .)
    COMMA           reduce using rule 107 (expression -> expression binop expression .)
    ID              reduce using rule 107 (expression -> expression binop expression .)
    CHAR            reduce using rule 107 (expression -> expression binop expression .)
    DOUBLE          reduce using rule 107 (expression -> expression binop expression .)
    FLOAT           reduce using rule 107 (expression -> expression binop expression .)
    INT             reduce using rule 107 (expression -> expression binop expression .)
    STRUCT          reduce using rule 107 (expression -> expression binop expression .)
    VOID            reduce using rule 107 (expression -> expression binop expression .)
    UINT8_T         reduce using rule 107 (expression -> expression binop expression .)
    UINT16_T        reduce using rule 107 (expression -> expression binop expression .)
    LPAREN          reduce using rule 107 (expression -> expression binop expression .)
    FLOAT_L         reduce using rule 107 (expression -> expression binop expression .)
    INT_L           reduce using rule 107 (expression -> expression binop expression .)
    CHAR_L          reduce using rule 107 (expression -> expression binop expression .)
    STRING_L        reduce using rule 107 (expression -> expression binop expression .)
    NONDECIMAL_L    reduce using rule 107 (expression -> expression binop expression .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

  ! PLUS            [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! MINUS           [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! ASTERISK        [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! DIVIDE          [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! LSHIFT          [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! RSHIFT          [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! PERCENT         [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! BITAND          [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! BITOR           [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! EQ              [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! NEQ             [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! LT              [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! GT              [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! LE              [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! GE              [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! AND             [ reduce using rule 107 (expression -> expression binop expression .) ]
  ! OR              [ reduce using rule 107 (expression -> expression binop expression .) ]

    binop                          shift and go to state 67
    conditional                    shift and go to state 77

state 126

    (104) expression -> expression binop name .
    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
  ! shift/reduce conflict for BITAND resolved as shift
  ! shift/reduce conflict for BITOR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 104 (expression -> expression binop name .)
    RPAREN          reduce using rule 104 (expression -> expression binop name .)
    RBRACK          reduce using rule 104 (expression -> expression binop name .)
    COMMA           reduce using rule 104 (expression -> expression binop name .)
    ID              reduce using rule 104 (expression -> expression binop name .)
    CHAR            reduce using rule 104 (expression -> expression binop name .)
    DOUBLE          reduce using rule 104 (expression -> expression binop name .)
    FLOAT           reduce using rule 104 (expression -> expression binop name .)
    INT             reduce using rule 104 (expression -> expression binop name .)
    STRUCT          reduce using rule 104 (expression -> expression binop name .)
    VOID            reduce using rule 104 (expression -> expression binop name .)
    UINT8_T         reduce using rule 104 (expression -> expression binop name .)
    UINT16_T        reduce using rule 104 (expression -> expression binop name .)
    LPAREN          reduce using rule 104 (expression -> expression binop name .)
    FLOAT_L         reduce using rule 104 (expression -> expression binop name .)
    INT_L           reduce using rule 104 (expression -> expression binop name .)
    CHAR_L          reduce using rule 104 (expression -> expression binop name .)
    STRING_L        reduce using rule 104 (expression -> expression binop name .)
    NONDECIMAL_L    reduce using rule 104 (expression -> expression binop name .)
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

  ! PLUS            [ reduce using rule 104 (expression -> expression binop name .) ]
  ! MINUS           [ reduce using rule 104 (expression -> expression binop name .) ]
  ! ASTERISK        [ reduce using rule 104 (expression -> expression binop name .) ]
  ! DIVIDE          [ reduce using rule 104 (expression -> expression binop name .) ]
  ! LSHIFT          [ reduce using rule 104 (expression -> expression binop name .) ]
  ! RSHIFT          [ reduce using rule 104 (expression -> expression binop name .) ]
  ! PERCENT         [ reduce using rule 104 (expression -> expression binop name .) ]
  ! BITAND          [ reduce using rule 104 (expression -> expression binop name .) ]
  ! BITOR           [ reduce using rule 104 (expression -> expression binop name .) ]
  ! EQ              [ reduce using rule 104 (expression -> expression binop name .) ]
  ! NEQ             [ reduce using rule 104 (expression -> expression binop name .) ]
  ! LT              [ reduce using rule 104 (expression -> expression binop name .) ]
  ! GT              [ reduce using rule 104 (expression -> expression binop name .) ]
  ! LE              [ reduce using rule 104 (expression -> expression binop name .) ]
  ! GE              [ reduce using rule 104 (expression -> expression binop name .) ]
  ! AND             [ reduce using rule 104 (expression -> expression binop name .) ]
  ! OR              [ reduce using rule 104 (expression -> expression binop name .) ]

    binop                          shift and go to state 107
    conditional                    shift and go to state 77

state 127

    (39) name -> ID .
    (108) expression -> ID . INCREMENT

    LBRACK          reduce using rule 39 (name -> ID .)
    MEMBER          reduce using rule 39 (name -> ID .)
    PLUS            reduce using rule 39 (name -> ID .)
    MINUS           reduce using rule 39 (name -> ID .)
    ASTERISK        reduce using rule 39 (name -> ID .)
    DIVIDE          reduce using rule 39 (name -> ID .)
    LSHIFT          reduce using rule 39 (name -> ID .)
    RSHIFT          reduce using rule 39 (name -> ID .)
    PERCENT         reduce using rule 39 (name -> ID .)
    BITAND          reduce using rule 39 (name -> ID .)
    BITOR           reduce using rule 39 (name -> ID .)
    EQ              reduce using rule 39 (name -> ID .)
    NEQ             reduce using rule 39 (name -> ID .)
    LT              reduce using rule 39 (name -> ID .)
    GT              reduce using rule 39 (name -> ID .)
    LE              reduce using rule 39 (name -> ID .)
    GE              reduce using rule 39 (name -> ID .)
    AND             reduce using rule 39 (name -> ID .)
    OR              reduce using rule 39 (name -> ID .)
    SEMI            reduce using rule 39 (name -> ID .)
    RPAREN          reduce using rule 39 (name -> ID .)
    RBRACK          reduce using rule 39 (name -> ID .)
    COMMA           reduce using rule 39 (name -> ID .)
    ID              reduce using rule 39 (name -> ID .)
    CHAR            reduce using rule 39 (name -> ID .)
    DOUBLE          reduce using rule 39 (name -> ID .)
    FLOAT           reduce using rule 39 (name -> ID .)
    INT             reduce using rule 39 (name -> ID .)
    STRUCT          reduce using rule 39 (name -> ID .)
    VOID            reduce using rule 39 (name -> ID .)
    UINT8_T         reduce using rule 39 (name -> ID .)
    UINT16_T        reduce using rule 39 (name -> ID .)
    LPAREN          reduce using rule 39 (name -> ID .)
    FLOAT_L         reduce using rule 39 (name -> ID .)
    INT_L           reduce using rule 39 (name -> ID .)
    CHAR_L          reduce using rule 39 (name -> ID .)
    STRING_L        reduce using rule 39 (name -> ID .)
    NONDECIMAL_L    reduce using rule 39 (name -> ID .)
    INCREMENT       shift and go to state 61


state 128

    (63) control_expr -> control LPAREN conditional_expr . RPAREN LBRACE node_list RBRACE

    RPAREN          shift and go to state 163


state 129

    (57) conditional_expr -> name . conditional expression
    (60) conditional_expr -> name . conditional name
    (61) conditional_expr -> name .
    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional

    RPAREN          reduce using rule 61 (conditional_expr -> name .)
    SEMI            reduce using rule 61 (conditional_expr -> name .)
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76

    conditional                    shift and go to state 164
    binop                          shift and go to state 107

state 130

    (58) conditional_expr -> expression . conditional name
    (59) conditional_expr -> expression . conditional expression
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional

    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76

    conditional                    shift and go to state 165
    binop                          shift and go to state 67

state 131

    (64) control_expr -> control LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (42) include -> . INCLUDE
    (43) define -> . DEFINE
    (44) if -> . IFNDEF
    (45) if -> . ENDIF
    (76) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (78) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (83) statement -> . init_var
    (84) statement -> . assign_var
    (85) statement -> . declare_var
    (86) statement -> . expression SEMI
    (87) statement -> . func_call SEMI
    (63) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (64) control_expr -> . control LBRACE node_list RBRACE
    (65) control_expr -> . for_loop LBRACE node_list RBRACE
    (82) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (118) init_var -> . init_var_ls init_var_rs
    (124) assign_var -> . assign_var_ls assign_var_rs
    (109) declare_var -> . dtype ID SEMI
    (110) declare_var -> . modifier dtype ID SEMI
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (46) control -> . WHILE
    (47) control -> . IF
    (48) control -> . ELSE
    (62) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT ID
    (111) init_var_ls -> . modifier dtype ID assign
    (112) init_var_ls -> . dtype ID assign
    (113) init_var_ls -> . modifier dtype ID LBRACK RBRACK assign
    (114) init_var_ls -> . dtype ID LBRACK RBRACK assign
    (119) assign_var_ls -> . name assign
    (31) modifier -> . CONST
    (32) modifier -> . EXTERN
    (33) modifier -> . INLINE
    (34) modifier -> . LONG
    (35) modifier -> . SHORT
    (36) modifier -> . SIGNED
    (37) modifier -> . UNSIGNED
    (38) modifier -> . VOLATILE
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    RBRACE          shift and go to state 166
    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    STRUCT          shift and go to state 25
    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    ID              shift and go to state 16
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    WHILE           shift and go to state 40
    IF              shift and go to state 41
    ELSE            shift and go to state 42
    FOR             shift and go to state 43
    CONST           shift and go to state 44
    EXTERN          shift and go to state 45
    INLINE          shift and go to state 46
    LONG            shift and go to state 47
    SHORT           shift and go to state 48
    SIGNED          shift and go to state 49
    UNSIGNED        shift and go to state 50
    VOLATILE        shift and go to state 51
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    control                        shift and go to state 23
    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    dtype                          shift and go to state 15
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    for_loop                       shift and go to state 24
    struct_type                    shift and go to state 33
    init_var_ls                    shift and go to state 34
    assign_var_ls                  shift and go to state 35
    modifier                       shift and go to state 36
    name                           shift and go to state 37
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 132

    (65) control_expr -> for_loop LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (42) include -> . INCLUDE
    (43) define -> . DEFINE
    (44) if -> . IFNDEF
    (45) if -> . ENDIF
    (76) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (78) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (83) statement -> . init_var
    (84) statement -> . assign_var
    (85) statement -> . declare_var
    (86) statement -> . expression SEMI
    (87) statement -> . func_call SEMI
    (63) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (64) control_expr -> . control LBRACE node_list RBRACE
    (65) control_expr -> . for_loop LBRACE node_list RBRACE
    (82) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (118) init_var -> . init_var_ls init_var_rs
    (124) assign_var -> . assign_var_ls assign_var_rs
    (109) declare_var -> . dtype ID SEMI
    (110) declare_var -> . modifier dtype ID SEMI
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (46) control -> . WHILE
    (47) control -> . IF
    (48) control -> . ELSE
    (62) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT ID
    (111) init_var_ls -> . modifier dtype ID assign
    (112) init_var_ls -> . dtype ID assign
    (113) init_var_ls -> . modifier dtype ID LBRACK RBRACK assign
    (114) init_var_ls -> . dtype ID LBRACK RBRACK assign
    (119) assign_var_ls -> . name assign
    (31) modifier -> . CONST
    (32) modifier -> . EXTERN
    (33) modifier -> . INLINE
    (34) modifier -> . LONG
    (35) modifier -> . SHORT
    (36) modifier -> . SIGNED
    (37) modifier -> . UNSIGNED
    (38) modifier -> . VOLATILE
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    RBRACE          shift and go to state 167
    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    STRUCT          shift and go to state 25
    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    ID              shift and go to state 16
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    WHILE           shift and go to state 40
    IF              shift and go to state 41
    ELSE            shift and go to state 42
    FOR             shift and go to state 43
    CONST           shift and go to state 44
    EXTERN          shift and go to state 45
    INLINE          shift and go to state 46
    LONG            shift and go to state 47
    SHORT           shift and go to state 48
    SIGNED          shift and go to state 49
    UNSIGNED        shift and go to state 50
    VOLATILE        shift and go to state 51
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    for_loop                       shift and go to state 24
    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    dtype                          shift and go to state 15
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    control                        shift and go to state 23
    struct_type                    shift and go to state 33
    init_var_ls                    shift and go to state 34
    assign_var_ls                  shift and go to state 35
    modifier                       shift and go to state 36
    name                           shift and go to state 37
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 133

    (82) struct_def -> STRUCT ID LBRACE . node_list RBRACE SEMI
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 168

state 134

    (115) init_var_rs -> name SEMI .

    INCLUDE         reduce using rule 115 (init_var_rs -> name SEMI .)
    DEFINE          reduce using rule 115 (init_var_rs -> name SEMI .)
    IFNDEF          reduce using rule 115 (init_var_rs -> name SEMI .)
    ENDIF           reduce using rule 115 (init_var_rs -> name SEMI .)
    STRUCT          reduce using rule 115 (init_var_rs -> name SEMI .)
    CHAR            reduce using rule 115 (init_var_rs -> name SEMI .)
    DOUBLE          reduce using rule 115 (init_var_rs -> name SEMI .)
    FLOAT           reduce using rule 115 (init_var_rs -> name SEMI .)
    INT             reduce using rule 115 (init_var_rs -> name SEMI .)
    VOID            reduce using rule 115 (init_var_rs -> name SEMI .)
    UINT8_T         reduce using rule 115 (init_var_rs -> name SEMI .)
    UINT16_T        reduce using rule 115 (init_var_rs -> name SEMI .)
    ID              reduce using rule 115 (init_var_rs -> name SEMI .)
    LPAREN          reduce using rule 115 (init_var_rs -> name SEMI .)
    NEGATE          reduce using rule 115 (init_var_rs -> name SEMI .)
    MINUS           reduce using rule 115 (init_var_rs -> name SEMI .)
    WHILE           reduce using rule 115 (init_var_rs -> name SEMI .)
    IF              reduce using rule 115 (init_var_rs -> name SEMI .)
    ELSE            reduce using rule 115 (init_var_rs -> name SEMI .)
    FOR             reduce using rule 115 (init_var_rs -> name SEMI .)
    CONST           reduce using rule 115 (init_var_rs -> name SEMI .)
    EXTERN          reduce using rule 115 (init_var_rs -> name SEMI .)
    INLINE          reduce using rule 115 (init_var_rs -> name SEMI .)
    LONG            reduce using rule 115 (init_var_rs -> name SEMI .)
    SHORT           reduce using rule 115 (init_var_rs -> name SEMI .)
    SIGNED          reduce using rule 115 (init_var_rs -> name SEMI .)
    UNSIGNED        reduce using rule 115 (init_var_rs -> name SEMI .)
    VOLATILE        reduce using rule 115 (init_var_rs -> name SEMI .)
    FLOAT_L         reduce using rule 115 (init_var_rs -> name SEMI .)
    INT_L           reduce using rule 115 (init_var_rs -> name SEMI .)
    CHAR_L          reduce using rule 115 (init_var_rs -> name SEMI .)
    STRING_L        reduce using rule 115 (init_var_rs -> name SEMI .)
    NONDECIMAL_L    reduce using rule 115 (init_var_rs -> name SEMI .)
    $end            reduce using rule 115 (init_var_rs -> name SEMI .)
    RBRACE          reduce using rule 115 (init_var_rs -> name SEMI .)


state 135

    (116) init_var_rs -> type_cast name . SEMI
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name

    SEMI            shift and go to state 169
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110


state 136

    (39) name -> ID .

    SEMI            reduce using rule 39 (name -> ID .)
    LBRACK          reduce using rule 39 (name -> ID .)
    MEMBER          reduce using rule 39 (name -> ID .)
    PLUS            reduce using rule 39 (name -> ID .)
    MINUS           reduce using rule 39 (name -> ID .)
    ASTERISK        reduce using rule 39 (name -> ID .)
    DIVIDE          reduce using rule 39 (name -> ID .)
    LSHIFT          reduce using rule 39 (name -> ID .)
    RSHIFT          reduce using rule 39 (name -> ID .)
    PERCENT         reduce using rule 39 (name -> ID .)
    BITAND          reduce using rule 39 (name -> ID .)
    BITOR           reduce using rule 39 (name -> ID .)
    SIMPLE_ASSIGN   reduce using rule 39 (name -> ID .)
    COMPLEX_ASSIGN  reduce using rule 39 (name -> ID .)
    EQ              reduce using rule 39 (name -> ID .)
    NEQ             reduce using rule 39 (name -> ID .)
    LT              reduce using rule 39 (name -> ID .)
    GT              reduce using rule 39 (name -> ID .)
    LE              reduce using rule 39 (name -> ID .)
    GE              reduce using rule 39 (name -> ID .)
    AND             reduce using rule 39 (name -> ID .)
    OR              reduce using rule 39 (name -> ID .)
    RPAREN          reduce using rule 39 (name -> ID .)
    RBRACK          reduce using rule 39 (name -> ID .)
    COMMA           reduce using rule 39 (name -> ID .)
    ID              reduce using rule 39 (name -> ID .)
    CHAR            reduce using rule 39 (name -> ID .)
    DOUBLE          reduce using rule 39 (name -> ID .)
    FLOAT           reduce using rule 39 (name -> ID .)
    INT             reduce using rule 39 (name -> ID .)
    STRUCT          reduce using rule 39 (name -> ID .)
    VOID            reduce using rule 39 (name -> ID .)
    UINT8_T         reduce using rule 39 (name -> ID .)
    UINT16_T        reduce using rule 39 (name -> ID .)
    LPAREN          reduce using rule 39 (name -> ID .)
    FLOAT_L         reduce using rule 39 (name -> ID .)
    INT_L           reduce using rule 39 (name -> ID .)
    CHAR_L          reduce using rule 39 (name -> ID .)
    STRING_L        reduce using rule 39 (name -> ID .)
    NONDECIMAL_L    reduce using rule 39 (name -> ID .)


state 137

    (117) init_var_rs -> func_call SEMI .

    INCLUDE         reduce using rule 117 (init_var_rs -> func_call SEMI .)
    DEFINE          reduce using rule 117 (init_var_rs -> func_call SEMI .)
    IFNDEF          reduce using rule 117 (init_var_rs -> func_call SEMI .)
    ENDIF           reduce using rule 117 (init_var_rs -> func_call SEMI .)
    STRUCT          reduce using rule 117 (init_var_rs -> func_call SEMI .)
    CHAR            reduce using rule 117 (init_var_rs -> func_call SEMI .)
    DOUBLE          reduce using rule 117 (init_var_rs -> func_call SEMI .)
    FLOAT           reduce using rule 117 (init_var_rs -> func_call SEMI .)
    INT             reduce using rule 117 (init_var_rs -> func_call SEMI .)
    VOID            reduce using rule 117 (init_var_rs -> func_call SEMI .)
    UINT8_T         reduce using rule 117 (init_var_rs -> func_call SEMI .)
    UINT16_T        reduce using rule 117 (init_var_rs -> func_call SEMI .)
    ID              reduce using rule 117 (init_var_rs -> func_call SEMI .)
    LPAREN          reduce using rule 117 (init_var_rs -> func_call SEMI .)
    NEGATE          reduce using rule 117 (init_var_rs -> func_call SEMI .)
    MINUS           reduce using rule 117 (init_var_rs -> func_call SEMI .)
    WHILE           reduce using rule 117 (init_var_rs -> func_call SEMI .)
    IF              reduce using rule 117 (init_var_rs -> func_call SEMI .)
    ELSE            reduce using rule 117 (init_var_rs -> func_call SEMI .)
    FOR             reduce using rule 117 (init_var_rs -> func_call SEMI .)
    CONST           reduce using rule 117 (init_var_rs -> func_call SEMI .)
    EXTERN          reduce using rule 117 (init_var_rs -> func_call SEMI .)
    INLINE          reduce using rule 117 (init_var_rs -> func_call SEMI .)
    LONG            reduce using rule 117 (init_var_rs -> func_call SEMI .)
    SHORT           reduce using rule 117 (init_var_rs -> func_call SEMI .)
    SIGNED          reduce using rule 117 (init_var_rs -> func_call SEMI .)
    UNSIGNED        reduce using rule 117 (init_var_rs -> func_call SEMI .)
    VOLATILE        reduce using rule 117 (init_var_rs -> func_call SEMI .)
    FLOAT_L         reduce using rule 117 (init_var_rs -> func_call SEMI .)
    INT_L           reduce using rule 117 (init_var_rs -> func_call SEMI .)
    CHAR_L          reduce using rule 117 (init_var_rs -> func_call SEMI .)
    STRING_L        reduce using rule 117 (init_var_rs -> func_call SEMI .)
    NONDECIMAL_L    reduce using rule 117 (init_var_rs -> func_call SEMI .)
    $end            reduce using rule 117 (init_var_rs -> func_call SEMI .)
    RBRACE          reduce using rule 117 (init_var_rs -> func_call SEMI .)


state 138

    (19) type_cast -> LPAREN dtype . RPAREN
    (30) dtype -> dtype . ASTERISK

    RPAREN          shift and go to state 170
    ASTERISK        shift and go to state 60


state 139

    (120) assign_var_rs -> expression SEMI .

    INCLUDE         reduce using rule 120 (assign_var_rs -> expression SEMI .)
    DEFINE          reduce using rule 120 (assign_var_rs -> expression SEMI .)
    IFNDEF          reduce using rule 120 (assign_var_rs -> expression SEMI .)
    ENDIF           reduce using rule 120 (assign_var_rs -> expression SEMI .)
    STRUCT          reduce using rule 120 (assign_var_rs -> expression SEMI .)
    CHAR            reduce using rule 120 (assign_var_rs -> expression SEMI .)
    DOUBLE          reduce using rule 120 (assign_var_rs -> expression SEMI .)
    FLOAT           reduce using rule 120 (assign_var_rs -> expression SEMI .)
    INT             reduce using rule 120 (assign_var_rs -> expression SEMI .)
    VOID            reduce using rule 120 (assign_var_rs -> expression SEMI .)
    UINT8_T         reduce using rule 120 (assign_var_rs -> expression SEMI .)
    UINT16_T        reduce using rule 120 (assign_var_rs -> expression SEMI .)
    ID              reduce using rule 120 (assign_var_rs -> expression SEMI .)
    LPAREN          reduce using rule 120 (assign_var_rs -> expression SEMI .)
    NEGATE          reduce using rule 120 (assign_var_rs -> expression SEMI .)
    MINUS           reduce using rule 120 (assign_var_rs -> expression SEMI .)
    WHILE           reduce using rule 120 (assign_var_rs -> expression SEMI .)
    IF              reduce using rule 120 (assign_var_rs -> expression SEMI .)
    ELSE            reduce using rule 120 (assign_var_rs -> expression SEMI .)
    FOR             reduce using rule 120 (assign_var_rs -> expression SEMI .)
    CONST           reduce using rule 120 (assign_var_rs -> expression SEMI .)
    EXTERN          reduce using rule 120 (assign_var_rs -> expression SEMI .)
    INLINE          reduce using rule 120 (assign_var_rs -> expression SEMI .)
    LONG            reduce using rule 120 (assign_var_rs -> expression SEMI .)
    SHORT           reduce using rule 120 (assign_var_rs -> expression SEMI .)
    SIGNED          reduce using rule 120 (assign_var_rs -> expression SEMI .)
    UNSIGNED        reduce using rule 120 (assign_var_rs -> expression SEMI .)
    VOLATILE        reduce using rule 120 (assign_var_rs -> expression SEMI .)
    FLOAT_L         reduce using rule 120 (assign_var_rs -> expression SEMI .)
    INT_L           reduce using rule 120 (assign_var_rs -> expression SEMI .)
    CHAR_L          reduce using rule 120 (assign_var_rs -> expression SEMI .)
    STRING_L        reduce using rule 120 (assign_var_rs -> expression SEMI .)
    NONDECIMAL_L    reduce using rule 120 (assign_var_rs -> expression SEMI .)
    $end            reduce using rule 120 (assign_var_rs -> expression SEMI .)
    RBRACE          reduce using rule 120 (assign_var_rs -> expression SEMI .)
    SEMI            reduce using rule 120 (assign_var_rs -> expression SEMI .)


state 140

    (121) assign_var_rs -> name SEMI .

    INCLUDE         reduce using rule 121 (assign_var_rs -> name SEMI .)
    DEFINE          reduce using rule 121 (assign_var_rs -> name SEMI .)
    IFNDEF          reduce using rule 121 (assign_var_rs -> name SEMI .)
    ENDIF           reduce using rule 121 (assign_var_rs -> name SEMI .)
    STRUCT          reduce using rule 121 (assign_var_rs -> name SEMI .)
    CHAR            reduce using rule 121 (assign_var_rs -> name SEMI .)
    DOUBLE          reduce using rule 121 (assign_var_rs -> name SEMI .)
    FLOAT           reduce using rule 121 (assign_var_rs -> name SEMI .)
    INT             reduce using rule 121 (assign_var_rs -> name SEMI .)
    VOID            reduce using rule 121 (assign_var_rs -> name SEMI .)
    UINT8_T         reduce using rule 121 (assign_var_rs -> name SEMI .)
    UINT16_T        reduce using rule 121 (assign_var_rs -> name SEMI .)
    ID              reduce using rule 121 (assign_var_rs -> name SEMI .)
    LPAREN          reduce using rule 121 (assign_var_rs -> name SEMI .)
    NEGATE          reduce using rule 121 (assign_var_rs -> name SEMI .)
    MINUS           reduce using rule 121 (assign_var_rs -> name SEMI .)
    WHILE           reduce using rule 121 (assign_var_rs -> name SEMI .)
    IF              reduce using rule 121 (assign_var_rs -> name SEMI .)
    ELSE            reduce using rule 121 (assign_var_rs -> name SEMI .)
    FOR             reduce using rule 121 (assign_var_rs -> name SEMI .)
    CONST           reduce using rule 121 (assign_var_rs -> name SEMI .)
    EXTERN          reduce using rule 121 (assign_var_rs -> name SEMI .)
    INLINE          reduce using rule 121 (assign_var_rs -> name SEMI .)
    LONG            reduce using rule 121 (assign_var_rs -> name SEMI .)
    SHORT           reduce using rule 121 (assign_var_rs -> name SEMI .)
    SIGNED          reduce using rule 121 (assign_var_rs -> name SEMI .)
    UNSIGNED        reduce using rule 121 (assign_var_rs -> name SEMI .)
    VOLATILE        reduce using rule 121 (assign_var_rs -> name SEMI .)
    FLOAT_L         reduce using rule 121 (assign_var_rs -> name SEMI .)
    INT_L           reduce using rule 121 (assign_var_rs -> name SEMI .)
    CHAR_L          reduce using rule 121 (assign_var_rs -> name SEMI .)
    STRING_L        reduce using rule 121 (assign_var_rs -> name SEMI .)
    NONDECIMAL_L    reduce using rule 121 (assign_var_rs -> name SEMI .)
    $end            reduce using rule 121 (assign_var_rs -> name SEMI .)
    RBRACE          reduce using rule 121 (assign_var_rs -> name SEMI .)
    SEMI            reduce using rule 121 (assign_var_rs -> name SEMI .)


state 141

    (122) assign_var_rs -> func_call SEMI .

    INCLUDE         reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    DEFINE          reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    IFNDEF          reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    ENDIF           reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    STRUCT          reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    CHAR            reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    DOUBLE          reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    FLOAT           reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    INT             reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    VOID            reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    UINT8_T         reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    UINT16_T        reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    ID              reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    LPAREN          reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    NEGATE          reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    MINUS           reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    WHILE           reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    IF              reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    ELSE            reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    FOR             reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    CONST           reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    EXTERN          reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    INLINE          reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    LONG            reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    SHORT           reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    SIGNED          reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    UNSIGNED        reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    VOLATILE        reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    FLOAT_L         reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    INT_L           reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    CHAR_L          reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    STRING_L        reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    NONDECIMAL_L    reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    $end            reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    RBRACE          reduce using rule 122 (assign_var_rs -> func_call SEMI .)
    SEMI            reduce using rule 122 (assign_var_rs -> func_call SEMI .)


state 142

    (123) assign_var_rs -> type_cast assign_var_rs . SEMI

    SEMI            shift and go to state 171


state 143

    (108) expression -> ID . INCREMENT
    (39) name -> ID .
    (29) dtype -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for ASTERISK resolved using rule 29 (dtype -> ID .)
    INCREMENT       shift and go to state 61
    LBRACK          reduce using rule 39 (name -> ID .)
    MEMBER          reduce using rule 39 (name -> ID .)
    PLUS            reduce using rule 39 (name -> ID .)
    MINUS           reduce using rule 39 (name -> ID .)
    DIVIDE          reduce using rule 39 (name -> ID .)
    LSHIFT          reduce using rule 39 (name -> ID .)
    RSHIFT          reduce using rule 39 (name -> ID .)
    PERCENT         reduce using rule 39 (name -> ID .)
    BITAND          reduce using rule 39 (name -> ID .)
    BITOR           reduce using rule 39 (name -> ID .)
    EQ              reduce using rule 39 (name -> ID .)
    NEQ             reduce using rule 39 (name -> ID .)
    LT              reduce using rule 39 (name -> ID .)
    GT              reduce using rule 39 (name -> ID .)
    LE              reduce using rule 39 (name -> ID .)
    GE              reduce using rule 39 (name -> ID .)
    AND             reduce using rule 39 (name -> ID .)
    OR              reduce using rule 39 (name -> ID .)
    RPAREN          reduce using rule 29 (dtype -> ID .)
    ASTERISK        reduce using rule 29 (dtype -> ID .)

  ! RPAREN          [ reduce using rule 39 (name -> ID .) ]
  ! ASTERISK        [ reduce using rule 39 (name -> ID .) ]


state 144

    (110) declare_var -> modifier dtype ID . SEMI
    (111) init_var_ls -> modifier dtype ID . assign
    (113) init_var_ls -> modifier dtype ID . LBRACK RBRACK assign
    (16) assign -> . SIMPLE_ASSIGN
    (17) assign -> . COMPLEX_ASSIGN

    SEMI            shift and go to state 172
    LBRACK          shift and go to state 174
    SIMPLE_ASSIGN   shift and go to state 111
    COMPLEX_ASSIGN  shift and go to state 112

    assign                         shift and go to state 173

state 145

    (18) struct_type -> STRUCT ID .

    ID              reduce using rule 18 (struct_type -> STRUCT ID .)
    ASTERISK        reduce using rule 18 (struct_type -> STRUCT ID .)
    RPAREN          reduce using rule 18 (struct_type -> STRUCT ID .)
    FLOAT_L         reduce using rule 18 (struct_type -> STRUCT ID .)
    INT_L           reduce using rule 18 (struct_type -> STRUCT ID .)
    CHAR_L          reduce using rule 18 (struct_type -> STRUCT ID .)
    STRING_L        reduce using rule 18 (struct_type -> STRUCT ID .)
    NONDECIMAL_L    reduce using rule 18 (struct_type -> STRUCT ID .)
    COMMA           reduce using rule 18 (struct_type -> STRUCT ID .)
    CHAR            reduce using rule 18 (struct_type -> STRUCT ID .)
    DOUBLE          reduce using rule 18 (struct_type -> STRUCT ID .)
    FLOAT           reduce using rule 18 (struct_type -> STRUCT ID .)
    INT             reduce using rule 18 (struct_type -> STRUCT ID .)
    STRUCT          reduce using rule 18 (struct_type -> STRUCT ID .)
    VOID            reduce using rule 18 (struct_type -> STRUCT ID .)
    UINT8_T         reduce using rule 18 (struct_type -> STRUCT ID .)
    UINT16_T        reduce using rule 18 (struct_type -> STRUCT ID .)
    LPAREN          reduce using rule 18 (struct_type -> STRUCT ID .)


state 146

    (106) expression -> name binop name .
    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
  ! shift/reduce conflict for BITAND resolved as shift
  ! shift/reduce conflict for BITOR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 106 (expression -> name binop name .)
    RPAREN          reduce using rule 106 (expression -> name binop name .)
    RBRACK          reduce using rule 106 (expression -> name binop name .)
    COMMA           reduce using rule 106 (expression -> name binop name .)
    ID              reduce using rule 106 (expression -> name binop name .)
    CHAR            reduce using rule 106 (expression -> name binop name .)
    DOUBLE          reduce using rule 106 (expression -> name binop name .)
    FLOAT           reduce using rule 106 (expression -> name binop name .)
    INT             reduce using rule 106 (expression -> name binop name .)
    STRUCT          reduce using rule 106 (expression -> name binop name .)
    VOID            reduce using rule 106 (expression -> name binop name .)
    UINT8_T         reduce using rule 106 (expression -> name binop name .)
    UINT16_T        reduce using rule 106 (expression -> name binop name .)
    LPAREN          reduce using rule 106 (expression -> name binop name .)
    FLOAT_L         reduce using rule 106 (expression -> name binop name .)
    INT_L           reduce using rule 106 (expression -> name binop name .)
    CHAR_L          reduce using rule 106 (expression -> name binop name .)
    STRING_L        reduce using rule 106 (expression -> name binop name .)
    NONDECIMAL_L    reduce using rule 106 (expression -> name binop name .)
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

  ! PLUS            [ reduce using rule 106 (expression -> name binop name .) ]
  ! MINUS           [ reduce using rule 106 (expression -> name binop name .) ]
  ! ASTERISK        [ reduce using rule 106 (expression -> name binop name .) ]
  ! DIVIDE          [ reduce using rule 106 (expression -> name binop name .) ]
  ! LSHIFT          [ reduce using rule 106 (expression -> name binop name .) ]
  ! RSHIFT          [ reduce using rule 106 (expression -> name binop name .) ]
  ! PERCENT         [ reduce using rule 106 (expression -> name binop name .) ]
  ! BITAND          [ reduce using rule 106 (expression -> name binop name .) ]
  ! BITOR           [ reduce using rule 106 (expression -> name binop name .) ]
  ! EQ              [ reduce using rule 106 (expression -> name binop name .) ]
  ! NEQ             [ reduce using rule 106 (expression -> name binop name .) ]
  ! LT              [ reduce using rule 106 (expression -> name binop name .) ]
  ! GT              [ reduce using rule 106 (expression -> name binop name .) ]
  ! LE              [ reduce using rule 106 (expression -> name binop name .) ]
  ! GE              [ reduce using rule 106 (expression -> name binop name .) ]
  ! AND             [ reduce using rule 106 (expression -> name binop name .) ]
  ! OR              [ reduce using rule 106 (expression -> name binop name .) ]

    binop                          shift and go to state 107
    conditional                    shift and go to state 77

state 147

    (105) expression -> name binop expression .
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
  ! shift/reduce conflict for BITAND resolved as shift
  ! shift/reduce conflict for BITOR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 105 (expression -> name binop expression .)
    RPAREN          reduce using rule 105 (expression -> name binop expression .)
    RBRACK          reduce using rule 105 (expression -> name binop expression .)
    COMMA           reduce using rule 105 (expression -> name binop expression .)
    ID              reduce using rule 105 (expression -> name binop expression .)
    CHAR            reduce using rule 105 (expression -> name binop expression .)
    DOUBLE          reduce using rule 105 (expression -> name binop expression .)
    FLOAT           reduce using rule 105 (expression -> name binop expression .)
    INT             reduce using rule 105 (expression -> name binop expression .)
    STRUCT          reduce using rule 105 (expression -> name binop expression .)
    VOID            reduce using rule 105 (expression -> name binop expression .)
    UINT8_T         reduce using rule 105 (expression -> name binop expression .)
    UINT16_T        reduce using rule 105 (expression -> name binop expression .)
    LPAREN          reduce using rule 105 (expression -> name binop expression .)
    FLOAT_L         reduce using rule 105 (expression -> name binop expression .)
    INT_L           reduce using rule 105 (expression -> name binop expression .)
    CHAR_L          reduce using rule 105 (expression -> name binop expression .)
    STRING_L        reduce using rule 105 (expression -> name binop expression .)
    NONDECIMAL_L    reduce using rule 105 (expression -> name binop expression .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

  ! PLUS            [ reduce using rule 105 (expression -> name binop expression .) ]
  ! MINUS           [ reduce using rule 105 (expression -> name binop expression .) ]
  ! ASTERISK        [ reduce using rule 105 (expression -> name binop expression .) ]
  ! DIVIDE          [ reduce using rule 105 (expression -> name binop expression .) ]
  ! LSHIFT          [ reduce using rule 105 (expression -> name binop expression .) ]
  ! RSHIFT          [ reduce using rule 105 (expression -> name binop expression .) ]
  ! PERCENT         [ reduce using rule 105 (expression -> name binop expression .) ]
  ! BITAND          [ reduce using rule 105 (expression -> name binop expression .) ]
  ! BITOR           [ reduce using rule 105 (expression -> name binop expression .) ]
  ! EQ              [ reduce using rule 105 (expression -> name binop expression .) ]
  ! NEQ             [ reduce using rule 105 (expression -> name binop expression .) ]
  ! LT              [ reduce using rule 105 (expression -> name binop expression .) ]
  ! GT              [ reduce using rule 105 (expression -> name binop expression .) ]
  ! LE              [ reduce using rule 105 (expression -> name binop expression .) ]
  ! GE              [ reduce using rule 105 (expression -> name binop expression .) ]
  ! AND             [ reduce using rule 105 (expression -> name binop expression .) ]
  ! OR              [ reduce using rule 105 (expression -> name binop expression .) ]

    binop                          shift and go to state 67
    conditional                    shift and go to state 77

state 148

    (79) access -> name LBRACK name . RBRACK
    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    RBRACK          shift and go to state 175
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    binop                          shift and go to state 107
    conditional                    shift and go to state 77

state 149

    (80) access -> name LBRACK expression . RBRACK
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    RBRACK          shift and go to state 176
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    binop                          shift and go to state 67
    conditional                    shift and go to state 77

state 150

    (81) access -> name MEMBER name .
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name

  ! shift/reduce conflict for LBRACK resolved as shift
  ! shift/reduce conflict for MEMBER resolved as shift
    PLUS            reduce using rule 81 (access -> name MEMBER name .)
    MINUS           reduce using rule 81 (access -> name MEMBER name .)
    ASTERISK        reduce using rule 81 (access -> name MEMBER name .)
    DIVIDE          reduce using rule 81 (access -> name MEMBER name .)
    LSHIFT          reduce using rule 81 (access -> name MEMBER name .)
    RSHIFT          reduce using rule 81 (access -> name MEMBER name .)
    PERCENT         reduce using rule 81 (access -> name MEMBER name .)
    BITAND          reduce using rule 81 (access -> name MEMBER name .)
    BITOR           reduce using rule 81 (access -> name MEMBER name .)
    SIMPLE_ASSIGN   reduce using rule 81 (access -> name MEMBER name .)
    COMPLEX_ASSIGN  reduce using rule 81 (access -> name MEMBER name .)
    EQ              reduce using rule 81 (access -> name MEMBER name .)
    NEQ             reduce using rule 81 (access -> name MEMBER name .)
    LT              reduce using rule 81 (access -> name MEMBER name .)
    GT              reduce using rule 81 (access -> name MEMBER name .)
    LE              reduce using rule 81 (access -> name MEMBER name .)
    GE              reduce using rule 81 (access -> name MEMBER name .)
    AND             reduce using rule 81 (access -> name MEMBER name .)
    OR              reduce using rule 81 (access -> name MEMBER name .)
    RPAREN          reduce using rule 81 (access -> name MEMBER name .)
    SEMI            reduce using rule 81 (access -> name MEMBER name .)
    RBRACK          reduce using rule 81 (access -> name MEMBER name .)
    COMMA           reduce using rule 81 (access -> name MEMBER name .)
    ID              reduce using rule 81 (access -> name MEMBER name .)
    CHAR            reduce using rule 81 (access -> name MEMBER name .)
    DOUBLE          reduce using rule 81 (access -> name MEMBER name .)
    FLOAT           reduce using rule 81 (access -> name MEMBER name .)
    INT             reduce using rule 81 (access -> name MEMBER name .)
    STRUCT          reduce using rule 81 (access -> name MEMBER name .)
    VOID            reduce using rule 81 (access -> name MEMBER name .)
    UINT8_T         reduce using rule 81 (access -> name MEMBER name .)
    UINT16_T        reduce using rule 81 (access -> name MEMBER name .)
    LPAREN          reduce using rule 81 (access -> name MEMBER name .)
    FLOAT_L         reduce using rule 81 (access -> name MEMBER name .)
    INT_L           reduce using rule 81 (access -> name MEMBER name .)
    CHAR_L          reduce using rule 81 (access -> name MEMBER name .)
    STRING_L        reduce using rule 81 (access -> name MEMBER name .)
    NONDECIMAL_L    reduce using rule 81 (access -> name MEMBER name .)
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110

  ! LBRACK          [ reduce using rule 81 (access -> name MEMBER name .) ]
  ! MEMBER          [ reduce using rule 81 (access -> name MEMBER name .) ]


state 151

    (62) for_loop -> FOR LPAREN init_var . conditional_expr SEMI ID INCREMENT RPAREN
    (57) conditional_expr -> . name conditional expression
    (58) conditional_expr -> . expression conditional name
    (59) conditional_expr -> . expression conditional expression
    (60) conditional_expr -> . name conditional name
    (61) conditional_expr -> . name
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    ID              shift and go to state 127
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    conditional_expr               shift and go to state 177
    name                           shift and go to state 129
    expression                     shift and go to state 130
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 152

    (111) init_var_ls -> modifier . dtype ID assign
    (113) init_var_ls -> modifier . dtype ID LBRACK RBRACK assign
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (18) struct_type -> . STRUCT ID

    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    STRUCT          shift and go to state 106
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    ID              shift and go to state 105

    dtype                          shift and go to state 178
    struct_type                    shift and go to state 33

state 153

    (112) init_var_ls -> dtype . ID assign
    (114) init_var_ls -> dtype . ID LBRACK RBRACK assign
    (30) dtype -> dtype . ASTERISK

    ID              shift and go to state 179
    ASTERISK        shift and go to state 60


state 154

    (76) func_def -> dtype ID LPAREN func_arglist . RPAREN LBRACE node_list RBRACE
    (78) func_decl -> dtype ID LPAREN func_arglist . RPAREN SEMI
    (74) func_arglist -> func_arglist . func_arg
    (75) func_arglist -> func_arglist . func_arg COMMA
    (66) func_arg -> . name
    (67) func_arg -> . dtype name
    (68) func_arg -> . dtype
    (69) func_arg -> . type_cast name
    (70) func_arg -> . type_cast expression
    (71) func_arg -> . func_call
    (72) func_arg -> . type_cast func_call
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (19) type_cast -> . LPAREN dtype RPAREN
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name
    (18) struct_type -> . STRUCT ID

    RPAREN          shift and go to state 180
    ID              shift and go to state 156
    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    STRUCT          shift and go to state 106
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    LPAREN          shift and go to state 96
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    dtype                          shift and go to state 160
    func_arg                       shift and go to state 158
    name                           shift and go to state 159
    type_cast                      shift and go to state 161
    func_call                      shift and go to state 162
    literal                        shift and go to state 52
    access                         shift and go to state 53
    struct_type                    shift and go to state 33

state 155

    (114) init_var_ls -> dtype ID LBRACK RBRACK . assign
    (16) assign -> . SIMPLE_ASSIGN
    (17) assign -> . COMPLEX_ASSIGN

    SIMPLE_ASSIGN   shift and go to state 111
    COMPLEX_ASSIGN  shift and go to state 112

    assign                         shift and go to state 181

state 156

    (39) name -> ID .
    (29) dtype -> ID .
    (77) func_call -> ID . LPAREN func_arglist RPAREN

  ! reduce/reduce conflict for ID resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for FLOAT_L resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for INT_L resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for CHAR_L resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for STRING_L resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for NONDECIMAL_L resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for CHAR resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for INT resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for STRUCT resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for VOID resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for UINT8_T resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for UINT16_T resolved using rule 29 (dtype -> ID .)
  ! reduce/reduce conflict for LPAREN resolved using rule 29 (dtype -> ID .)
  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACK          reduce using rule 39 (name -> ID .)
    MEMBER          reduce using rule 39 (name -> ID .)
    ASTERISK        reduce using rule 29 (dtype -> ID .)
    ID              reduce using rule 29 (dtype -> ID .)
    FLOAT_L         reduce using rule 29 (dtype -> ID .)
    INT_L           reduce using rule 29 (dtype -> ID .)
    CHAR_L          reduce using rule 29 (dtype -> ID .)
    STRING_L        reduce using rule 29 (dtype -> ID .)
    NONDECIMAL_L    reduce using rule 29 (dtype -> ID .)
    COMMA           reduce using rule 29 (dtype -> ID .)
    RPAREN          reduce using rule 29 (dtype -> ID .)
    CHAR            reduce using rule 29 (dtype -> ID .)
    DOUBLE          reduce using rule 29 (dtype -> ID .)
    FLOAT           reduce using rule 29 (dtype -> ID .)
    INT             reduce using rule 29 (dtype -> ID .)
    STRUCT          reduce using rule 29 (dtype -> ID .)
    VOID            reduce using rule 29 (dtype -> ID .)
    UINT8_T         reduce using rule 29 (dtype -> ID .)
    UINT16_T        reduce using rule 29 (dtype -> ID .)
    LPAREN          shift and go to state 62

  ! COMMA           [ reduce using rule 39 (name -> ID .) ]
  ! RPAREN          [ reduce using rule 39 (name -> ID .) ]
  ! ID              [ reduce using rule 39 (name -> ID .) ]
  ! CHAR            [ reduce using rule 39 (name -> ID .) ]
  ! DOUBLE          [ reduce using rule 39 (name -> ID .) ]
  ! FLOAT           [ reduce using rule 39 (name -> ID .) ]
  ! INT             [ reduce using rule 39 (name -> ID .) ]
  ! STRUCT          [ reduce using rule 39 (name -> ID .) ]
  ! VOID            [ reduce using rule 39 (name -> ID .) ]
  ! UINT8_T         [ reduce using rule 39 (name -> ID .) ]
  ! UINT16_T        [ reduce using rule 39 (name -> ID .) ]
  ! LPAREN          [ reduce using rule 39 (name -> ID .) ]
  ! FLOAT_L         [ reduce using rule 39 (name -> ID .) ]
  ! INT_L           [ reduce using rule 39 (name -> ID .) ]
  ! CHAR_L          [ reduce using rule 39 (name -> ID .) ]
  ! STRING_L        [ reduce using rule 39 (name -> ID .) ]
  ! NONDECIMAL_L    [ reduce using rule 39 (name -> ID .) ]
  ! LPAREN          [ reduce using rule 29 (dtype -> ID .) ]


state 157

    (77) func_call -> ID LPAREN func_arglist RPAREN .

    SEMI            reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    COMMA           reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    RPAREN          reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    ID              reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    CHAR            reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    DOUBLE          reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    FLOAT           reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    INT             reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    STRUCT          reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    VOID            reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    UINT8_T         reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    UINT16_T        reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    LPAREN          reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    FLOAT_L         reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    INT_L           reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    CHAR_L          reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    STRING_L        reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)
    NONDECIMAL_L    reduce using rule 77 (func_call -> ID LPAREN func_arglist RPAREN .)


state 158

    (74) func_arglist -> func_arglist func_arg .
    (75) func_arglist -> func_arglist func_arg . COMMA

    RPAREN          reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    ID              reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    CHAR            reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    DOUBLE          reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    FLOAT           reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    INT             reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    STRUCT          reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    VOID            reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    UINT8_T         reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    UINT16_T        reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    LPAREN          reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    FLOAT_L         reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    INT_L           reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    CHAR_L          reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    STRING_L        reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    NONDECIMAL_L    reduce using rule 74 (func_arglist -> func_arglist func_arg .)
    COMMA           shift and go to state 182


state 159

    (66) func_arg -> name .
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name

    COMMA           reduce using rule 66 (func_arg -> name .)
    RPAREN          reduce using rule 66 (func_arg -> name .)
    ID              reduce using rule 66 (func_arg -> name .)
    CHAR            reduce using rule 66 (func_arg -> name .)
    DOUBLE          reduce using rule 66 (func_arg -> name .)
    FLOAT           reduce using rule 66 (func_arg -> name .)
    INT             reduce using rule 66 (func_arg -> name .)
    STRUCT          reduce using rule 66 (func_arg -> name .)
    VOID            reduce using rule 66 (func_arg -> name .)
    UINT8_T         reduce using rule 66 (func_arg -> name .)
    UINT16_T        reduce using rule 66 (func_arg -> name .)
    LPAREN          reduce using rule 66 (func_arg -> name .)
    FLOAT_L         reduce using rule 66 (func_arg -> name .)
    INT_L           reduce using rule 66 (func_arg -> name .)
    CHAR_L          reduce using rule 66 (func_arg -> name .)
    STRING_L        reduce using rule 66 (func_arg -> name .)
    NONDECIMAL_L    reduce using rule 66 (func_arg -> name .)
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110


state 160

    (67) func_arg -> dtype . name
    (68) func_arg -> dtype .
    (30) dtype -> dtype . ASTERISK
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT_L resolved as shift
  ! shift/reduce conflict for INT_L resolved as shift
  ! shift/reduce conflict for CHAR_L resolved as shift
  ! shift/reduce conflict for STRING_L resolved as shift
  ! shift/reduce conflict for NONDECIMAL_L resolved as shift
    COMMA           reduce using rule 68 (func_arg -> dtype .)
    RPAREN          reduce using rule 68 (func_arg -> dtype .)
    CHAR            reduce using rule 68 (func_arg -> dtype .)
    DOUBLE          reduce using rule 68 (func_arg -> dtype .)
    FLOAT           reduce using rule 68 (func_arg -> dtype .)
    INT             reduce using rule 68 (func_arg -> dtype .)
    STRUCT          reduce using rule 68 (func_arg -> dtype .)
    VOID            reduce using rule 68 (func_arg -> dtype .)
    UINT8_T         reduce using rule 68 (func_arg -> dtype .)
    UINT16_T        reduce using rule 68 (func_arg -> dtype .)
    LPAREN          reduce using rule 68 (func_arg -> dtype .)
    ASTERISK        shift and go to state 60
    ID              shift and go to state 136
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

  ! ID              [ reduce using rule 68 (func_arg -> dtype .) ]
  ! FLOAT_L         [ reduce using rule 68 (func_arg -> dtype .) ]
  ! INT_L           [ reduce using rule 68 (func_arg -> dtype .) ]
  ! CHAR_L          [ reduce using rule 68 (func_arg -> dtype .) ]
  ! STRING_L        [ reduce using rule 68 (func_arg -> dtype .) ]
  ! NONDECIMAL_L    [ reduce using rule 68 (func_arg -> dtype .) ]

    name                           shift and go to state 183
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 161

    (69) func_arg -> type_cast . name
    (70) func_arg -> type_cast . expression
    (72) func_arg -> type_cast . func_call
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    ID              shift and go to state 187
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    name                           shift and go to state 184
    expression                     shift and go to state 185
    func_call                      shift and go to state 186
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 162

    (71) func_arg -> func_call .

    COMMA           reduce using rule 71 (func_arg -> func_call .)
    RPAREN          reduce using rule 71 (func_arg -> func_call .)
    ID              reduce using rule 71 (func_arg -> func_call .)
    CHAR            reduce using rule 71 (func_arg -> func_call .)
    DOUBLE          reduce using rule 71 (func_arg -> func_call .)
    FLOAT           reduce using rule 71 (func_arg -> func_call .)
    INT             reduce using rule 71 (func_arg -> func_call .)
    STRUCT          reduce using rule 71 (func_arg -> func_call .)
    VOID            reduce using rule 71 (func_arg -> func_call .)
    UINT8_T         reduce using rule 71 (func_arg -> func_call .)
    UINT16_T        reduce using rule 71 (func_arg -> func_call .)
    LPAREN          reduce using rule 71 (func_arg -> func_call .)
    FLOAT_L         reduce using rule 71 (func_arg -> func_call .)
    INT_L           reduce using rule 71 (func_arg -> func_call .)
    CHAR_L          reduce using rule 71 (func_arg -> func_call .)
    STRING_L        reduce using rule 71 (func_arg -> func_call .)
    NONDECIMAL_L    reduce using rule 71 (func_arg -> func_call .)


state 163

    (63) control_expr -> control LPAREN conditional_expr RPAREN . LBRACE node_list RBRACE

    LBRACE          shift and go to state 188


state 164

    (57) conditional_expr -> name conditional . expression
    (60) conditional_expr -> name conditional . name
    (103) binop -> conditional .
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEGATE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT_L resolved as shift
  ! shift/reduce conflict for INT_L resolved as shift
  ! shift/reduce conflict for CHAR_L resolved as shift
  ! shift/reduce conflict for STRING_L resolved as shift
  ! shift/reduce conflict for NONDECIMAL_L resolved as shift
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    ID              shift and go to state 65
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

  ! LPAREN          [ reduce using rule 103 (binop -> conditional .) ]
  ! NEGATE          [ reduce using rule 103 (binop -> conditional .) ]
  ! MINUS           [ reduce using rule 103 (binop -> conditional .) ]
  ! ID              [ reduce using rule 103 (binop -> conditional .) ]
  ! FLOAT_L         [ reduce using rule 103 (binop -> conditional .) ]
  ! INT_L           [ reduce using rule 103 (binop -> conditional .) ]
  ! CHAR_L          [ reduce using rule 103 (binop -> conditional .) ]
  ! STRING_L        [ reduce using rule 103 (binop -> conditional .) ]
  ! NONDECIMAL_L    [ reduce using rule 103 (binop -> conditional .) ]

    name                           shift and go to state 189
    expression                     shift and go to state 190
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 165

    (58) conditional_expr -> expression conditional . name
    (59) conditional_expr -> expression conditional . expression
    (103) binop -> conditional .
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEGATE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for FLOAT_L resolved as shift
  ! shift/reduce conflict for INT_L resolved as shift
  ! shift/reduce conflict for CHAR_L resolved as shift
  ! shift/reduce conflict for STRING_L resolved as shift
  ! shift/reduce conflict for NONDECIMAL_L resolved as shift
    ID              shift and go to state 127
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

  ! ID              [ reduce using rule 103 (binop -> conditional .) ]
  ! LPAREN          [ reduce using rule 103 (binop -> conditional .) ]
  ! NEGATE          [ reduce using rule 103 (binop -> conditional .) ]
  ! MINUS           [ reduce using rule 103 (binop -> conditional .) ]
  ! FLOAT_L         [ reduce using rule 103 (binop -> conditional .) ]
  ! INT_L           [ reduce using rule 103 (binop -> conditional .) ]
  ! CHAR_L          [ reduce using rule 103 (binop -> conditional .) ]
  ! STRING_L        [ reduce using rule 103 (binop -> conditional .) ]
  ! NONDECIMAL_L    [ reduce using rule 103 (binop -> conditional .) ]

    expression                     shift and go to state 191
    name                           shift and go to state 192
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 166

    (64) control_expr -> control LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    DEFINE          reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    IFNDEF          reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    ENDIF           reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    STRUCT          reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    CHAR            reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    INT             reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    VOID            reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    ID              reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    LPAREN          reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    NEGATE          reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    MINUS           reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    WHILE           reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    IF              reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    ELSE            reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    FOR             reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    CONST           reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    INLINE          reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    LONG            reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    SHORT           reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    FLOAT_L         reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    INT_L           reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    CHAR_L          reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    STRING_L        reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    NONDECIMAL_L    reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    $end            reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 64 (control_expr -> control LBRACE node_list RBRACE .)


state 167

    (65) control_expr -> for_loop LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    DEFINE          reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    IFNDEF          reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    ENDIF           reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    STRUCT          reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    CHAR            reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    INT             reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    VOID            reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    ID              reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    LPAREN          reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    NEGATE          reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    MINUS           reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    WHILE           reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    IF              reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    ELSE            reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    FOR             reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    CONST           reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    INLINE          reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    LONG            reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    SHORT           reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    FLOAT_L         reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    INT_L           reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    CHAR_L          reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    STRING_L        reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    NONDECIMAL_L    reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    $end            reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 65 (control_expr -> for_loop LBRACE node_list RBRACE .)


state 168

    (82) struct_def -> STRUCT ID LBRACE node_list . RBRACE SEMI
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (42) include -> . INCLUDE
    (43) define -> . DEFINE
    (44) if -> . IFNDEF
    (45) if -> . ENDIF
    (76) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (78) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (83) statement -> . init_var
    (84) statement -> . assign_var
    (85) statement -> . declare_var
    (86) statement -> . expression SEMI
    (87) statement -> . func_call SEMI
    (63) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (64) control_expr -> . control LBRACE node_list RBRACE
    (65) control_expr -> . for_loop LBRACE node_list RBRACE
    (82) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (118) init_var -> . init_var_ls init_var_rs
    (124) assign_var -> . assign_var_ls assign_var_rs
    (109) declare_var -> . dtype ID SEMI
    (110) declare_var -> . modifier dtype ID SEMI
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (46) control -> . WHILE
    (47) control -> . IF
    (48) control -> . ELSE
    (62) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT ID
    (111) init_var_ls -> . modifier dtype ID assign
    (112) init_var_ls -> . dtype ID assign
    (113) init_var_ls -> . modifier dtype ID LBRACK RBRACK assign
    (114) init_var_ls -> . dtype ID LBRACK RBRACK assign
    (119) assign_var_ls -> . name assign
    (31) modifier -> . CONST
    (32) modifier -> . EXTERN
    (33) modifier -> . INLINE
    (34) modifier -> . LONG
    (35) modifier -> . SHORT
    (36) modifier -> . SIGNED
    (37) modifier -> . UNSIGNED
    (38) modifier -> . VOLATILE
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    RBRACE          shift and go to state 193
    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    STRUCT          shift and go to state 25
    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    ID              shift and go to state 16
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    WHILE           shift and go to state 40
    IF              shift and go to state 41
    ELSE            shift and go to state 42
    FOR             shift and go to state 43
    CONST           shift and go to state 44
    EXTERN          shift and go to state 45
    INLINE          shift and go to state 46
    LONG            shift and go to state 47
    SHORT           shift and go to state 48
    SIGNED          shift and go to state 49
    UNSIGNED        shift and go to state 50
    VOLATILE        shift and go to state 51
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    dtype                          shift and go to state 15
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    control                        shift and go to state 23
    for_loop                       shift and go to state 24
    struct_type                    shift and go to state 33
    init_var_ls                    shift and go to state 34
    assign_var_ls                  shift and go to state 35
    modifier                       shift and go to state 36
    name                           shift and go to state 37
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 169

    (116) init_var_rs -> type_cast name SEMI .

    INCLUDE         reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    DEFINE          reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    IFNDEF          reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    ENDIF           reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    STRUCT          reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    CHAR            reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    DOUBLE          reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    FLOAT           reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    INT             reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    VOID            reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    UINT8_T         reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    UINT16_T        reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    ID              reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    LPAREN          reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    NEGATE          reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    MINUS           reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    WHILE           reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    IF              reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    ELSE            reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    FOR             reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    CONST           reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    EXTERN          reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    INLINE          reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    LONG            reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    SHORT           reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    SIGNED          reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    UNSIGNED        reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    VOLATILE        reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    FLOAT_L         reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    INT_L           reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    CHAR_L          reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    STRING_L        reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    NONDECIMAL_L    reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    $end            reduce using rule 116 (init_var_rs -> type_cast name SEMI .)
    RBRACE          reduce using rule 116 (init_var_rs -> type_cast name SEMI .)


state 170

    (19) type_cast -> LPAREN dtype RPAREN .

    ID              reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    FLOAT_L         reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    INT_L           reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    CHAR_L          reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    STRING_L        reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    NONDECIMAL_L    reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    LPAREN          reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    NEGATE          reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    MINUS           reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)


state 171

    (123) assign_var_rs -> type_cast assign_var_rs SEMI .

    INCLUDE         reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    DEFINE          reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    IFNDEF          reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    ENDIF           reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    STRUCT          reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    CHAR            reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    DOUBLE          reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    FLOAT           reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    INT             reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    VOID            reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    UINT8_T         reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    UINT16_T        reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    ID              reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    LPAREN          reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    NEGATE          reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    MINUS           reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    WHILE           reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    IF              reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    ELSE            reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    FOR             reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    CONST           reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    EXTERN          reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    INLINE          reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    LONG            reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    SHORT           reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    SIGNED          reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    UNSIGNED        reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    VOLATILE        reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    FLOAT_L         reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    INT_L           reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    CHAR_L          reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    STRING_L        reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    NONDECIMAL_L    reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    $end            reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    RBRACE          reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)
    SEMI            reduce using rule 123 (assign_var_rs -> type_cast assign_var_rs SEMI .)


state 172

    (110) declare_var -> modifier dtype ID SEMI .

    INCLUDE         reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    DEFINE          reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    IFNDEF          reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    ENDIF           reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    STRUCT          reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    CHAR            reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    DOUBLE          reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    FLOAT           reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    INT             reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    VOID            reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    UINT8_T         reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    UINT16_T        reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    ID              reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    LPAREN          reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    NEGATE          reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    MINUS           reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    WHILE           reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    IF              reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    ELSE            reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    FOR             reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    CONST           reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    EXTERN          reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    INLINE          reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    LONG            reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    SHORT           reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    SIGNED          reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    UNSIGNED        reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    VOLATILE        reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    FLOAT_L         reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    INT_L           reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    CHAR_L          reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    STRING_L        reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    NONDECIMAL_L    reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    $end            reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)
    RBRACE          reduce using rule 110 (declare_var -> modifier dtype ID SEMI .)


state 173

    (111) init_var_ls -> modifier dtype ID assign .

    ID              reduce using rule 111 (init_var_ls -> modifier dtype ID assign .)
    LPAREN          reduce using rule 111 (init_var_ls -> modifier dtype ID assign .)
    FLOAT_L         reduce using rule 111 (init_var_ls -> modifier dtype ID assign .)
    INT_L           reduce using rule 111 (init_var_ls -> modifier dtype ID assign .)
    CHAR_L          reduce using rule 111 (init_var_ls -> modifier dtype ID assign .)
    STRING_L        reduce using rule 111 (init_var_ls -> modifier dtype ID assign .)
    NONDECIMAL_L    reduce using rule 111 (init_var_ls -> modifier dtype ID assign .)


state 174

    (113) init_var_ls -> modifier dtype ID LBRACK . RBRACK assign

    RBRACK          shift and go to state 194


state 175

    (79) access -> name LBRACK name RBRACK .

    LBRACK          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    MEMBER          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    PLUS            reduce using rule 79 (access -> name LBRACK name RBRACK .)
    MINUS           reduce using rule 79 (access -> name LBRACK name RBRACK .)
    ASTERISK        reduce using rule 79 (access -> name LBRACK name RBRACK .)
    DIVIDE          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    LSHIFT          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    RSHIFT          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    PERCENT         reduce using rule 79 (access -> name LBRACK name RBRACK .)
    BITAND          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    BITOR           reduce using rule 79 (access -> name LBRACK name RBRACK .)
    SIMPLE_ASSIGN   reduce using rule 79 (access -> name LBRACK name RBRACK .)
    COMPLEX_ASSIGN  reduce using rule 79 (access -> name LBRACK name RBRACK .)
    EQ              reduce using rule 79 (access -> name LBRACK name RBRACK .)
    NEQ             reduce using rule 79 (access -> name LBRACK name RBRACK .)
    LT              reduce using rule 79 (access -> name LBRACK name RBRACK .)
    GT              reduce using rule 79 (access -> name LBRACK name RBRACK .)
    LE              reduce using rule 79 (access -> name LBRACK name RBRACK .)
    GE              reduce using rule 79 (access -> name LBRACK name RBRACK .)
    AND             reduce using rule 79 (access -> name LBRACK name RBRACK .)
    OR              reduce using rule 79 (access -> name LBRACK name RBRACK .)
    RPAREN          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    SEMI            reduce using rule 79 (access -> name LBRACK name RBRACK .)
    RBRACK          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    COMMA           reduce using rule 79 (access -> name LBRACK name RBRACK .)
    ID              reduce using rule 79 (access -> name LBRACK name RBRACK .)
    CHAR            reduce using rule 79 (access -> name LBRACK name RBRACK .)
    DOUBLE          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    FLOAT           reduce using rule 79 (access -> name LBRACK name RBRACK .)
    INT             reduce using rule 79 (access -> name LBRACK name RBRACK .)
    STRUCT          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    VOID            reduce using rule 79 (access -> name LBRACK name RBRACK .)
    UINT8_T         reduce using rule 79 (access -> name LBRACK name RBRACK .)
    UINT16_T        reduce using rule 79 (access -> name LBRACK name RBRACK .)
    LPAREN          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    FLOAT_L         reduce using rule 79 (access -> name LBRACK name RBRACK .)
    INT_L           reduce using rule 79 (access -> name LBRACK name RBRACK .)
    CHAR_L          reduce using rule 79 (access -> name LBRACK name RBRACK .)
    STRING_L        reduce using rule 79 (access -> name LBRACK name RBRACK .)
    NONDECIMAL_L    reduce using rule 79 (access -> name LBRACK name RBRACK .)


state 176

    (80) access -> name LBRACK expression RBRACK .

    LBRACK          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    MEMBER          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    PLUS            reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    MINUS           reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    ASTERISK        reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    DIVIDE          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    LSHIFT          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    RSHIFT          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    PERCENT         reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    BITAND          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    BITOR           reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    SIMPLE_ASSIGN   reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    COMPLEX_ASSIGN  reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    EQ              reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    NEQ             reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    LT              reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    GT              reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    LE              reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    GE              reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    AND             reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    OR              reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    RPAREN          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    SEMI            reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    RBRACK          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    COMMA           reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    ID              reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    CHAR            reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    DOUBLE          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    FLOAT           reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    INT             reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    STRUCT          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    VOID            reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    UINT8_T         reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    UINT16_T        reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    LPAREN          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    FLOAT_L         reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    INT_L           reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    CHAR_L          reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    STRING_L        reduce using rule 80 (access -> name LBRACK expression RBRACK .)
    NONDECIMAL_L    reduce using rule 80 (access -> name LBRACK expression RBRACK .)


state 177

    (62) for_loop -> FOR LPAREN init_var conditional_expr . SEMI ID INCREMENT RPAREN

    SEMI            shift and go to state 195


state 178

    (111) init_var_ls -> modifier dtype . ID assign
    (113) init_var_ls -> modifier dtype . ID LBRACK RBRACK assign
    (30) dtype -> dtype . ASTERISK

    ID              shift and go to state 196
    ASTERISK        shift and go to state 60


state 179

    (112) init_var_ls -> dtype ID . assign
    (114) init_var_ls -> dtype ID . LBRACK RBRACK assign
    (16) assign -> . SIMPLE_ASSIGN
    (17) assign -> . COMPLEX_ASSIGN

    LBRACK          shift and go to state 121
    SIMPLE_ASSIGN   shift and go to state 111
    COMPLEX_ASSIGN  shift and go to state 112

    assign                         shift and go to state 120

state 180

    (76) func_def -> dtype ID LPAREN func_arglist RPAREN . LBRACE node_list RBRACE
    (78) func_decl -> dtype ID LPAREN func_arglist RPAREN . SEMI

    LBRACE          shift and go to state 197
    SEMI            shift and go to state 198


state 181

    (114) init_var_ls -> dtype ID LBRACK RBRACK assign .

    ID              reduce using rule 114 (init_var_ls -> dtype ID LBRACK RBRACK assign .)
    LPAREN          reduce using rule 114 (init_var_ls -> dtype ID LBRACK RBRACK assign .)
    FLOAT_L         reduce using rule 114 (init_var_ls -> dtype ID LBRACK RBRACK assign .)
    INT_L           reduce using rule 114 (init_var_ls -> dtype ID LBRACK RBRACK assign .)
    CHAR_L          reduce using rule 114 (init_var_ls -> dtype ID LBRACK RBRACK assign .)
    STRING_L        reduce using rule 114 (init_var_ls -> dtype ID LBRACK RBRACK assign .)
    NONDECIMAL_L    reduce using rule 114 (init_var_ls -> dtype ID LBRACK RBRACK assign .)


state 182

    (75) func_arglist -> func_arglist func_arg COMMA .

    RPAREN          reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    ID              reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    CHAR            reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    DOUBLE          reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    FLOAT           reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    INT             reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    STRUCT          reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    VOID            reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    UINT8_T         reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    UINT16_T        reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    LPAREN          reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    FLOAT_L         reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    INT_L           reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    CHAR_L          reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    STRING_L        reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)
    NONDECIMAL_L    reduce using rule 75 (func_arglist -> func_arglist func_arg COMMA .)


state 183

    (67) func_arg -> dtype name .
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name

    COMMA           reduce using rule 67 (func_arg -> dtype name .)
    RPAREN          reduce using rule 67 (func_arg -> dtype name .)
    ID              reduce using rule 67 (func_arg -> dtype name .)
    CHAR            reduce using rule 67 (func_arg -> dtype name .)
    DOUBLE          reduce using rule 67 (func_arg -> dtype name .)
    FLOAT           reduce using rule 67 (func_arg -> dtype name .)
    INT             reduce using rule 67 (func_arg -> dtype name .)
    STRUCT          reduce using rule 67 (func_arg -> dtype name .)
    VOID            reduce using rule 67 (func_arg -> dtype name .)
    UINT8_T         reduce using rule 67 (func_arg -> dtype name .)
    UINT16_T        reduce using rule 67 (func_arg -> dtype name .)
    LPAREN          reduce using rule 67 (func_arg -> dtype name .)
    FLOAT_L         reduce using rule 67 (func_arg -> dtype name .)
    INT_L           reduce using rule 67 (func_arg -> dtype name .)
    CHAR_L          reduce using rule 67 (func_arg -> dtype name .)
    STRING_L        reduce using rule 67 (func_arg -> dtype name .)
    NONDECIMAL_L    reduce using rule 67 (func_arg -> dtype name .)
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110


state 184

    (69) func_arg -> type_cast name .
    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    COMMA           reduce using rule 69 (func_arg -> type_cast name .)
    RPAREN          reduce using rule 69 (func_arg -> type_cast name .)
    ID              reduce using rule 69 (func_arg -> type_cast name .)
    CHAR            reduce using rule 69 (func_arg -> type_cast name .)
    DOUBLE          reduce using rule 69 (func_arg -> type_cast name .)
    FLOAT           reduce using rule 69 (func_arg -> type_cast name .)
    INT             reduce using rule 69 (func_arg -> type_cast name .)
    STRUCT          reduce using rule 69 (func_arg -> type_cast name .)
    VOID            reduce using rule 69 (func_arg -> type_cast name .)
    UINT8_T         reduce using rule 69 (func_arg -> type_cast name .)
    UINT16_T        reduce using rule 69 (func_arg -> type_cast name .)
    LPAREN          reduce using rule 69 (func_arg -> type_cast name .)
    FLOAT_L         reduce using rule 69 (func_arg -> type_cast name .)
    INT_L           reduce using rule 69 (func_arg -> type_cast name .)
    CHAR_L          reduce using rule 69 (func_arg -> type_cast name .)
    STRING_L        reduce using rule 69 (func_arg -> type_cast name .)
    NONDECIMAL_L    reduce using rule 69 (func_arg -> type_cast name .)
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    binop                          shift and go to state 107
    conditional                    shift and go to state 77

state 185

    (70) func_arg -> type_cast expression .
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    COMMA           reduce using rule 70 (func_arg -> type_cast expression .)
    RPAREN          reduce using rule 70 (func_arg -> type_cast expression .)
    ID              reduce using rule 70 (func_arg -> type_cast expression .)
    CHAR            reduce using rule 70 (func_arg -> type_cast expression .)
    DOUBLE          reduce using rule 70 (func_arg -> type_cast expression .)
    FLOAT           reduce using rule 70 (func_arg -> type_cast expression .)
    INT             reduce using rule 70 (func_arg -> type_cast expression .)
    STRUCT          reduce using rule 70 (func_arg -> type_cast expression .)
    VOID            reduce using rule 70 (func_arg -> type_cast expression .)
    UINT8_T         reduce using rule 70 (func_arg -> type_cast expression .)
    UINT16_T        reduce using rule 70 (func_arg -> type_cast expression .)
    LPAREN          reduce using rule 70 (func_arg -> type_cast expression .)
    FLOAT_L         reduce using rule 70 (func_arg -> type_cast expression .)
    INT_L           reduce using rule 70 (func_arg -> type_cast expression .)
    CHAR_L          reduce using rule 70 (func_arg -> type_cast expression .)
    STRING_L        reduce using rule 70 (func_arg -> type_cast expression .)
    NONDECIMAL_L    reduce using rule 70 (func_arg -> type_cast expression .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    binop                          shift and go to state 67
    conditional                    shift and go to state 77

state 186

    (72) func_arg -> type_cast func_call .

    COMMA           reduce using rule 72 (func_arg -> type_cast func_call .)
    RPAREN          reduce using rule 72 (func_arg -> type_cast func_call .)
    ID              reduce using rule 72 (func_arg -> type_cast func_call .)
    CHAR            reduce using rule 72 (func_arg -> type_cast func_call .)
    DOUBLE          reduce using rule 72 (func_arg -> type_cast func_call .)
    FLOAT           reduce using rule 72 (func_arg -> type_cast func_call .)
    INT             reduce using rule 72 (func_arg -> type_cast func_call .)
    STRUCT          reduce using rule 72 (func_arg -> type_cast func_call .)
    VOID            reduce using rule 72 (func_arg -> type_cast func_call .)
    UINT8_T         reduce using rule 72 (func_arg -> type_cast func_call .)
    UINT16_T        reduce using rule 72 (func_arg -> type_cast func_call .)
    LPAREN          reduce using rule 72 (func_arg -> type_cast func_call .)
    FLOAT_L         reduce using rule 72 (func_arg -> type_cast func_call .)
    INT_L           reduce using rule 72 (func_arg -> type_cast func_call .)
    CHAR_L          reduce using rule 72 (func_arg -> type_cast func_call .)
    STRING_L        reduce using rule 72 (func_arg -> type_cast func_call .)
    NONDECIMAL_L    reduce using rule 72 (func_arg -> type_cast func_call .)


state 187

    (39) name -> ID .
    (108) expression -> ID . INCREMENT
    (77) func_call -> ID . LPAREN func_arglist RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACK          reduce using rule 39 (name -> ID .)
    MEMBER          reduce using rule 39 (name -> ID .)
    PLUS            reduce using rule 39 (name -> ID .)
    MINUS           reduce using rule 39 (name -> ID .)
    ASTERISK        reduce using rule 39 (name -> ID .)
    DIVIDE          reduce using rule 39 (name -> ID .)
    LSHIFT          reduce using rule 39 (name -> ID .)
    RSHIFT          reduce using rule 39 (name -> ID .)
    PERCENT         reduce using rule 39 (name -> ID .)
    BITAND          reduce using rule 39 (name -> ID .)
    BITOR           reduce using rule 39 (name -> ID .)
    EQ              reduce using rule 39 (name -> ID .)
    NEQ             reduce using rule 39 (name -> ID .)
    LT              reduce using rule 39 (name -> ID .)
    GT              reduce using rule 39 (name -> ID .)
    LE              reduce using rule 39 (name -> ID .)
    GE              reduce using rule 39 (name -> ID .)
    AND             reduce using rule 39 (name -> ID .)
    OR              reduce using rule 39 (name -> ID .)
    COMMA           reduce using rule 39 (name -> ID .)
    RPAREN          reduce using rule 39 (name -> ID .)
    ID              reduce using rule 39 (name -> ID .)
    CHAR            reduce using rule 39 (name -> ID .)
    DOUBLE          reduce using rule 39 (name -> ID .)
    FLOAT           reduce using rule 39 (name -> ID .)
    INT             reduce using rule 39 (name -> ID .)
    STRUCT          reduce using rule 39 (name -> ID .)
    VOID            reduce using rule 39 (name -> ID .)
    UINT8_T         reduce using rule 39 (name -> ID .)
    UINT16_T        reduce using rule 39 (name -> ID .)
    FLOAT_L         reduce using rule 39 (name -> ID .)
    INT_L           reduce using rule 39 (name -> ID .)
    CHAR_L          reduce using rule 39 (name -> ID .)
    STRING_L        reduce using rule 39 (name -> ID .)
    NONDECIMAL_L    reduce using rule 39 (name -> ID .)
    INCREMENT       shift and go to state 61
    LPAREN          shift and go to state 62

  ! LPAREN          [ reduce using rule 39 (name -> ID .) ]


state 188

    (63) control_expr -> control LPAREN conditional_expr RPAREN LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 199

state 189

    (60) conditional_expr -> name conditional name .
    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    RPAREN          reduce using rule 60 (conditional_expr -> name conditional name .)
    SEMI            reduce using rule 60 (conditional_expr -> name conditional name .)
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    conditional                    shift and go to state 77
    binop                          shift and go to state 107

state 190

    (57) conditional_expr -> name conditional expression .
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    RPAREN          reduce using rule 57 (conditional_expr -> name conditional expression .)
    SEMI            reduce using rule 57 (conditional_expr -> name conditional expression .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    conditional                    shift and go to state 77
    binop                          shift and go to state 67

state 191

    (59) conditional_expr -> expression conditional expression .
    (104) expression -> expression . binop name
    (107) expression -> expression . binop expression
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    RPAREN          reduce using rule 59 (conditional_expr -> expression conditional expression .)
    SEMI            reduce using rule 59 (conditional_expr -> expression conditional expression .)
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    conditional                    shift and go to state 77
    binop                          shift and go to state 67

state 192

    (58) conditional_expr -> expression conditional name .
    (105) expression -> name . binop expression
    (106) expression -> name . binop name
    (79) access -> name . LBRACK name RBRACK
    (80) access -> name . LBRACK expression RBRACK
    (81) access -> name . MEMBER name
    (94) binop -> . PLUS
    (95) binop -> . MINUS
    (96) binop -> . ASTERISK
    (97) binop -> . DIVIDE
    (98) binop -> . LSHIFT
    (99) binop -> . RSHIFT
    (100) binop -> . PERCENT
    (101) binop -> . BITAND
    (102) binop -> . BITOR
    (103) binop -> . conditional
    (49) conditional -> . EQ
    (50) conditional -> . NEQ
    (51) conditional -> . LT
    (52) conditional -> . GT
    (53) conditional -> . LE
    (54) conditional -> . GE
    (55) conditional -> . AND
    (56) conditional -> . OR

    RPAREN          reduce using rule 58 (conditional_expr -> expression conditional name .)
    SEMI            reduce using rule 58 (conditional_expr -> expression conditional name .)
    LBRACK          shift and go to state 109
    MEMBER          shift and go to state 110
    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    ASTERISK        shift and go to state 70
    DIVIDE          shift and go to state 71
    LSHIFT          shift and go to state 72
    RSHIFT          shift and go to state 73
    PERCENT         shift and go to state 74
    BITAND          shift and go to state 75
    BITOR           shift and go to state 76
    EQ              shift and go to state 78
    NEQ             shift and go to state 79
    LT              shift and go to state 80
    GT              shift and go to state 81
    LE              shift and go to state 82
    GE              shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85

    conditional                    shift and go to state 77
    binop                          shift and go to state 107

state 193

    (82) struct_def -> STRUCT ID LBRACE node_list RBRACE . SEMI

    SEMI            shift and go to state 200


state 194

    (113) init_var_ls -> modifier dtype ID LBRACK RBRACK . assign
    (16) assign -> . SIMPLE_ASSIGN
    (17) assign -> . COMPLEX_ASSIGN

    SIMPLE_ASSIGN   shift and go to state 111
    COMPLEX_ASSIGN  shift and go to state 112

    assign                         shift and go to state 201

state 195

    (62) for_loop -> FOR LPAREN init_var conditional_expr SEMI . ID INCREMENT RPAREN

    ID              shift and go to state 202


state 196

    (111) init_var_ls -> modifier dtype ID . assign
    (113) init_var_ls -> modifier dtype ID . LBRACK RBRACK assign
    (16) assign -> . SIMPLE_ASSIGN
    (17) assign -> . COMPLEX_ASSIGN

    LBRACK          shift and go to state 174
    SIMPLE_ASSIGN   shift and go to state 111
    COMPLEX_ASSIGN  shift and go to state 112

    assign                         shift and go to state 173

state 197

    (76) func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 203

state 198

    (78) func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .

    INCLUDE         reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    DEFINE          reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    IFNDEF          reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    ENDIF           reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    STRUCT          reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    CHAR            reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    DOUBLE          reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    FLOAT           reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    INT             reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    VOID            reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    UINT8_T         reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    UINT16_T        reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    ID              reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    LPAREN          reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    NEGATE          reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    MINUS           reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    WHILE           reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    IF              reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    ELSE            reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    FOR             reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    CONST           reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    EXTERN          reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    INLINE          reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    LONG            reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    SHORT           reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    SIGNED          reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    UNSIGNED        reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    VOLATILE        reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    FLOAT_L         reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    INT_L           reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    CHAR_L          reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    STRING_L        reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    NONDECIMAL_L    reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    $end            reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    RBRACE          reduce using rule 78 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)


state 199

    (63) control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (42) include -> . INCLUDE
    (43) define -> . DEFINE
    (44) if -> . IFNDEF
    (45) if -> . ENDIF
    (76) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (78) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (83) statement -> . init_var
    (84) statement -> . assign_var
    (85) statement -> . declare_var
    (86) statement -> . expression SEMI
    (87) statement -> . func_call SEMI
    (63) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (64) control_expr -> . control LBRACE node_list RBRACE
    (65) control_expr -> . for_loop LBRACE node_list RBRACE
    (82) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (118) init_var -> . init_var_ls init_var_rs
    (124) assign_var -> . assign_var_ls assign_var_rs
    (109) declare_var -> . dtype ID SEMI
    (110) declare_var -> . modifier dtype ID SEMI
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (46) control -> . WHILE
    (47) control -> . IF
    (48) control -> . ELSE
    (62) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT ID
    (111) init_var_ls -> . modifier dtype ID assign
    (112) init_var_ls -> . dtype ID assign
    (113) init_var_ls -> . modifier dtype ID LBRACK RBRACK assign
    (114) init_var_ls -> . dtype ID LBRACK RBRACK assign
    (119) assign_var_ls -> . name assign
    (31) modifier -> . CONST
    (32) modifier -> . EXTERN
    (33) modifier -> . INLINE
    (34) modifier -> . LONG
    (35) modifier -> . SHORT
    (36) modifier -> . SIGNED
    (37) modifier -> . UNSIGNED
    (38) modifier -> . VOLATILE
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    RBRACE          shift and go to state 204
    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    STRUCT          shift and go to state 25
    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    ID              shift and go to state 16
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    WHILE           shift and go to state 40
    IF              shift and go to state 41
    ELSE            shift and go to state 42
    FOR             shift and go to state 43
    CONST           shift and go to state 44
    EXTERN          shift and go to state 45
    INLINE          shift and go to state 46
    LONG            shift and go to state 47
    SHORT           shift and go to state 48
    SIGNED          shift and go to state 49
    UNSIGNED        shift and go to state 50
    VOLATILE        shift and go to state 51
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    control                        shift and go to state 23
    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    dtype                          shift and go to state 15
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    for_loop                       shift and go to state 24
    struct_type                    shift and go to state 33
    init_var_ls                    shift and go to state 34
    assign_var_ls                  shift and go to state 35
    modifier                       shift and go to state 36
    name                           shift and go to state 37
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 200

    (82) struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .

    INCLUDE         reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    DEFINE          reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    IFNDEF          reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    ENDIF           reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    STRUCT          reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    CHAR            reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    DOUBLE          reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    FLOAT           reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    INT             reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    VOID            reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    UINT8_T         reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    UINT16_T        reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    ID              reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    LPAREN          reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    NEGATE          reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    MINUS           reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    WHILE           reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    IF              reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    ELSE            reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    FOR             reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    CONST           reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    EXTERN          reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    INLINE          reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    LONG            reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    SHORT           reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    SIGNED          reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    UNSIGNED        reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    VOLATILE        reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    FLOAT_L         reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    INT_L           reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    CHAR_L          reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    STRING_L        reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    NONDECIMAL_L    reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    $end            reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    RBRACE          reduce using rule 82 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)


state 201

    (113) init_var_ls -> modifier dtype ID LBRACK RBRACK assign .

    ID              reduce using rule 113 (init_var_ls -> modifier dtype ID LBRACK RBRACK assign .)
    LPAREN          reduce using rule 113 (init_var_ls -> modifier dtype ID LBRACK RBRACK assign .)
    FLOAT_L         reduce using rule 113 (init_var_ls -> modifier dtype ID LBRACK RBRACK assign .)
    INT_L           reduce using rule 113 (init_var_ls -> modifier dtype ID LBRACK RBRACK assign .)
    CHAR_L          reduce using rule 113 (init_var_ls -> modifier dtype ID LBRACK RBRACK assign .)
    STRING_L        reduce using rule 113 (init_var_ls -> modifier dtype ID LBRACK RBRACK assign .)
    NONDECIMAL_L    reduce using rule 113 (init_var_ls -> modifier dtype ID LBRACK RBRACK assign .)


state 202

    (62) for_loop -> FOR LPAREN init_var conditional_expr SEMI ID . INCREMENT RPAREN

    INCREMENT       shift and go to state 205


state 203

    (76) func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (42) include -> . INCLUDE
    (43) define -> . DEFINE
    (44) if -> . IFNDEF
    (45) if -> . ENDIF
    (76) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (78) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (83) statement -> . init_var
    (84) statement -> . assign_var
    (85) statement -> . declare_var
    (86) statement -> . expression SEMI
    (87) statement -> . func_call SEMI
    (63) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (64) control_expr -> . control LBRACE node_list RBRACE
    (65) control_expr -> . for_loop LBRACE node_list RBRACE
    (82) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (20) dtype -> . CHAR
    (21) dtype -> . DOUBLE
    (22) dtype -> . FLOAT
    (23) dtype -> . INT
    (24) dtype -> . STRUCT
    (25) dtype -> . VOID
    (26) dtype -> . UINT8_T
    (27) dtype -> . UINT16_T
    (28) dtype -> . struct_type
    (29) dtype -> . ID
    (30) dtype -> . dtype ASTERISK
    (118) init_var -> . init_var_ls init_var_rs
    (124) assign_var -> . assign_var_ls assign_var_rs
    (109) declare_var -> . dtype ID SEMI
    (110) declare_var -> . modifier dtype ID SEMI
    (88) expression -> . LPAREN expression RPAREN
    (89) expression -> . LPAREN name RPAREN
    (90) expression -> . NEGATE expression
    (91) expression -> . MINUS expression
    (92) expression -> . NEGATE name
    (93) expression -> . MINUS name
    (104) expression -> . expression binop name
    (105) expression -> . name binop expression
    (106) expression -> . name binop name
    (107) expression -> . expression binop expression
    (108) expression -> . ID INCREMENT
    (77) func_call -> . ID LPAREN func_arglist RPAREN
    (46) control -> . WHILE
    (47) control -> . IF
    (48) control -> . ELSE
    (62) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT ID
    (111) init_var_ls -> . modifier dtype ID assign
    (112) init_var_ls -> . dtype ID assign
    (113) init_var_ls -> . modifier dtype ID LBRACK RBRACK assign
    (114) init_var_ls -> . dtype ID LBRACK RBRACK assign
    (119) assign_var_ls -> . name assign
    (31) modifier -> . CONST
    (32) modifier -> . EXTERN
    (33) modifier -> . INLINE
    (34) modifier -> . LONG
    (35) modifier -> . SHORT
    (36) modifier -> . SIGNED
    (37) modifier -> . UNSIGNED
    (38) modifier -> . VOLATILE
    (39) name -> . ID
    (40) name -> . literal
    (41) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (79) access -> . name LBRACK name RBRACK
    (80) access -> . name LBRACK expression RBRACK
    (81) access -> . name MEMBER name

    RBRACE          shift and go to state 206
    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    STRUCT          shift and go to state 25
    CHAR            shift and go to state 26
    DOUBLE          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    VOID            shift and go to state 30
    UINT8_T         shift and go to state 31
    UINT16_T        shift and go to state 32
    ID              shift and go to state 16
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 38
    MINUS           shift and go to state 39
    WHILE           shift and go to state 40
    IF              shift and go to state 41
    ELSE            shift and go to state 42
    FOR             shift and go to state 43
    CONST           shift and go to state 44
    EXTERN          shift and go to state 45
    INLINE          shift and go to state 46
    LONG            shift and go to state 47
    SHORT           shift and go to state 48
    SIGNED          shift and go to state 49
    UNSIGNED        shift and go to state 50
    VOLATILE        shift and go to state 51
    FLOAT_L         shift and go to state 54
    INT_L           shift and go to state 55
    CHAR_L          shift and go to state 56
    STRING_L        shift and go to state 57
    NONDECIMAL_L    shift and go to state 58

    dtype                          shift and go to state 15
    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    control                        shift and go to state 23
    for_loop                       shift and go to state 24
    struct_type                    shift and go to state 33
    init_var_ls                    shift and go to state 34
    assign_var_ls                  shift and go to state 35
    modifier                       shift and go to state 36
    name                           shift and go to state 37
    literal                        shift and go to state 52
    access                         shift and go to state 53

state 204

    (63) control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    DEFINE          reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    IFNDEF          reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    ENDIF           reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    STRUCT          reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    CHAR            reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    INT             reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    VOID            reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    ID              reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    LPAREN          reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    NEGATE          reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    MINUS           reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    WHILE           reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    IF              reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    ELSE            reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    FOR             reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    CONST           reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    INLINE          reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    LONG            reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    SHORT           reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    FLOAT_L         reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    INT_L           reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    CHAR_L          reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    STRING_L        reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    NONDECIMAL_L    reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    $end            reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 63 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)


state 205

    (62) for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT . RPAREN

    RPAREN          shift and go to state 207


state 206

    (76) func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    DEFINE          reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    IFNDEF          reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    ENDIF           reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    STRUCT          reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    CHAR            reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    INT             reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    VOID            reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    ID              reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    LPAREN          reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    NEGATE          reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    MINUS           reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    WHILE           reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    IF              reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    ELSE            reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    FOR             reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    CONST           reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    INLINE          reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    LONG            reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    SHORT           reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    FLOAT_L         reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    INT_L           reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    CHAR_L          reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    STRING_L        reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    NONDECIMAL_L    reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    $end            reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 76 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)


state 207

    (62) for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN .

    LBRACE          reduce using rule 62 (for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 25 resolved as shift
WARNING: shift/reduce conflict for ID in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 113 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 113 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 113 resolved as shift
WARNING: shift/reduce conflict for BITAND in state 113 resolved as shift
WARNING: shift/reduce conflict for BITOR in state 113 resolved as shift
WARNING: shift/reduce conflict for EQ in state 113 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 113 resolved as shift
WARNING: shift/reduce conflict for LT in state 113 resolved as shift
WARNING: shift/reduce conflict for GT in state 113 resolved as shift
WARNING: shift/reduce conflict for LE in state 113 resolved as shift
WARNING: shift/reduce conflict for GE in state 113 resolved as shift
WARNING: shift/reduce conflict for AND in state 113 resolved as shift
WARNING: shift/reduce conflict for OR in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 114 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 114 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 114 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 114 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 114 resolved as shift
WARNING: shift/reduce conflict for BITAND in state 114 resolved as shift
WARNING: shift/reduce conflict for BITOR in state 114 resolved as shift
WARNING: shift/reduce conflict for EQ in state 114 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 114 resolved as shift
WARNING: shift/reduce conflict for LT in state 114 resolved as shift
WARNING: shift/reduce conflict for GT in state 114 resolved as shift
WARNING: shift/reduce conflict for LE in state 114 resolved as shift
WARNING: shift/reduce conflict for GE in state 114 resolved as shift
WARNING: shift/reduce conflict for AND in state 114 resolved as shift
WARNING: shift/reduce conflict for OR in state 114 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 115 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 115 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 115 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 115 resolved as shift
WARNING: shift/reduce conflict for BITAND in state 115 resolved as shift
WARNING: shift/reduce conflict for BITOR in state 115 resolved as shift
WARNING: shift/reduce conflict for EQ in state 115 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 115 resolved as shift
WARNING: shift/reduce conflict for LT in state 115 resolved as shift
WARNING: shift/reduce conflict for GT in state 115 resolved as shift
WARNING: shift/reduce conflict for LE in state 115 resolved as shift
WARNING: shift/reduce conflict for GE in state 115 resolved as shift
WARNING: shift/reduce conflict for AND in state 115 resolved as shift
WARNING: shift/reduce conflict for OR in state 115 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 116 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 116 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 116 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 116 resolved as shift
WARNING: shift/reduce conflict for BITAND in state 116 resolved as shift
WARNING: shift/reduce conflict for BITOR in state 116 resolved as shift
WARNING: shift/reduce conflict for EQ in state 116 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 116 resolved as shift
WARNING: shift/reduce conflict for LT in state 116 resolved as shift
WARNING: shift/reduce conflict for GT in state 116 resolved as shift
WARNING: shift/reduce conflict for LE in state 116 resolved as shift
WARNING: shift/reduce conflict for GE in state 116 resolved as shift
WARNING: shift/reduce conflict for AND in state 116 resolved as shift
WARNING: shift/reduce conflict for OR in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 125 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 125 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 125 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 125 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 125 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 125 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 125 resolved as shift
WARNING: shift/reduce conflict for BITAND in state 125 resolved as shift
WARNING: shift/reduce conflict for BITOR in state 125 resolved as shift
WARNING: shift/reduce conflict for EQ in state 125 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 125 resolved as shift
WARNING: shift/reduce conflict for LT in state 125 resolved as shift
WARNING: shift/reduce conflict for GT in state 125 resolved as shift
WARNING: shift/reduce conflict for LE in state 125 resolved as shift
WARNING: shift/reduce conflict for GE in state 125 resolved as shift
WARNING: shift/reduce conflict for AND in state 125 resolved as shift
WARNING: shift/reduce conflict for OR in state 125 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 126 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 126 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 126 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 126 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 126 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 126 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 126 resolved as shift
WARNING: shift/reduce conflict for BITAND in state 126 resolved as shift
WARNING: shift/reduce conflict for BITOR in state 126 resolved as shift
WARNING: shift/reduce conflict for EQ in state 126 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 126 resolved as shift
WARNING: shift/reduce conflict for LT in state 126 resolved as shift
WARNING: shift/reduce conflict for GT in state 126 resolved as shift
WARNING: shift/reduce conflict for LE in state 126 resolved as shift
WARNING: shift/reduce conflict for GE in state 126 resolved as shift
WARNING: shift/reduce conflict for AND in state 126 resolved as shift
WARNING: shift/reduce conflict for OR in state 126 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 146 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 146 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 146 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 146 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 146 resolved as shift
WARNING: shift/reduce conflict for BITAND in state 146 resolved as shift
WARNING: shift/reduce conflict for BITOR in state 146 resolved as shift
WARNING: shift/reduce conflict for EQ in state 146 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 146 resolved as shift
WARNING: shift/reduce conflict for LT in state 146 resolved as shift
WARNING: shift/reduce conflict for GT in state 146 resolved as shift
WARNING: shift/reduce conflict for LE in state 146 resolved as shift
WARNING: shift/reduce conflict for GE in state 146 resolved as shift
WARNING: shift/reduce conflict for AND in state 146 resolved as shift
WARNING: shift/reduce conflict for OR in state 146 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 147 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 147 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 147 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 147 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 147 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 147 resolved as shift
WARNING: shift/reduce conflict for BITAND in state 147 resolved as shift
WARNING: shift/reduce conflict for BITOR in state 147 resolved as shift
WARNING: shift/reduce conflict for EQ in state 147 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 147 resolved as shift
WARNING: shift/reduce conflict for LT in state 147 resolved as shift
WARNING: shift/reduce conflict for GT in state 147 resolved as shift
WARNING: shift/reduce conflict for LE in state 147 resolved as shift
WARNING: shift/reduce conflict for GE in state 147 resolved as shift
WARNING: shift/reduce conflict for AND in state 147 resolved as shift
WARNING: shift/reduce conflict for OR in state 147 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 150 resolved as shift
WARNING: shift/reduce conflict for MEMBER in state 150 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 156 resolved as shift
WARNING: shift/reduce conflict for ID in state 160 resolved as shift
WARNING: shift/reduce conflict for FLOAT_L in state 160 resolved as shift
WARNING: shift/reduce conflict for INT_L in state 160 resolved as shift
WARNING: shift/reduce conflict for CHAR_L in state 160 resolved as shift
WARNING: shift/reduce conflict for STRING_L in state 160 resolved as shift
WARNING: shift/reduce conflict for NONDECIMAL_L in state 160 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 164 resolved as shift
WARNING: shift/reduce conflict for NEGATE in state 164 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 164 resolved as shift
WARNING: shift/reduce conflict for ID in state 164 resolved as shift
WARNING: shift/reduce conflict for FLOAT_L in state 164 resolved as shift
WARNING: shift/reduce conflict for INT_L in state 164 resolved as shift
WARNING: shift/reduce conflict for CHAR_L in state 164 resolved as shift
WARNING: shift/reduce conflict for STRING_L in state 164 resolved as shift
WARNING: shift/reduce conflict for NONDECIMAL_L in state 164 resolved as shift
WARNING: shift/reduce conflict for ID in state 165 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 165 resolved as shift
WARNING: shift/reduce conflict for NEGATE in state 165 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOAT_L in state 165 resolved as shift
WARNING: shift/reduce conflict for INT_L in state 165 resolved as shift
WARNING: shift/reduce conflict for CHAR_L in state 165 resolved as shift
WARNING: shift/reduce conflict for STRING_L in state 165 resolved as shift
WARNING: shift/reduce conflict for NONDECIMAL_L in state 165 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 187 resolved as shift
WARNING: reduce/reduce conflict in state 16 resolved using rule (dtype -> ID)
WARNING: rejected rule (name -> ID) in state 16
WARNING: reduce/reduce conflict in state 143 resolved using rule (dtype -> ID)
WARNING: rejected rule (name -> ID) in state 143
WARNING: reduce/reduce conflict in state 156 resolved using rule (dtype -> ID)
WARNING: rejected rule (name -> ID) in state 156
