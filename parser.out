Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AUTO
    BREAK
    CASE
    COMMENT
    CONTINUE
    DEFAULT
    DO
    ENUM
    GOTO
    LCOMMENT
    NUMBER
    REGISTER
    RESTRICT
    STATIC
    SWITCH
    UNION
    _ALIGNAS
    _ALIGNOF
    _ATOMIC
    _BOOL
    _COMPLEX
    _GENERIC
    _IMAGERY
    _NORETURN
    _STATIC_ASSERT
    _THREAD_LOCAL

Grammar

Rule 0     S' -> node_list
Rule 1     node_list -> <empty>
Rule 2     node_list -> node_list node
Rule 3     node -> include
Rule 4     node -> define
Rule 5     node -> if
Rule 6     node -> func_def
Rule 7     node -> func_decl
Rule 8     node -> statement
Rule 9     node -> control_expr
Rule 10    node -> struct_def
Rule 11    literal -> FLOAT_L
Rule 12    literal -> INT_L
Rule 13    literal -> CHAR_L
Rule 14    literal -> STRING_L
Rule 15    literal -> NONDECIMAL_L
Rule 16    assign -> SIMPLE_ASSIGN
Rule 17    assign -> COMPLEX_ASSIGN
Rule 18    struct_type -> STRUCT name
Rule 19    type_cast -> LPAREN dtype RPAREN
Rule 20    modifier -> CONST
Rule 21    modifier -> EXTERN
Rule 22    modifier -> INLINE
Rule 23    modifier -> LONG
Rule 24    modifier -> SHORT
Rule 25    modifier -> SIGNED
Rule 26    modifier -> UNSIGNED
Rule 27    modifier -> VOLATILE
Rule 28    modifier_list -> <empty>
Rule 29    modifier_list -> modifier_list modifier
Rule 30    modified -> modifier_list dtype
Rule 31    modified -> modifier
Rule 32    dtype -> CHAR
Rule 33    dtype -> DOUBLE
Rule 34    dtype -> FLOAT
Rule 35    dtype -> INT
Rule 36    dtype -> VOID
Rule 37    dtype -> UINT8_T
Rule 38    dtype -> UINT16_T
Rule 39    dtype -> struct_type
Rule 40    dtype -> ID
Rule 41    dtype -> dtype ASTERISK
Rule 42    name -> ID
Rule 43    name -> literal
Rule 44    name -> access
Rule 45    include -> INCLUDE
Rule 46    define -> DEFINE
Rule 47    if -> IFNDEF
Rule 48    if -> ENDIF
Rule 49    control -> WHILE
Rule 50    control -> IF
Rule 51    control -> ELSE
Rule 52    conditional -> EQ
Rule 53    conditional -> NEQ
Rule 54    conditional -> LT
Rule 55    conditional -> GT
Rule 56    conditional -> LE
Rule 57    conditional -> GE
Rule 58    conditional -> AND
Rule 59    conditional -> OR
Rule 60    conditional_expr -> name conditional expression
Rule 61    conditional_expr -> expression conditional name
Rule 62    conditional_expr -> expression conditional expression
Rule 63    conditional_expr -> name conditional name
Rule 64    conditional_expr -> name
Rule 65    conditional_expr -> expression
Rule 66    for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
Rule 67    control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
Rule 68    control_expr -> control LBRACE node_list RBRACE
Rule 69    control_expr -> for_loop LBRACE node_list RBRACE
Rule 70    func_arg -> name
Rule 71    func_arg -> dtype name
Rule 72    func_arg -> dtype
Rule 73    func_arg -> type_cast name
Rule 74    func_arg -> type_cast expression
Rule 75    func_arg -> func_call
Rule 76    func_arg -> type_cast func_call
Rule 77    func_arglist -> <empty>
Rule 78    func_arglist -> func_arglist func_arg
Rule 79    func_arglist -> func_arglist func_arg COMMA
Rule 80    func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
Rule 81    func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
Rule 82    func_call -> ID LPAREN func_arglist RPAREN
Rule 83    func_call -> SIZEOF LPAREN func_arglist RPAREN
Rule 84    func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI
Rule 85    access -> name LBRACK name RBRACK
Rule 86    access -> name LBRACK expression RBRACK
Rule 87    access -> name MEMBER name
Rule 88    access -> BITAND name
Rule 89    struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI
Rule 90    struct_typedef -> TYPEDEF STRUCT LBRACE node_list RBRACE ID SEMI
Rule 91    statement -> init_var
Rule 92    statement -> assign_var
Rule 93    statement -> declare_var
Rule 94    statement -> expression SEMI
Rule 95    statement -> func_call SEMI
Rule 96    statement -> return SEMI
Rule 97    expression -> LPAREN expression RPAREN
Rule 98    expression -> LPAREN name RPAREN
Rule 99    expression -> NEGATE expression
Rule 100   expression -> MINUS expression
Rule 101   expression -> NEGATE name
Rule 102   expression -> MINUS name
Rule 103   binop -> PLUS
Rule 104   binop -> MINUS
Rule 105   binop -> ASTERISK
Rule 106   binop -> DIVIDE
Rule 107   binop -> LSHIFT
Rule 108   binop -> RSHIFT
Rule 109   binop -> PERCENT
Rule 110   binop -> BITAND
Rule 111   binop -> BITOR
Rule 112   binop -> conditional
Rule 113   operand -> name
Rule 114   operand -> expression
Rule 115   operand -> type_cast name
Rule 116   operand -> func_call
Rule 117   expression -> operand binop operand
Rule 118   expression -> name INCREMENT
Rule 119   return -> RETURN name
Rule 120   return -> RETURN expression
Rule 121   complex_dtype -> dtype
Rule 122   complex_dtype -> modifier dtype
Rule 123   declare_var_ls -> dtype ID
Rule 124   declare_var_ls -> modifier dtype ID
Rule 125   declare_var -> declare_var_ls SEMI
Rule 126   vector_init -> LBRACK RBRACK
Rule 127   vector_init -> LBRACK name RBRACK
Rule 128   vector_init_list -> <empty>
Rule 129   vector_init_list -> vector_init_list vector_init
Rule 130   init_var_ls -> declare_var_ls assign
Rule 131   init_var_ls -> declare_var_ls vector_init assign
Rule 132   typecast_init -> type_cast init_var_rs
Rule 133   init_var_rs -> name SEMI
Rule 134   init_var_rs -> func_call SEMI
Rule 135   init_var_rs -> expression SEMI
Rule 136   init_var_rs -> typecast_init
Rule 137   init_var_rs -> LPAREN name RPAREN
Rule 138   init_var_rs -> error SEMI
Rule 139   init_var -> init_var_ls init_var_rs
Rule 140   assign_var_ls -> name assign
Rule 141   assign_var_rs -> init_var_rs
Rule 142   assign_var -> assign_var_ls assign_var_rs

Terminals, with rules where they appear

AND                  : 58
ASTERISK             : 41 105
AUTO                 : 
BITAND               : 88 110
BITOR                : 111
BREAK                : 
CASE                 : 
CHAR                 : 32
CHAR_L               : 13
COMMA                : 79
COMMENT              : 
COMPLEX_ASSIGN       : 17
CONST                : 20
CONTINUE             : 
DEFAULT              : 
DEFINE               : 46
DIVIDE               : 106
DO                   : 
DOUBLE               : 33
ELSE                 : 51
ENDIF                : 48
ENUM                 : 
EQ                   : 52
EXTERN               : 21
FLOAT                : 34
FLOAT_L              : 11
FOR                  : 66
GE                   : 57
GOTO                 : 
GT                   : 55
ID                   : 40 42 66 80 81 82 84 89 90 123 124
IF                   : 50
IFNDEF               : 47
INCLUDE              : 45
INCREMENT            : 66 118
INLINE               : 22
INT                  : 35
INT_L                : 12
LBRACE               : 67 68 69 80 81 89 90
LBRACK               : 85 86 126 127
LCOMMENT             : 
LE                   : 56
LONG                 : 23
LPAREN               : 19 66 67 80 81 82 83 84 97 98 137
LSHIFT               : 107
LT                   : 54
MEMBER               : 87
MINUS                : 100 102 104
NEGATE               : 99 101
NEQ                  : 53
NONDECIMAL_L         : 15
NUMBER               : 
OR                   : 59
PERCENT              : 109
PLUS                 : 103
RBRACE               : 67 68 69 80 81 89 90
RBRACK               : 85 86 126 127
REGISTER             : 
RESTRICT             : 
RETURN               : 119 120
RPAREN               : 19 66 67 80 81 82 83 84 97 98 137
RSHIFT               : 108
SEMI                 : 66 84 89 90 94 95 96 125 133 134 135 138
SHORT                : 24
SIGNED               : 25
SIMPLE_ASSIGN        : 16
SIZEOF               : 83
STATIC               : 
STRING_L             : 14
STRUCT               : 18 89 90
SWITCH               : 
TYPEDEF              : 90
UINT16_T             : 38
UINT8_T              : 37
UNION                : 
UNSIGNED             : 26
VOID                 : 36
VOLATILE             : 27
WHILE                : 49
_ALIGNAS             : 
_ALIGNOF             : 
_ATOMIC              : 
_BOOL                : 
_COMPLEX             : 
_GENERIC             : 
_IMAGERY             : 
_NORETURN            : 
_STATIC_ASSERT       : 
_THREAD_LOCAL        : 
error                : 138

Nonterminals, with rules where they appear

access               : 44
assign               : 130 131 140
assign_var           : 92
assign_var_ls        : 142
assign_var_rs        : 142
binop                : 117
complex_dtype        : 
conditional          : 60 61 62 63 112
conditional_expr     : 66 67
control              : 67 68
control_expr         : 9
declare_var          : 93
declare_var_ls       : 125 130 131
define               : 4
dtype                : 19 30 41 71 72 80 84 121 122 123 124
expression           : 60 61 62 62 65 74 86 94 97 99 100 114 120 135
for_loop             : 69
func_arg             : 78 79
func_arglist         : 78 79 80 81 82 83 84
func_call            : 75 76 95 116 134
func_decl            : 7
func_def             : 6
if                   : 5
include              : 3
init_var             : 66 91
init_var_ls          : 139
init_var_rs          : 132 139 141
literal              : 43
modified             : 
modifier             : 29 31 122 124
modifier_list        : 29 30
name                 : 18 60 61 63 63 64 70 71 73 85 85 86 87 87 88 98 101 102 113 115 118 119 127 133 137 140
node                 : 2
node_list            : 2 67 68 69 80 81 89 90 0
operand              : 117 117
return               : 96
statement            : 8
struct_def           : 10
struct_type          : 39
struct_typedef       : 
type_cast            : 73 74 76 115 132
typecast_init        : 136
vector_init          : 129 131
vector_init_list     : 129

Parsing method: LALR

state 0

    (0) S' -> . node_list
    (1) node_list -> .
    (2) node_list -> . node_list node

    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    SIZEOF          reduce using rule 1 (node_list -> .)
    RETURN          reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)
    BITAND          reduce using rule 1 (node_list -> .)
    $end            reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 1

state 1

    (0) S' -> node_list .
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (45) include -> . INCLUDE
    (46) define -> . DEFINE
    (47) if -> . IFNDEF
    (48) if -> . ENDIF
    (80) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (81) func_def -> . ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (84) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (91) statement -> . init_var
    (92) statement -> . assign_var
    (93) statement -> . declare_var
    (94) statement -> . expression SEMI
    (95) statement -> . func_call SEMI
    (96) statement -> . return SEMI
    (67) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (68) control_expr -> . control LBRACE node_list RBRACE
    (69) control_expr -> . for_loop LBRACE node_list RBRACE
    (89) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (139) init_var -> . init_var_ls init_var_rs
    (142) assign_var -> . assign_var_ls assign_var_rs
    (125) declare_var -> . declare_var_ls SEMI
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (119) return -> . RETURN name
    (120) return -> . RETURN expression
    (49) control -> . WHILE
    (50) control -> . IF
    (51) control -> . ELSE
    (66) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT name
    (130) init_var_ls -> . declare_var_ls assign
    (131) init_var_ls -> . declare_var_ls vector_init assign
    (140) assign_var_ls -> . name assign
    (123) declare_var_ls -> . dtype ID
    (124) declare_var_ls -> . modifier dtype ID
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (20) modifier -> . CONST
    (21) modifier -> . EXTERN
    (22) modifier -> . INLINE
    (23) modifier -> . LONG
    (24) modifier -> . SHORT
    (25) modifier -> . SIGNED
    (26) modifier -> . UNSIGNED
    (27) modifier -> . VOLATILE
    (19) type_cast -> . LPAREN dtype RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    ID              shift and go to state 16
    STRUCT          shift and go to state 26
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    SIZEOF          shift and go to state 42
    RETURN          shift and go to state 43
    WHILE           shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    FOR             shift and go to state 47
    CONST           shift and go to state 52
    EXTERN          shift and go to state 53
    INLINE          shift and go to state 54
    LONG            shift and go to state 55
    SHORT           shift and go to state 56
    SIGNED          shift and go to state 57
    UNSIGNED        shift and go to state 58
    VOLATILE        shift and go to state 59
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    dtype                          shift and go to state 15
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    return                         shift and go to state 23
    control                        shift and go to state 24
    for_loop                       shift and go to state 25
    struct_type                    shift and go to state 34
    init_var_ls                    shift and go to state 35
    assign_var_ls                  shift and go to state 36
    declare_var_ls                 shift and go to state 37
    name                           shift and go to state 38
    operand                        shift and go to state 41
    modifier                       shift and go to state 48
    type_cast                      shift and go to state 49
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 2

    (2) node_list -> node_list node .

    INCLUDE         reduce using rule 2 (node_list -> node_list node .)
    DEFINE          reduce using rule 2 (node_list -> node_list node .)
    IFNDEF          reduce using rule 2 (node_list -> node_list node .)
    ENDIF           reduce using rule 2 (node_list -> node_list node .)
    ID              reduce using rule 2 (node_list -> node_list node .)
    STRUCT          reduce using rule 2 (node_list -> node_list node .)
    CHAR            reduce using rule 2 (node_list -> node_list node .)
    DOUBLE          reduce using rule 2 (node_list -> node_list node .)
    FLOAT           reduce using rule 2 (node_list -> node_list node .)
    INT             reduce using rule 2 (node_list -> node_list node .)
    VOID            reduce using rule 2 (node_list -> node_list node .)
    UINT8_T         reduce using rule 2 (node_list -> node_list node .)
    UINT16_T        reduce using rule 2 (node_list -> node_list node .)
    LPAREN          reduce using rule 2 (node_list -> node_list node .)
    NEGATE          reduce using rule 2 (node_list -> node_list node .)
    MINUS           reduce using rule 2 (node_list -> node_list node .)
    SIZEOF          reduce using rule 2 (node_list -> node_list node .)
    RETURN          reduce using rule 2 (node_list -> node_list node .)
    WHILE           reduce using rule 2 (node_list -> node_list node .)
    IF              reduce using rule 2 (node_list -> node_list node .)
    ELSE            reduce using rule 2 (node_list -> node_list node .)
    FOR             reduce using rule 2 (node_list -> node_list node .)
    CONST           reduce using rule 2 (node_list -> node_list node .)
    EXTERN          reduce using rule 2 (node_list -> node_list node .)
    INLINE          reduce using rule 2 (node_list -> node_list node .)
    LONG            reduce using rule 2 (node_list -> node_list node .)
    SHORT           reduce using rule 2 (node_list -> node_list node .)
    SIGNED          reduce using rule 2 (node_list -> node_list node .)
    UNSIGNED        reduce using rule 2 (node_list -> node_list node .)
    VOLATILE        reduce using rule 2 (node_list -> node_list node .)
    FLOAT_L         reduce using rule 2 (node_list -> node_list node .)
    INT_L           reduce using rule 2 (node_list -> node_list node .)
    CHAR_L          reduce using rule 2 (node_list -> node_list node .)
    STRING_L        reduce using rule 2 (node_list -> node_list node .)
    NONDECIMAL_L    reduce using rule 2 (node_list -> node_list node .)
    BITAND          reduce using rule 2 (node_list -> node_list node .)
    $end            reduce using rule 2 (node_list -> node_list node .)
    RBRACE          reduce using rule 2 (node_list -> node_list node .)


state 3

    (3) node -> include .

    INCLUDE         reduce using rule 3 (node -> include .)
    DEFINE          reduce using rule 3 (node -> include .)
    IFNDEF          reduce using rule 3 (node -> include .)
    ENDIF           reduce using rule 3 (node -> include .)
    ID              reduce using rule 3 (node -> include .)
    STRUCT          reduce using rule 3 (node -> include .)
    CHAR            reduce using rule 3 (node -> include .)
    DOUBLE          reduce using rule 3 (node -> include .)
    FLOAT           reduce using rule 3 (node -> include .)
    INT             reduce using rule 3 (node -> include .)
    VOID            reduce using rule 3 (node -> include .)
    UINT8_T         reduce using rule 3 (node -> include .)
    UINT16_T        reduce using rule 3 (node -> include .)
    LPAREN          reduce using rule 3 (node -> include .)
    NEGATE          reduce using rule 3 (node -> include .)
    MINUS           reduce using rule 3 (node -> include .)
    SIZEOF          reduce using rule 3 (node -> include .)
    RETURN          reduce using rule 3 (node -> include .)
    WHILE           reduce using rule 3 (node -> include .)
    IF              reduce using rule 3 (node -> include .)
    ELSE            reduce using rule 3 (node -> include .)
    FOR             reduce using rule 3 (node -> include .)
    CONST           reduce using rule 3 (node -> include .)
    EXTERN          reduce using rule 3 (node -> include .)
    INLINE          reduce using rule 3 (node -> include .)
    LONG            reduce using rule 3 (node -> include .)
    SHORT           reduce using rule 3 (node -> include .)
    SIGNED          reduce using rule 3 (node -> include .)
    UNSIGNED        reduce using rule 3 (node -> include .)
    VOLATILE        reduce using rule 3 (node -> include .)
    FLOAT_L         reduce using rule 3 (node -> include .)
    INT_L           reduce using rule 3 (node -> include .)
    CHAR_L          reduce using rule 3 (node -> include .)
    STRING_L        reduce using rule 3 (node -> include .)
    NONDECIMAL_L    reduce using rule 3 (node -> include .)
    BITAND          reduce using rule 3 (node -> include .)
    $end            reduce using rule 3 (node -> include .)
    RBRACE          reduce using rule 3 (node -> include .)


state 4

    (4) node -> define .

    INCLUDE         reduce using rule 4 (node -> define .)
    DEFINE          reduce using rule 4 (node -> define .)
    IFNDEF          reduce using rule 4 (node -> define .)
    ENDIF           reduce using rule 4 (node -> define .)
    ID              reduce using rule 4 (node -> define .)
    STRUCT          reduce using rule 4 (node -> define .)
    CHAR            reduce using rule 4 (node -> define .)
    DOUBLE          reduce using rule 4 (node -> define .)
    FLOAT           reduce using rule 4 (node -> define .)
    INT             reduce using rule 4 (node -> define .)
    VOID            reduce using rule 4 (node -> define .)
    UINT8_T         reduce using rule 4 (node -> define .)
    UINT16_T        reduce using rule 4 (node -> define .)
    LPAREN          reduce using rule 4 (node -> define .)
    NEGATE          reduce using rule 4 (node -> define .)
    MINUS           reduce using rule 4 (node -> define .)
    SIZEOF          reduce using rule 4 (node -> define .)
    RETURN          reduce using rule 4 (node -> define .)
    WHILE           reduce using rule 4 (node -> define .)
    IF              reduce using rule 4 (node -> define .)
    ELSE            reduce using rule 4 (node -> define .)
    FOR             reduce using rule 4 (node -> define .)
    CONST           reduce using rule 4 (node -> define .)
    EXTERN          reduce using rule 4 (node -> define .)
    INLINE          reduce using rule 4 (node -> define .)
    LONG            reduce using rule 4 (node -> define .)
    SHORT           reduce using rule 4 (node -> define .)
    SIGNED          reduce using rule 4 (node -> define .)
    UNSIGNED        reduce using rule 4 (node -> define .)
    VOLATILE        reduce using rule 4 (node -> define .)
    FLOAT_L         reduce using rule 4 (node -> define .)
    INT_L           reduce using rule 4 (node -> define .)
    CHAR_L          reduce using rule 4 (node -> define .)
    STRING_L        reduce using rule 4 (node -> define .)
    NONDECIMAL_L    reduce using rule 4 (node -> define .)
    BITAND          reduce using rule 4 (node -> define .)
    $end            reduce using rule 4 (node -> define .)
    RBRACE          reduce using rule 4 (node -> define .)


state 5

    (5) node -> if .

    INCLUDE         reduce using rule 5 (node -> if .)
    DEFINE          reduce using rule 5 (node -> if .)
    IFNDEF          reduce using rule 5 (node -> if .)
    ENDIF           reduce using rule 5 (node -> if .)
    ID              reduce using rule 5 (node -> if .)
    STRUCT          reduce using rule 5 (node -> if .)
    CHAR            reduce using rule 5 (node -> if .)
    DOUBLE          reduce using rule 5 (node -> if .)
    FLOAT           reduce using rule 5 (node -> if .)
    INT             reduce using rule 5 (node -> if .)
    VOID            reduce using rule 5 (node -> if .)
    UINT8_T         reduce using rule 5 (node -> if .)
    UINT16_T        reduce using rule 5 (node -> if .)
    LPAREN          reduce using rule 5 (node -> if .)
    NEGATE          reduce using rule 5 (node -> if .)
    MINUS           reduce using rule 5 (node -> if .)
    SIZEOF          reduce using rule 5 (node -> if .)
    RETURN          reduce using rule 5 (node -> if .)
    WHILE           reduce using rule 5 (node -> if .)
    IF              reduce using rule 5 (node -> if .)
    ELSE            reduce using rule 5 (node -> if .)
    FOR             reduce using rule 5 (node -> if .)
    CONST           reduce using rule 5 (node -> if .)
    EXTERN          reduce using rule 5 (node -> if .)
    INLINE          reduce using rule 5 (node -> if .)
    LONG            reduce using rule 5 (node -> if .)
    SHORT           reduce using rule 5 (node -> if .)
    SIGNED          reduce using rule 5 (node -> if .)
    UNSIGNED        reduce using rule 5 (node -> if .)
    VOLATILE        reduce using rule 5 (node -> if .)
    FLOAT_L         reduce using rule 5 (node -> if .)
    INT_L           reduce using rule 5 (node -> if .)
    CHAR_L          reduce using rule 5 (node -> if .)
    STRING_L        reduce using rule 5 (node -> if .)
    NONDECIMAL_L    reduce using rule 5 (node -> if .)
    BITAND          reduce using rule 5 (node -> if .)
    $end            reduce using rule 5 (node -> if .)
    RBRACE          reduce using rule 5 (node -> if .)


state 6

    (6) node -> func_def .

    INCLUDE         reduce using rule 6 (node -> func_def .)
    DEFINE          reduce using rule 6 (node -> func_def .)
    IFNDEF          reduce using rule 6 (node -> func_def .)
    ENDIF           reduce using rule 6 (node -> func_def .)
    ID              reduce using rule 6 (node -> func_def .)
    STRUCT          reduce using rule 6 (node -> func_def .)
    CHAR            reduce using rule 6 (node -> func_def .)
    DOUBLE          reduce using rule 6 (node -> func_def .)
    FLOAT           reduce using rule 6 (node -> func_def .)
    INT             reduce using rule 6 (node -> func_def .)
    VOID            reduce using rule 6 (node -> func_def .)
    UINT8_T         reduce using rule 6 (node -> func_def .)
    UINT16_T        reduce using rule 6 (node -> func_def .)
    LPAREN          reduce using rule 6 (node -> func_def .)
    NEGATE          reduce using rule 6 (node -> func_def .)
    MINUS           reduce using rule 6 (node -> func_def .)
    SIZEOF          reduce using rule 6 (node -> func_def .)
    RETURN          reduce using rule 6 (node -> func_def .)
    WHILE           reduce using rule 6 (node -> func_def .)
    IF              reduce using rule 6 (node -> func_def .)
    ELSE            reduce using rule 6 (node -> func_def .)
    FOR             reduce using rule 6 (node -> func_def .)
    CONST           reduce using rule 6 (node -> func_def .)
    EXTERN          reduce using rule 6 (node -> func_def .)
    INLINE          reduce using rule 6 (node -> func_def .)
    LONG            reduce using rule 6 (node -> func_def .)
    SHORT           reduce using rule 6 (node -> func_def .)
    SIGNED          reduce using rule 6 (node -> func_def .)
    UNSIGNED        reduce using rule 6 (node -> func_def .)
    VOLATILE        reduce using rule 6 (node -> func_def .)
    FLOAT_L         reduce using rule 6 (node -> func_def .)
    INT_L           reduce using rule 6 (node -> func_def .)
    CHAR_L          reduce using rule 6 (node -> func_def .)
    STRING_L        reduce using rule 6 (node -> func_def .)
    NONDECIMAL_L    reduce using rule 6 (node -> func_def .)
    BITAND          reduce using rule 6 (node -> func_def .)
    $end            reduce using rule 6 (node -> func_def .)
    RBRACE          reduce using rule 6 (node -> func_def .)


state 7

    (7) node -> func_decl .

    INCLUDE         reduce using rule 7 (node -> func_decl .)
    DEFINE          reduce using rule 7 (node -> func_decl .)
    IFNDEF          reduce using rule 7 (node -> func_decl .)
    ENDIF           reduce using rule 7 (node -> func_decl .)
    ID              reduce using rule 7 (node -> func_decl .)
    STRUCT          reduce using rule 7 (node -> func_decl .)
    CHAR            reduce using rule 7 (node -> func_decl .)
    DOUBLE          reduce using rule 7 (node -> func_decl .)
    FLOAT           reduce using rule 7 (node -> func_decl .)
    INT             reduce using rule 7 (node -> func_decl .)
    VOID            reduce using rule 7 (node -> func_decl .)
    UINT8_T         reduce using rule 7 (node -> func_decl .)
    UINT16_T        reduce using rule 7 (node -> func_decl .)
    LPAREN          reduce using rule 7 (node -> func_decl .)
    NEGATE          reduce using rule 7 (node -> func_decl .)
    MINUS           reduce using rule 7 (node -> func_decl .)
    SIZEOF          reduce using rule 7 (node -> func_decl .)
    RETURN          reduce using rule 7 (node -> func_decl .)
    WHILE           reduce using rule 7 (node -> func_decl .)
    IF              reduce using rule 7 (node -> func_decl .)
    ELSE            reduce using rule 7 (node -> func_decl .)
    FOR             reduce using rule 7 (node -> func_decl .)
    CONST           reduce using rule 7 (node -> func_decl .)
    EXTERN          reduce using rule 7 (node -> func_decl .)
    INLINE          reduce using rule 7 (node -> func_decl .)
    LONG            reduce using rule 7 (node -> func_decl .)
    SHORT           reduce using rule 7 (node -> func_decl .)
    SIGNED          reduce using rule 7 (node -> func_decl .)
    UNSIGNED        reduce using rule 7 (node -> func_decl .)
    VOLATILE        reduce using rule 7 (node -> func_decl .)
    FLOAT_L         reduce using rule 7 (node -> func_decl .)
    INT_L           reduce using rule 7 (node -> func_decl .)
    CHAR_L          reduce using rule 7 (node -> func_decl .)
    STRING_L        reduce using rule 7 (node -> func_decl .)
    NONDECIMAL_L    reduce using rule 7 (node -> func_decl .)
    BITAND          reduce using rule 7 (node -> func_decl .)
    $end            reduce using rule 7 (node -> func_decl .)
    RBRACE          reduce using rule 7 (node -> func_decl .)


state 8

    (8) node -> statement .

    INCLUDE         reduce using rule 8 (node -> statement .)
    DEFINE          reduce using rule 8 (node -> statement .)
    IFNDEF          reduce using rule 8 (node -> statement .)
    ENDIF           reduce using rule 8 (node -> statement .)
    ID              reduce using rule 8 (node -> statement .)
    STRUCT          reduce using rule 8 (node -> statement .)
    CHAR            reduce using rule 8 (node -> statement .)
    DOUBLE          reduce using rule 8 (node -> statement .)
    FLOAT           reduce using rule 8 (node -> statement .)
    INT             reduce using rule 8 (node -> statement .)
    VOID            reduce using rule 8 (node -> statement .)
    UINT8_T         reduce using rule 8 (node -> statement .)
    UINT16_T        reduce using rule 8 (node -> statement .)
    LPAREN          reduce using rule 8 (node -> statement .)
    NEGATE          reduce using rule 8 (node -> statement .)
    MINUS           reduce using rule 8 (node -> statement .)
    SIZEOF          reduce using rule 8 (node -> statement .)
    RETURN          reduce using rule 8 (node -> statement .)
    WHILE           reduce using rule 8 (node -> statement .)
    IF              reduce using rule 8 (node -> statement .)
    ELSE            reduce using rule 8 (node -> statement .)
    FOR             reduce using rule 8 (node -> statement .)
    CONST           reduce using rule 8 (node -> statement .)
    EXTERN          reduce using rule 8 (node -> statement .)
    INLINE          reduce using rule 8 (node -> statement .)
    LONG            reduce using rule 8 (node -> statement .)
    SHORT           reduce using rule 8 (node -> statement .)
    SIGNED          reduce using rule 8 (node -> statement .)
    UNSIGNED        reduce using rule 8 (node -> statement .)
    VOLATILE        reduce using rule 8 (node -> statement .)
    FLOAT_L         reduce using rule 8 (node -> statement .)
    INT_L           reduce using rule 8 (node -> statement .)
    CHAR_L          reduce using rule 8 (node -> statement .)
    STRING_L        reduce using rule 8 (node -> statement .)
    NONDECIMAL_L    reduce using rule 8 (node -> statement .)
    BITAND          reduce using rule 8 (node -> statement .)
    $end            reduce using rule 8 (node -> statement .)
    RBRACE          reduce using rule 8 (node -> statement .)


state 9

    (9) node -> control_expr .

    INCLUDE         reduce using rule 9 (node -> control_expr .)
    DEFINE          reduce using rule 9 (node -> control_expr .)
    IFNDEF          reduce using rule 9 (node -> control_expr .)
    ENDIF           reduce using rule 9 (node -> control_expr .)
    ID              reduce using rule 9 (node -> control_expr .)
    STRUCT          reduce using rule 9 (node -> control_expr .)
    CHAR            reduce using rule 9 (node -> control_expr .)
    DOUBLE          reduce using rule 9 (node -> control_expr .)
    FLOAT           reduce using rule 9 (node -> control_expr .)
    INT             reduce using rule 9 (node -> control_expr .)
    VOID            reduce using rule 9 (node -> control_expr .)
    UINT8_T         reduce using rule 9 (node -> control_expr .)
    UINT16_T        reduce using rule 9 (node -> control_expr .)
    LPAREN          reduce using rule 9 (node -> control_expr .)
    NEGATE          reduce using rule 9 (node -> control_expr .)
    MINUS           reduce using rule 9 (node -> control_expr .)
    SIZEOF          reduce using rule 9 (node -> control_expr .)
    RETURN          reduce using rule 9 (node -> control_expr .)
    WHILE           reduce using rule 9 (node -> control_expr .)
    IF              reduce using rule 9 (node -> control_expr .)
    ELSE            reduce using rule 9 (node -> control_expr .)
    FOR             reduce using rule 9 (node -> control_expr .)
    CONST           reduce using rule 9 (node -> control_expr .)
    EXTERN          reduce using rule 9 (node -> control_expr .)
    INLINE          reduce using rule 9 (node -> control_expr .)
    LONG            reduce using rule 9 (node -> control_expr .)
    SHORT           reduce using rule 9 (node -> control_expr .)
    SIGNED          reduce using rule 9 (node -> control_expr .)
    UNSIGNED        reduce using rule 9 (node -> control_expr .)
    VOLATILE        reduce using rule 9 (node -> control_expr .)
    FLOAT_L         reduce using rule 9 (node -> control_expr .)
    INT_L           reduce using rule 9 (node -> control_expr .)
    CHAR_L          reduce using rule 9 (node -> control_expr .)
    STRING_L        reduce using rule 9 (node -> control_expr .)
    NONDECIMAL_L    reduce using rule 9 (node -> control_expr .)
    BITAND          reduce using rule 9 (node -> control_expr .)
    $end            reduce using rule 9 (node -> control_expr .)
    RBRACE          reduce using rule 9 (node -> control_expr .)


state 10

    (10) node -> struct_def .

    INCLUDE         reduce using rule 10 (node -> struct_def .)
    DEFINE          reduce using rule 10 (node -> struct_def .)
    IFNDEF          reduce using rule 10 (node -> struct_def .)
    ENDIF           reduce using rule 10 (node -> struct_def .)
    ID              reduce using rule 10 (node -> struct_def .)
    STRUCT          reduce using rule 10 (node -> struct_def .)
    CHAR            reduce using rule 10 (node -> struct_def .)
    DOUBLE          reduce using rule 10 (node -> struct_def .)
    FLOAT           reduce using rule 10 (node -> struct_def .)
    INT             reduce using rule 10 (node -> struct_def .)
    VOID            reduce using rule 10 (node -> struct_def .)
    UINT8_T         reduce using rule 10 (node -> struct_def .)
    UINT16_T        reduce using rule 10 (node -> struct_def .)
    LPAREN          reduce using rule 10 (node -> struct_def .)
    NEGATE          reduce using rule 10 (node -> struct_def .)
    MINUS           reduce using rule 10 (node -> struct_def .)
    SIZEOF          reduce using rule 10 (node -> struct_def .)
    RETURN          reduce using rule 10 (node -> struct_def .)
    WHILE           reduce using rule 10 (node -> struct_def .)
    IF              reduce using rule 10 (node -> struct_def .)
    ELSE            reduce using rule 10 (node -> struct_def .)
    FOR             reduce using rule 10 (node -> struct_def .)
    CONST           reduce using rule 10 (node -> struct_def .)
    EXTERN          reduce using rule 10 (node -> struct_def .)
    INLINE          reduce using rule 10 (node -> struct_def .)
    LONG            reduce using rule 10 (node -> struct_def .)
    SHORT           reduce using rule 10 (node -> struct_def .)
    SIGNED          reduce using rule 10 (node -> struct_def .)
    UNSIGNED        reduce using rule 10 (node -> struct_def .)
    VOLATILE        reduce using rule 10 (node -> struct_def .)
    FLOAT_L         reduce using rule 10 (node -> struct_def .)
    INT_L           reduce using rule 10 (node -> struct_def .)
    CHAR_L          reduce using rule 10 (node -> struct_def .)
    STRING_L        reduce using rule 10 (node -> struct_def .)
    NONDECIMAL_L    reduce using rule 10 (node -> struct_def .)
    BITAND          reduce using rule 10 (node -> struct_def .)
    $end            reduce using rule 10 (node -> struct_def .)
    RBRACE          reduce using rule 10 (node -> struct_def .)


state 11

    (45) include -> INCLUDE .

    INCLUDE         reduce using rule 45 (include -> INCLUDE .)
    DEFINE          reduce using rule 45 (include -> INCLUDE .)
    IFNDEF          reduce using rule 45 (include -> INCLUDE .)
    ENDIF           reduce using rule 45 (include -> INCLUDE .)
    ID              reduce using rule 45 (include -> INCLUDE .)
    STRUCT          reduce using rule 45 (include -> INCLUDE .)
    CHAR            reduce using rule 45 (include -> INCLUDE .)
    DOUBLE          reduce using rule 45 (include -> INCLUDE .)
    FLOAT           reduce using rule 45 (include -> INCLUDE .)
    INT             reduce using rule 45 (include -> INCLUDE .)
    VOID            reduce using rule 45 (include -> INCLUDE .)
    UINT8_T         reduce using rule 45 (include -> INCLUDE .)
    UINT16_T        reduce using rule 45 (include -> INCLUDE .)
    LPAREN          reduce using rule 45 (include -> INCLUDE .)
    NEGATE          reduce using rule 45 (include -> INCLUDE .)
    MINUS           reduce using rule 45 (include -> INCLUDE .)
    SIZEOF          reduce using rule 45 (include -> INCLUDE .)
    RETURN          reduce using rule 45 (include -> INCLUDE .)
    WHILE           reduce using rule 45 (include -> INCLUDE .)
    IF              reduce using rule 45 (include -> INCLUDE .)
    ELSE            reduce using rule 45 (include -> INCLUDE .)
    FOR             reduce using rule 45 (include -> INCLUDE .)
    CONST           reduce using rule 45 (include -> INCLUDE .)
    EXTERN          reduce using rule 45 (include -> INCLUDE .)
    INLINE          reduce using rule 45 (include -> INCLUDE .)
    LONG            reduce using rule 45 (include -> INCLUDE .)
    SHORT           reduce using rule 45 (include -> INCLUDE .)
    SIGNED          reduce using rule 45 (include -> INCLUDE .)
    UNSIGNED        reduce using rule 45 (include -> INCLUDE .)
    VOLATILE        reduce using rule 45 (include -> INCLUDE .)
    FLOAT_L         reduce using rule 45 (include -> INCLUDE .)
    INT_L           reduce using rule 45 (include -> INCLUDE .)
    CHAR_L          reduce using rule 45 (include -> INCLUDE .)
    STRING_L        reduce using rule 45 (include -> INCLUDE .)
    NONDECIMAL_L    reduce using rule 45 (include -> INCLUDE .)
    BITAND          reduce using rule 45 (include -> INCLUDE .)
    $end            reduce using rule 45 (include -> INCLUDE .)
    RBRACE          reduce using rule 45 (include -> INCLUDE .)


state 12

    (46) define -> DEFINE .

    INCLUDE         reduce using rule 46 (define -> DEFINE .)
    DEFINE          reduce using rule 46 (define -> DEFINE .)
    IFNDEF          reduce using rule 46 (define -> DEFINE .)
    ENDIF           reduce using rule 46 (define -> DEFINE .)
    ID              reduce using rule 46 (define -> DEFINE .)
    STRUCT          reduce using rule 46 (define -> DEFINE .)
    CHAR            reduce using rule 46 (define -> DEFINE .)
    DOUBLE          reduce using rule 46 (define -> DEFINE .)
    FLOAT           reduce using rule 46 (define -> DEFINE .)
    INT             reduce using rule 46 (define -> DEFINE .)
    VOID            reduce using rule 46 (define -> DEFINE .)
    UINT8_T         reduce using rule 46 (define -> DEFINE .)
    UINT16_T        reduce using rule 46 (define -> DEFINE .)
    LPAREN          reduce using rule 46 (define -> DEFINE .)
    NEGATE          reduce using rule 46 (define -> DEFINE .)
    MINUS           reduce using rule 46 (define -> DEFINE .)
    SIZEOF          reduce using rule 46 (define -> DEFINE .)
    RETURN          reduce using rule 46 (define -> DEFINE .)
    WHILE           reduce using rule 46 (define -> DEFINE .)
    IF              reduce using rule 46 (define -> DEFINE .)
    ELSE            reduce using rule 46 (define -> DEFINE .)
    FOR             reduce using rule 46 (define -> DEFINE .)
    CONST           reduce using rule 46 (define -> DEFINE .)
    EXTERN          reduce using rule 46 (define -> DEFINE .)
    INLINE          reduce using rule 46 (define -> DEFINE .)
    LONG            reduce using rule 46 (define -> DEFINE .)
    SHORT           reduce using rule 46 (define -> DEFINE .)
    SIGNED          reduce using rule 46 (define -> DEFINE .)
    UNSIGNED        reduce using rule 46 (define -> DEFINE .)
    VOLATILE        reduce using rule 46 (define -> DEFINE .)
    FLOAT_L         reduce using rule 46 (define -> DEFINE .)
    INT_L           reduce using rule 46 (define -> DEFINE .)
    CHAR_L          reduce using rule 46 (define -> DEFINE .)
    STRING_L        reduce using rule 46 (define -> DEFINE .)
    NONDECIMAL_L    reduce using rule 46 (define -> DEFINE .)
    BITAND          reduce using rule 46 (define -> DEFINE .)
    $end            reduce using rule 46 (define -> DEFINE .)
    RBRACE          reduce using rule 46 (define -> DEFINE .)


state 13

    (47) if -> IFNDEF .

    INCLUDE         reduce using rule 47 (if -> IFNDEF .)
    DEFINE          reduce using rule 47 (if -> IFNDEF .)
    IFNDEF          reduce using rule 47 (if -> IFNDEF .)
    ENDIF           reduce using rule 47 (if -> IFNDEF .)
    ID              reduce using rule 47 (if -> IFNDEF .)
    STRUCT          reduce using rule 47 (if -> IFNDEF .)
    CHAR            reduce using rule 47 (if -> IFNDEF .)
    DOUBLE          reduce using rule 47 (if -> IFNDEF .)
    FLOAT           reduce using rule 47 (if -> IFNDEF .)
    INT             reduce using rule 47 (if -> IFNDEF .)
    VOID            reduce using rule 47 (if -> IFNDEF .)
    UINT8_T         reduce using rule 47 (if -> IFNDEF .)
    UINT16_T        reduce using rule 47 (if -> IFNDEF .)
    LPAREN          reduce using rule 47 (if -> IFNDEF .)
    NEGATE          reduce using rule 47 (if -> IFNDEF .)
    MINUS           reduce using rule 47 (if -> IFNDEF .)
    SIZEOF          reduce using rule 47 (if -> IFNDEF .)
    RETURN          reduce using rule 47 (if -> IFNDEF .)
    WHILE           reduce using rule 47 (if -> IFNDEF .)
    IF              reduce using rule 47 (if -> IFNDEF .)
    ELSE            reduce using rule 47 (if -> IFNDEF .)
    FOR             reduce using rule 47 (if -> IFNDEF .)
    CONST           reduce using rule 47 (if -> IFNDEF .)
    EXTERN          reduce using rule 47 (if -> IFNDEF .)
    INLINE          reduce using rule 47 (if -> IFNDEF .)
    LONG            reduce using rule 47 (if -> IFNDEF .)
    SHORT           reduce using rule 47 (if -> IFNDEF .)
    SIGNED          reduce using rule 47 (if -> IFNDEF .)
    UNSIGNED        reduce using rule 47 (if -> IFNDEF .)
    VOLATILE        reduce using rule 47 (if -> IFNDEF .)
    FLOAT_L         reduce using rule 47 (if -> IFNDEF .)
    INT_L           reduce using rule 47 (if -> IFNDEF .)
    CHAR_L          reduce using rule 47 (if -> IFNDEF .)
    STRING_L        reduce using rule 47 (if -> IFNDEF .)
    NONDECIMAL_L    reduce using rule 47 (if -> IFNDEF .)
    BITAND          reduce using rule 47 (if -> IFNDEF .)
    $end            reduce using rule 47 (if -> IFNDEF .)
    RBRACE          reduce using rule 47 (if -> IFNDEF .)


state 14

    (48) if -> ENDIF .

    INCLUDE         reduce using rule 48 (if -> ENDIF .)
    DEFINE          reduce using rule 48 (if -> ENDIF .)
    IFNDEF          reduce using rule 48 (if -> ENDIF .)
    ENDIF           reduce using rule 48 (if -> ENDIF .)
    ID              reduce using rule 48 (if -> ENDIF .)
    STRUCT          reduce using rule 48 (if -> ENDIF .)
    CHAR            reduce using rule 48 (if -> ENDIF .)
    DOUBLE          reduce using rule 48 (if -> ENDIF .)
    FLOAT           reduce using rule 48 (if -> ENDIF .)
    INT             reduce using rule 48 (if -> ENDIF .)
    VOID            reduce using rule 48 (if -> ENDIF .)
    UINT8_T         reduce using rule 48 (if -> ENDIF .)
    UINT16_T        reduce using rule 48 (if -> ENDIF .)
    LPAREN          reduce using rule 48 (if -> ENDIF .)
    NEGATE          reduce using rule 48 (if -> ENDIF .)
    MINUS           reduce using rule 48 (if -> ENDIF .)
    SIZEOF          reduce using rule 48 (if -> ENDIF .)
    RETURN          reduce using rule 48 (if -> ENDIF .)
    WHILE           reduce using rule 48 (if -> ENDIF .)
    IF              reduce using rule 48 (if -> ENDIF .)
    ELSE            reduce using rule 48 (if -> ENDIF .)
    FOR             reduce using rule 48 (if -> ENDIF .)
    CONST           reduce using rule 48 (if -> ENDIF .)
    EXTERN          reduce using rule 48 (if -> ENDIF .)
    INLINE          reduce using rule 48 (if -> ENDIF .)
    LONG            reduce using rule 48 (if -> ENDIF .)
    SHORT           reduce using rule 48 (if -> ENDIF .)
    SIGNED          reduce using rule 48 (if -> ENDIF .)
    UNSIGNED        reduce using rule 48 (if -> ENDIF .)
    VOLATILE        reduce using rule 48 (if -> ENDIF .)
    FLOAT_L         reduce using rule 48 (if -> ENDIF .)
    INT_L           reduce using rule 48 (if -> ENDIF .)
    CHAR_L          reduce using rule 48 (if -> ENDIF .)
    STRING_L        reduce using rule 48 (if -> ENDIF .)
    NONDECIMAL_L    reduce using rule 48 (if -> ENDIF .)
    BITAND          reduce using rule 48 (if -> ENDIF .)
    $end            reduce using rule 48 (if -> ENDIF .)
    RBRACE          reduce using rule 48 (if -> ENDIF .)


state 15

    (80) func_def -> dtype . ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (84) func_decl -> dtype . ID LPAREN func_arglist RPAREN SEMI
    (41) dtype -> dtype . ASTERISK
    (123) declare_var_ls -> dtype . ID

    ID              shift and go to state 66
    ASTERISK        shift and go to state 67


state 16

    (81) func_def -> ID . LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (40) dtype -> ID .
    (82) func_call -> ID . LPAREN func_arglist RPAREN
    (42) name -> ID .

  ! reduce/reduce conflict for ASTERISK resolved using rule 40 (dtype -> ID .)
    LPAREN          shift and go to state 68
    ID              reduce using rule 40 (dtype -> ID .)
    ASTERISK        reduce using rule 40 (dtype -> ID .)
    INCREMENT       reduce using rule 42 (name -> ID .)
    LBRACK          reduce using rule 42 (name -> ID .)
    MEMBER          reduce using rule 42 (name -> ID .)
    SIMPLE_ASSIGN   reduce using rule 42 (name -> ID .)
    COMPLEX_ASSIGN  reduce using rule 42 (name -> ID .)
    PLUS            reduce using rule 42 (name -> ID .)
    MINUS           reduce using rule 42 (name -> ID .)
    DIVIDE          reduce using rule 42 (name -> ID .)
    LSHIFT          reduce using rule 42 (name -> ID .)
    RSHIFT          reduce using rule 42 (name -> ID .)
    PERCENT         reduce using rule 42 (name -> ID .)
    BITAND          reduce using rule 42 (name -> ID .)
    BITOR           reduce using rule 42 (name -> ID .)
    EQ              reduce using rule 42 (name -> ID .)
    NEQ             reduce using rule 42 (name -> ID .)
    LT              reduce using rule 42 (name -> ID .)
    GT              reduce using rule 42 (name -> ID .)
    LE              reduce using rule 42 (name -> ID .)
    GE              reduce using rule 42 (name -> ID .)
    AND             reduce using rule 42 (name -> ID .)
    OR              reduce using rule 42 (name -> ID .)

  ! ASTERISK        [ reduce using rule 42 (name -> ID .) ]


state 17

    (97) expression -> LPAREN . expression RPAREN
    (98) expression -> LPAREN . name RPAREN
    (19) type_cast -> LPAREN . dtype RPAREN
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (18) struct_type -> . STRUCT name
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN

    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    ID              shift and go to state 72
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    STRUCT          shift and go to state 74
    SIZEOF          shift and go to state 42

    expression                     shift and go to state 69
    name                           shift and go to state 70
    dtype                          shift and go to state 71
    operand                        shift and go to state 41
    literal                        shift and go to state 50
    access                         shift and go to state 51
    struct_type                    shift and go to state 34
    type_cast                      shift and go to state 49
    func_call                      shift and go to state 73

state 18

    (91) statement -> init_var .

    INCLUDE         reduce using rule 91 (statement -> init_var .)
    DEFINE          reduce using rule 91 (statement -> init_var .)
    IFNDEF          reduce using rule 91 (statement -> init_var .)
    ENDIF           reduce using rule 91 (statement -> init_var .)
    ID              reduce using rule 91 (statement -> init_var .)
    STRUCT          reduce using rule 91 (statement -> init_var .)
    CHAR            reduce using rule 91 (statement -> init_var .)
    DOUBLE          reduce using rule 91 (statement -> init_var .)
    FLOAT           reduce using rule 91 (statement -> init_var .)
    INT             reduce using rule 91 (statement -> init_var .)
    VOID            reduce using rule 91 (statement -> init_var .)
    UINT8_T         reduce using rule 91 (statement -> init_var .)
    UINT16_T        reduce using rule 91 (statement -> init_var .)
    LPAREN          reduce using rule 91 (statement -> init_var .)
    NEGATE          reduce using rule 91 (statement -> init_var .)
    MINUS           reduce using rule 91 (statement -> init_var .)
    SIZEOF          reduce using rule 91 (statement -> init_var .)
    RETURN          reduce using rule 91 (statement -> init_var .)
    WHILE           reduce using rule 91 (statement -> init_var .)
    IF              reduce using rule 91 (statement -> init_var .)
    ELSE            reduce using rule 91 (statement -> init_var .)
    FOR             reduce using rule 91 (statement -> init_var .)
    CONST           reduce using rule 91 (statement -> init_var .)
    EXTERN          reduce using rule 91 (statement -> init_var .)
    INLINE          reduce using rule 91 (statement -> init_var .)
    LONG            reduce using rule 91 (statement -> init_var .)
    SHORT           reduce using rule 91 (statement -> init_var .)
    SIGNED          reduce using rule 91 (statement -> init_var .)
    UNSIGNED        reduce using rule 91 (statement -> init_var .)
    VOLATILE        reduce using rule 91 (statement -> init_var .)
    FLOAT_L         reduce using rule 91 (statement -> init_var .)
    INT_L           reduce using rule 91 (statement -> init_var .)
    CHAR_L          reduce using rule 91 (statement -> init_var .)
    STRING_L        reduce using rule 91 (statement -> init_var .)
    NONDECIMAL_L    reduce using rule 91 (statement -> init_var .)
    BITAND          reduce using rule 91 (statement -> init_var .)
    $end            reduce using rule 91 (statement -> init_var .)
    RBRACE          reduce using rule 91 (statement -> init_var .)


state 19

    (92) statement -> assign_var .

    INCLUDE         reduce using rule 92 (statement -> assign_var .)
    DEFINE          reduce using rule 92 (statement -> assign_var .)
    IFNDEF          reduce using rule 92 (statement -> assign_var .)
    ENDIF           reduce using rule 92 (statement -> assign_var .)
    ID              reduce using rule 92 (statement -> assign_var .)
    STRUCT          reduce using rule 92 (statement -> assign_var .)
    CHAR            reduce using rule 92 (statement -> assign_var .)
    DOUBLE          reduce using rule 92 (statement -> assign_var .)
    FLOAT           reduce using rule 92 (statement -> assign_var .)
    INT             reduce using rule 92 (statement -> assign_var .)
    VOID            reduce using rule 92 (statement -> assign_var .)
    UINT8_T         reduce using rule 92 (statement -> assign_var .)
    UINT16_T        reduce using rule 92 (statement -> assign_var .)
    LPAREN          reduce using rule 92 (statement -> assign_var .)
    NEGATE          reduce using rule 92 (statement -> assign_var .)
    MINUS           reduce using rule 92 (statement -> assign_var .)
    SIZEOF          reduce using rule 92 (statement -> assign_var .)
    RETURN          reduce using rule 92 (statement -> assign_var .)
    WHILE           reduce using rule 92 (statement -> assign_var .)
    IF              reduce using rule 92 (statement -> assign_var .)
    ELSE            reduce using rule 92 (statement -> assign_var .)
    FOR             reduce using rule 92 (statement -> assign_var .)
    CONST           reduce using rule 92 (statement -> assign_var .)
    EXTERN          reduce using rule 92 (statement -> assign_var .)
    INLINE          reduce using rule 92 (statement -> assign_var .)
    LONG            reduce using rule 92 (statement -> assign_var .)
    SHORT           reduce using rule 92 (statement -> assign_var .)
    SIGNED          reduce using rule 92 (statement -> assign_var .)
    UNSIGNED        reduce using rule 92 (statement -> assign_var .)
    VOLATILE        reduce using rule 92 (statement -> assign_var .)
    FLOAT_L         reduce using rule 92 (statement -> assign_var .)
    INT_L           reduce using rule 92 (statement -> assign_var .)
    CHAR_L          reduce using rule 92 (statement -> assign_var .)
    STRING_L        reduce using rule 92 (statement -> assign_var .)
    NONDECIMAL_L    reduce using rule 92 (statement -> assign_var .)
    BITAND          reduce using rule 92 (statement -> assign_var .)
    $end            reduce using rule 92 (statement -> assign_var .)
    RBRACE          reduce using rule 92 (statement -> assign_var .)


state 20

    (93) statement -> declare_var .

    INCLUDE         reduce using rule 93 (statement -> declare_var .)
    DEFINE          reduce using rule 93 (statement -> declare_var .)
    IFNDEF          reduce using rule 93 (statement -> declare_var .)
    ENDIF           reduce using rule 93 (statement -> declare_var .)
    ID              reduce using rule 93 (statement -> declare_var .)
    STRUCT          reduce using rule 93 (statement -> declare_var .)
    CHAR            reduce using rule 93 (statement -> declare_var .)
    DOUBLE          reduce using rule 93 (statement -> declare_var .)
    FLOAT           reduce using rule 93 (statement -> declare_var .)
    INT             reduce using rule 93 (statement -> declare_var .)
    VOID            reduce using rule 93 (statement -> declare_var .)
    UINT8_T         reduce using rule 93 (statement -> declare_var .)
    UINT16_T        reduce using rule 93 (statement -> declare_var .)
    LPAREN          reduce using rule 93 (statement -> declare_var .)
    NEGATE          reduce using rule 93 (statement -> declare_var .)
    MINUS           reduce using rule 93 (statement -> declare_var .)
    SIZEOF          reduce using rule 93 (statement -> declare_var .)
    RETURN          reduce using rule 93 (statement -> declare_var .)
    WHILE           reduce using rule 93 (statement -> declare_var .)
    IF              reduce using rule 93 (statement -> declare_var .)
    ELSE            reduce using rule 93 (statement -> declare_var .)
    FOR             reduce using rule 93 (statement -> declare_var .)
    CONST           reduce using rule 93 (statement -> declare_var .)
    EXTERN          reduce using rule 93 (statement -> declare_var .)
    INLINE          reduce using rule 93 (statement -> declare_var .)
    LONG            reduce using rule 93 (statement -> declare_var .)
    SHORT           reduce using rule 93 (statement -> declare_var .)
    SIGNED          reduce using rule 93 (statement -> declare_var .)
    UNSIGNED        reduce using rule 93 (statement -> declare_var .)
    VOLATILE        reduce using rule 93 (statement -> declare_var .)
    FLOAT_L         reduce using rule 93 (statement -> declare_var .)
    INT_L           reduce using rule 93 (statement -> declare_var .)
    CHAR_L          reduce using rule 93 (statement -> declare_var .)
    STRING_L        reduce using rule 93 (statement -> declare_var .)
    NONDECIMAL_L    reduce using rule 93 (statement -> declare_var .)
    BITAND          reduce using rule 93 (statement -> declare_var .)
    $end            reduce using rule 93 (statement -> declare_var .)
    RBRACE          reduce using rule 93 (statement -> declare_var .)


state 21

    (94) statement -> expression . SEMI
    (114) operand -> expression .

    SEMI            shift and go to state 75
    PLUS            reduce using rule 114 (operand -> expression .)
    MINUS           reduce using rule 114 (operand -> expression .)
    ASTERISK        reduce using rule 114 (operand -> expression .)
    DIVIDE          reduce using rule 114 (operand -> expression .)
    LSHIFT          reduce using rule 114 (operand -> expression .)
    RSHIFT          reduce using rule 114 (operand -> expression .)
    PERCENT         reduce using rule 114 (operand -> expression .)
    BITAND          reduce using rule 114 (operand -> expression .)
    BITOR           reduce using rule 114 (operand -> expression .)
    EQ              reduce using rule 114 (operand -> expression .)
    NEQ             reduce using rule 114 (operand -> expression .)
    LT              reduce using rule 114 (operand -> expression .)
    GT              reduce using rule 114 (operand -> expression .)
    LE              reduce using rule 114 (operand -> expression .)
    GE              reduce using rule 114 (operand -> expression .)
    AND             reduce using rule 114 (operand -> expression .)
    OR              reduce using rule 114 (operand -> expression .)


state 22

    (95) statement -> func_call . SEMI
    (116) operand -> func_call .

    SEMI            shift and go to state 76
    PLUS            reduce using rule 116 (operand -> func_call .)
    MINUS           reduce using rule 116 (operand -> func_call .)
    ASTERISK        reduce using rule 116 (operand -> func_call .)
    DIVIDE          reduce using rule 116 (operand -> func_call .)
    LSHIFT          reduce using rule 116 (operand -> func_call .)
    RSHIFT          reduce using rule 116 (operand -> func_call .)
    PERCENT         reduce using rule 116 (operand -> func_call .)
    BITAND          reduce using rule 116 (operand -> func_call .)
    BITOR           reduce using rule 116 (operand -> func_call .)
    EQ              reduce using rule 116 (operand -> func_call .)
    NEQ             reduce using rule 116 (operand -> func_call .)
    LT              reduce using rule 116 (operand -> func_call .)
    GT              reduce using rule 116 (operand -> func_call .)
    LE              reduce using rule 116 (operand -> func_call .)
    GE              reduce using rule 116 (operand -> func_call .)
    AND             reduce using rule 116 (operand -> func_call .)
    OR              reduce using rule 116 (operand -> func_call .)


state 23

    (96) statement -> return . SEMI

    SEMI            shift and go to state 77


state 24

    (67) control_expr -> control . LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (68) control_expr -> control . LBRACE node_list RBRACE

    LPAREN          shift and go to state 78
    LBRACE          shift and go to state 79


state 25

    (69) control_expr -> for_loop . LBRACE node_list RBRACE

    LBRACE          shift and go to state 80


state 26

    (89) struct_def -> STRUCT . ID LBRACE node_list RBRACE SEMI
    (18) struct_type -> STRUCT . name
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    ID              shift and go to state 81
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    name                           shift and go to state 82
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 27

    (32) dtype -> CHAR .

    ID              reduce using rule 32 (dtype -> CHAR .)
    ASTERISK        reduce using rule 32 (dtype -> CHAR .)
    RPAREN          reduce using rule 32 (dtype -> CHAR .)
    FLOAT_L         reduce using rule 32 (dtype -> CHAR .)
    INT_L           reduce using rule 32 (dtype -> CHAR .)
    CHAR_L          reduce using rule 32 (dtype -> CHAR .)
    STRING_L        reduce using rule 32 (dtype -> CHAR .)
    NONDECIMAL_L    reduce using rule 32 (dtype -> CHAR .)
    BITAND          reduce using rule 32 (dtype -> CHAR .)
    COMMA           reduce using rule 32 (dtype -> CHAR .)
    CHAR            reduce using rule 32 (dtype -> CHAR .)
    DOUBLE          reduce using rule 32 (dtype -> CHAR .)
    FLOAT           reduce using rule 32 (dtype -> CHAR .)
    INT             reduce using rule 32 (dtype -> CHAR .)
    VOID            reduce using rule 32 (dtype -> CHAR .)
    UINT8_T         reduce using rule 32 (dtype -> CHAR .)
    UINT16_T        reduce using rule 32 (dtype -> CHAR .)
    LPAREN          reduce using rule 32 (dtype -> CHAR .)
    SIZEOF          reduce using rule 32 (dtype -> CHAR .)
    STRUCT          reduce using rule 32 (dtype -> CHAR .)


state 28

    (33) dtype -> DOUBLE .

    ID              reduce using rule 33 (dtype -> DOUBLE .)
    ASTERISK        reduce using rule 33 (dtype -> DOUBLE .)
    RPAREN          reduce using rule 33 (dtype -> DOUBLE .)
    FLOAT_L         reduce using rule 33 (dtype -> DOUBLE .)
    INT_L           reduce using rule 33 (dtype -> DOUBLE .)
    CHAR_L          reduce using rule 33 (dtype -> DOUBLE .)
    STRING_L        reduce using rule 33 (dtype -> DOUBLE .)
    NONDECIMAL_L    reduce using rule 33 (dtype -> DOUBLE .)
    BITAND          reduce using rule 33 (dtype -> DOUBLE .)
    COMMA           reduce using rule 33 (dtype -> DOUBLE .)
    CHAR            reduce using rule 33 (dtype -> DOUBLE .)
    DOUBLE          reduce using rule 33 (dtype -> DOUBLE .)
    FLOAT           reduce using rule 33 (dtype -> DOUBLE .)
    INT             reduce using rule 33 (dtype -> DOUBLE .)
    VOID            reduce using rule 33 (dtype -> DOUBLE .)
    UINT8_T         reduce using rule 33 (dtype -> DOUBLE .)
    UINT16_T        reduce using rule 33 (dtype -> DOUBLE .)
    LPAREN          reduce using rule 33 (dtype -> DOUBLE .)
    SIZEOF          reduce using rule 33 (dtype -> DOUBLE .)
    STRUCT          reduce using rule 33 (dtype -> DOUBLE .)


state 29

    (34) dtype -> FLOAT .

    ID              reduce using rule 34 (dtype -> FLOAT .)
    ASTERISK        reduce using rule 34 (dtype -> FLOAT .)
    RPAREN          reduce using rule 34 (dtype -> FLOAT .)
    FLOAT_L         reduce using rule 34 (dtype -> FLOAT .)
    INT_L           reduce using rule 34 (dtype -> FLOAT .)
    CHAR_L          reduce using rule 34 (dtype -> FLOAT .)
    STRING_L        reduce using rule 34 (dtype -> FLOAT .)
    NONDECIMAL_L    reduce using rule 34 (dtype -> FLOAT .)
    BITAND          reduce using rule 34 (dtype -> FLOAT .)
    COMMA           reduce using rule 34 (dtype -> FLOAT .)
    CHAR            reduce using rule 34 (dtype -> FLOAT .)
    DOUBLE          reduce using rule 34 (dtype -> FLOAT .)
    FLOAT           reduce using rule 34 (dtype -> FLOAT .)
    INT             reduce using rule 34 (dtype -> FLOAT .)
    VOID            reduce using rule 34 (dtype -> FLOAT .)
    UINT8_T         reduce using rule 34 (dtype -> FLOAT .)
    UINT16_T        reduce using rule 34 (dtype -> FLOAT .)
    LPAREN          reduce using rule 34 (dtype -> FLOAT .)
    SIZEOF          reduce using rule 34 (dtype -> FLOAT .)
    STRUCT          reduce using rule 34 (dtype -> FLOAT .)


state 30

    (35) dtype -> INT .

    ID              reduce using rule 35 (dtype -> INT .)
    ASTERISK        reduce using rule 35 (dtype -> INT .)
    RPAREN          reduce using rule 35 (dtype -> INT .)
    FLOAT_L         reduce using rule 35 (dtype -> INT .)
    INT_L           reduce using rule 35 (dtype -> INT .)
    CHAR_L          reduce using rule 35 (dtype -> INT .)
    STRING_L        reduce using rule 35 (dtype -> INT .)
    NONDECIMAL_L    reduce using rule 35 (dtype -> INT .)
    BITAND          reduce using rule 35 (dtype -> INT .)
    COMMA           reduce using rule 35 (dtype -> INT .)
    CHAR            reduce using rule 35 (dtype -> INT .)
    DOUBLE          reduce using rule 35 (dtype -> INT .)
    FLOAT           reduce using rule 35 (dtype -> INT .)
    INT             reduce using rule 35 (dtype -> INT .)
    VOID            reduce using rule 35 (dtype -> INT .)
    UINT8_T         reduce using rule 35 (dtype -> INT .)
    UINT16_T        reduce using rule 35 (dtype -> INT .)
    LPAREN          reduce using rule 35 (dtype -> INT .)
    SIZEOF          reduce using rule 35 (dtype -> INT .)
    STRUCT          reduce using rule 35 (dtype -> INT .)


state 31

    (36) dtype -> VOID .

    ID              reduce using rule 36 (dtype -> VOID .)
    ASTERISK        reduce using rule 36 (dtype -> VOID .)
    RPAREN          reduce using rule 36 (dtype -> VOID .)
    FLOAT_L         reduce using rule 36 (dtype -> VOID .)
    INT_L           reduce using rule 36 (dtype -> VOID .)
    CHAR_L          reduce using rule 36 (dtype -> VOID .)
    STRING_L        reduce using rule 36 (dtype -> VOID .)
    NONDECIMAL_L    reduce using rule 36 (dtype -> VOID .)
    BITAND          reduce using rule 36 (dtype -> VOID .)
    COMMA           reduce using rule 36 (dtype -> VOID .)
    CHAR            reduce using rule 36 (dtype -> VOID .)
    DOUBLE          reduce using rule 36 (dtype -> VOID .)
    FLOAT           reduce using rule 36 (dtype -> VOID .)
    INT             reduce using rule 36 (dtype -> VOID .)
    VOID            reduce using rule 36 (dtype -> VOID .)
    UINT8_T         reduce using rule 36 (dtype -> VOID .)
    UINT16_T        reduce using rule 36 (dtype -> VOID .)
    LPAREN          reduce using rule 36 (dtype -> VOID .)
    SIZEOF          reduce using rule 36 (dtype -> VOID .)
    STRUCT          reduce using rule 36 (dtype -> VOID .)


state 32

    (37) dtype -> UINT8_T .

    ID              reduce using rule 37 (dtype -> UINT8_T .)
    ASTERISK        reduce using rule 37 (dtype -> UINT8_T .)
    RPAREN          reduce using rule 37 (dtype -> UINT8_T .)
    FLOAT_L         reduce using rule 37 (dtype -> UINT8_T .)
    INT_L           reduce using rule 37 (dtype -> UINT8_T .)
    CHAR_L          reduce using rule 37 (dtype -> UINT8_T .)
    STRING_L        reduce using rule 37 (dtype -> UINT8_T .)
    NONDECIMAL_L    reduce using rule 37 (dtype -> UINT8_T .)
    BITAND          reduce using rule 37 (dtype -> UINT8_T .)
    COMMA           reduce using rule 37 (dtype -> UINT8_T .)
    CHAR            reduce using rule 37 (dtype -> UINT8_T .)
    DOUBLE          reduce using rule 37 (dtype -> UINT8_T .)
    FLOAT           reduce using rule 37 (dtype -> UINT8_T .)
    INT             reduce using rule 37 (dtype -> UINT8_T .)
    VOID            reduce using rule 37 (dtype -> UINT8_T .)
    UINT8_T         reduce using rule 37 (dtype -> UINT8_T .)
    UINT16_T        reduce using rule 37 (dtype -> UINT8_T .)
    LPAREN          reduce using rule 37 (dtype -> UINT8_T .)
    SIZEOF          reduce using rule 37 (dtype -> UINT8_T .)
    STRUCT          reduce using rule 37 (dtype -> UINT8_T .)


state 33

    (38) dtype -> UINT16_T .

    ID              reduce using rule 38 (dtype -> UINT16_T .)
    ASTERISK        reduce using rule 38 (dtype -> UINT16_T .)
    RPAREN          reduce using rule 38 (dtype -> UINT16_T .)
    FLOAT_L         reduce using rule 38 (dtype -> UINT16_T .)
    INT_L           reduce using rule 38 (dtype -> UINT16_T .)
    CHAR_L          reduce using rule 38 (dtype -> UINT16_T .)
    STRING_L        reduce using rule 38 (dtype -> UINT16_T .)
    NONDECIMAL_L    reduce using rule 38 (dtype -> UINT16_T .)
    BITAND          reduce using rule 38 (dtype -> UINT16_T .)
    COMMA           reduce using rule 38 (dtype -> UINT16_T .)
    CHAR            reduce using rule 38 (dtype -> UINT16_T .)
    DOUBLE          reduce using rule 38 (dtype -> UINT16_T .)
    FLOAT           reduce using rule 38 (dtype -> UINT16_T .)
    INT             reduce using rule 38 (dtype -> UINT16_T .)
    VOID            reduce using rule 38 (dtype -> UINT16_T .)
    UINT8_T         reduce using rule 38 (dtype -> UINT16_T .)
    UINT16_T        reduce using rule 38 (dtype -> UINT16_T .)
    LPAREN          reduce using rule 38 (dtype -> UINT16_T .)
    SIZEOF          reduce using rule 38 (dtype -> UINT16_T .)
    STRUCT          reduce using rule 38 (dtype -> UINT16_T .)


state 34

    (39) dtype -> struct_type .

    ID              reduce using rule 39 (dtype -> struct_type .)
    ASTERISK        reduce using rule 39 (dtype -> struct_type .)
    RPAREN          reduce using rule 39 (dtype -> struct_type .)
    FLOAT_L         reduce using rule 39 (dtype -> struct_type .)
    INT_L           reduce using rule 39 (dtype -> struct_type .)
    CHAR_L          reduce using rule 39 (dtype -> struct_type .)
    STRING_L        reduce using rule 39 (dtype -> struct_type .)
    NONDECIMAL_L    reduce using rule 39 (dtype -> struct_type .)
    BITAND          reduce using rule 39 (dtype -> struct_type .)
    COMMA           reduce using rule 39 (dtype -> struct_type .)
    CHAR            reduce using rule 39 (dtype -> struct_type .)
    DOUBLE          reduce using rule 39 (dtype -> struct_type .)
    FLOAT           reduce using rule 39 (dtype -> struct_type .)
    INT             reduce using rule 39 (dtype -> struct_type .)
    VOID            reduce using rule 39 (dtype -> struct_type .)
    UINT8_T         reduce using rule 39 (dtype -> struct_type .)
    UINT16_T        reduce using rule 39 (dtype -> struct_type .)
    LPAREN          reduce using rule 39 (dtype -> struct_type .)
    SIZEOF          reduce using rule 39 (dtype -> struct_type .)
    STRUCT          reduce using rule 39 (dtype -> struct_type .)


state 35

    (139) init_var -> init_var_ls . init_var_rs
    (133) init_var_rs -> . name SEMI
    (134) init_var_rs -> . func_call SEMI
    (135) init_var_rs -> . expression SEMI
    (136) init_var_rs -> . typecast_init
    (137) init_var_rs -> . LPAREN name RPAREN
    (138) init_var_rs -> . error SEMI
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (132) typecast_init -> . type_cast init_var_rs
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (19) type_cast -> . LPAREN dtype RPAREN

    LPAREN          shift and go to state 88
    error           shift and go to state 89
    ID              shift and go to state 90
    SIZEOF          shift and go to state 42
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    init_var_rs                    shift and go to state 83
    name                           shift and go to state 84
    func_call                      shift and go to state 85
    expression                     shift and go to state 86
    typecast_init                  shift and go to state 87
    literal                        shift and go to state 50
    access                         shift and go to state 51
    operand                        shift and go to state 41
    type_cast                      shift and go to state 91

state 36

    (142) assign_var -> assign_var_ls . assign_var_rs
    (141) assign_var_rs -> . init_var_rs
    (133) init_var_rs -> . name SEMI
    (134) init_var_rs -> . func_call SEMI
    (135) init_var_rs -> . expression SEMI
    (136) init_var_rs -> . typecast_init
    (137) init_var_rs -> . LPAREN name RPAREN
    (138) init_var_rs -> . error SEMI
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (132) typecast_init -> . type_cast init_var_rs
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (19) type_cast -> . LPAREN dtype RPAREN

    LPAREN          shift and go to state 88
    error           shift and go to state 89
    ID              shift and go to state 90
    SIZEOF          shift and go to state 42
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    assign_var_rs                  shift and go to state 92
    init_var_rs                    shift and go to state 93
    name                           shift and go to state 84
    func_call                      shift and go to state 85
    expression                     shift and go to state 86
    typecast_init                  shift and go to state 87
    literal                        shift and go to state 50
    access                         shift and go to state 51
    operand                        shift and go to state 41
    type_cast                      shift and go to state 91

state 37

    (125) declare_var -> declare_var_ls . SEMI
    (130) init_var_ls -> declare_var_ls . assign
    (131) init_var_ls -> declare_var_ls . vector_init assign
    (16) assign -> . SIMPLE_ASSIGN
    (17) assign -> . COMPLEX_ASSIGN
    (126) vector_init -> . LBRACK RBRACK
    (127) vector_init -> . LBRACK name RBRACK

    SEMI            shift and go to state 94
    SIMPLE_ASSIGN   shift and go to state 97
    COMPLEX_ASSIGN  shift and go to state 98
    LBRACK          shift and go to state 99

    assign                         shift and go to state 95
    vector_init                    shift and go to state 96

state 38

    (118) expression -> name . INCREMENT
    (140) assign_var_ls -> name . assign
    (113) operand -> name .
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name
    (16) assign -> . SIMPLE_ASSIGN
    (17) assign -> . COMPLEX_ASSIGN

    INCREMENT       shift and go to state 100
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITAND          reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              reduce using rule 113 (operand -> name .)
    NEQ             reduce using rule 113 (operand -> name .)
    LT              reduce using rule 113 (operand -> name .)
    GT              reduce using rule 113 (operand -> name .)
    LE              reduce using rule 113 (operand -> name .)
    GE              reduce using rule 113 (operand -> name .)
    AND             reduce using rule 113 (operand -> name .)
    OR              reduce using rule 113 (operand -> name .)
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103
    SIMPLE_ASSIGN   shift and go to state 97
    COMPLEX_ASSIGN  shift and go to state 98

    assign                         shift and go to state 101

state 39

    (99) expression -> NEGATE . expression
    (101) expression -> NEGATE . name
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN

    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    ID              shift and go to state 90
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    SIZEOF          shift and go to state 42

    expression                     shift and go to state 104
    name                           shift and go to state 105
    operand                        shift and go to state 41
    literal                        shift and go to state 50
    access                         shift and go to state 51
    type_cast                      shift and go to state 49
    func_call                      shift and go to state 73

state 40

    (100) expression -> MINUS . expression
    (102) expression -> MINUS . name
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN

    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    ID              shift and go to state 90
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    SIZEOF          shift and go to state 42

    expression                     shift and go to state 106
    name                           shift and go to state 107
    operand                        shift and go to state 41
    literal                        shift and go to state 50
    access                         shift and go to state 51
    type_cast                      shift and go to state 49
    func_call                      shift and go to state 73

state 41

    (117) expression -> operand . binop operand
    (103) binop -> . PLUS
    (104) binop -> . MINUS
    (105) binop -> . ASTERISK
    (106) binop -> . DIVIDE
    (107) binop -> . LSHIFT
    (108) binop -> . RSHIFT
    (109) binop -> . PERCENT
    (110) binop -> . BITAND
    (111) binop -> . BITOR
    (112) binop -> . conditional
    (52) conditional -> . EQ
    (53) conditional -> . NEQ
    (54) conditional -> . LT
    (55) conditional -> . GT
    (56) conditional -> . LE
    (57) conditional -> . GE
    (58) conditional -> . AND
    (59) conditional -> . OR

    PLUS            shift and go to state 109
    MINUS           shift and go to state 110
    ASTERISK        shift and go to state 111
    DIVIDE          shift and go to state 112
    LSHIFT          shift and go to state 113
    RSHIFT          shift and go to state 114
    PERCENT         shift and go to state 115
    BITAND          shift and go to state 116
    BITOR           shift and go to state 117
    EQ              shift and go to state 119
    NEQ             shift and go to state 120
    LT              shift and go to state 121
    GT              shift and go to state 122
    LE              shift and go to state 123
    GE              shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

    binop                          shift and go to state 108
    conditional                    shift and go to state 118

state 42

    (83) func_call -> SIZEOF . LPAREN func_arglist RPAREN

    LPAREN          shift and go to state 127


state 43

    (119) return -> RETURN . name
    (120) return -> RETURN . expression
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN

    ID              shift and go to state 90
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    SIZEOF          shift and go to state 42

    name                           shift and go to state 128
    expression                     shift and go to state 129
    literal                        shift and go to state 50
    access                         shift and go to state 51
    operand                        shift and go to state 41
    type_cast                      shift and go to state 49
    func_call                      shift and go to state 73

state 44

    (49) control -> WHILE .

    LPAREN          reduce using rule 49 (control -> WHILE .)
    LBRACE          reduce using rule 49 (control -> WHILE .)


state 45

    (50) control -> IF .

    LPAREN          reduce using rule 50 (control -> IF .)
    LBRACE          reduce using rule 50 (control -> IF .)


state 46

    (51) control -> ELSE .

    LPAREN          reduce using rule 51 (control -> ELSE .)
    LBRACE          reduce using rule 51 (control -> ELSE .)


state 47

    (66) for_loop -> FOR . LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN

    LPAREN          shift and go to state 130


state 48

    (124) declare_var_ls -> modifier . dtype ID
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (18) struct_type -> . STRUCT name

    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    ID              shift and go to state 132
    STRUCT          shift and go to state 74

    dtype                          shift and go to state 131
    struct_type                    shift and go to state 34

state 49

    (115) operand -> type_cast . name
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    ID              shift and go to state 134
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    name                           shift and go to state 133
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 50

    (43) name -> literal .

    INCREMENT       reduce using rule 43 (name -> literal .)
    LBRACK          reduce using rule 43 (name -> literal .)
    MEMBER          reduce using rule 43 (name -> literal .)
    SIMPLE_ASSIGN   reduce using rule 43 (name -> literal .)
    COMPLEX_ASSIGN  reduce using rule 43 (name -> literal .)
    PLUS            reduce using rule 43 (name -> literal .)
    MINUS           reduce using rule 43 (name -> literal .)
    ASTERISK        reduce using rule 43 (name -> literal .)
    DIVIDE          reduce using rule 43 (name -> literal .)
    LSHIFT          reduce using rule 43 (name -> literal .)
    RSHIFT          reduce using rule 43 (name -> literal .)
    PERCENT         reduce using rule 43 (name -> literal .)
    BITAND          reduce using rule 43 (name -> literal .)
    BITOR           reduce using rule 43 (name -> literal .)
    EQ              reduce using rule 43 (name -> literal .)
    NEQ             reduce using rule 43 (name -> literal .)
    LT              reduce using rule 43 (name -> literal .)
    GT              reduce using rule 43 (name -> literal .)
    LE              reduce using rule 43 (name -> literal .)
    GE              reduce using rule 43 (name -> literal .)
    AND             reduce using rule 43 (name -> literal .)
    OR              reduce using rule 43 (name -> literal .)
    RPAREN          reduce using rule 43 (name -> literal .)
    ID              reduce using rule 43 (name -> literal .)
    SEMI            reduce using rule 43 (name -> literal .)
    RBRACK          reduce using rule 43 (name -> literal .)
    COMMA           reduce using rule 43 (name -> literal .)
    CHAR            reduce using rule 43 (name -> literal .)
    DOUBLE          reduce using rule 43 (name -> literal .)
    FLOAT           reduce using rule 43 (name -> literal .)
    INT             reduce using rule 43 (name -> literal .)
    VOID            reduce using rule 43 (name -> literal .)
    UINT8_T         reduce using rule 43 (name -> literal .)
    UINT16_T        reduce using rule 43 (name -> literal .)
    LPAREN          reduce using rule 43 (name -> literal .)
    SIZEOF          reduce using rule 43 (name -> literal .)
    FLOAT_L         reduce using rule 43 (name -> literal .)
    INT_L           reduce using rule 43 (name -> literal .)
    CHAR_L          reduce using rule 43 (name -> literal .)
    STRING_L        reduce using rule 43 (name -> literal .)
    NONDECIMAL_L    reduce using rule 43 (name -> literal .)
    STRUCT          reduce using rule 43 (name -> literal .)


state 51

    (44) name -> access .

    INCREMENT       reduce using rule 44 (name -> access .)
    LBRACK          reduce using rule 44 (name -> access .)
    MEMBER          reduce using rule 44 (name -> access .)
    SIMPLE_ASSIGN   reduce using rule 44 (name -> access .)
    COMPLEX_ASSIGN  reduce using rule 44 (name -> access .)
    PLUS            reduce using rule 44 (name -> access .)
    MINUS           reduce using rule 44 (name -> access .)
    ASTERISK        reduce using rule 44 (name -> access .)
    DIVIDE          reduce using rule 44 (name -> access .)
    LSHIFT          reduce using rule 44 (name -> access .)
    RSHIFT          reduce using rule 44 (name -> access .)
    PERCENT         reduce using rule 44 (name -> access .)
    BITAND          reduce using rule 44 (name -> access .)
    BITOR           reduce using rule 44 (name -> access .)
    EQ              reduce using rule 44 (name -> access .)
    NEQ             reduce using rule 44 (name -> access .)
    LT              reduce using rule 44 (name -> access .)
    GT              reduce using rule 44 (name -> access .)
    LE              reduce using rule 44 (name -> access .)
    GE              reduce using rule 44 (name -> access .)
    AND             reduce using rule 44 (name -> access .)
    OR              reduce using rule 44 (name -> access .)
    RPAREN          reduce using rule 44 (name -> access .)
    ID              reduce using rule 44 (name -> access .)
    SEMI            reduce using rule 44 (name -> access .)
    RBRACK          reduce using rule 44 (name -> access .)
    COMMA           reduce using rule 44 (name -> access .)
    CHAR            reduce using rule 44 (name -> access .)
    DOUBLE          reduce using rule 44 (name -> access .)
    FLOAT           reduce using rule 44 (name -> access .)
    INT             reduce using rule 44 (name -> access .)
    VOID            reduce using rule 44 (name -> access .)
    UINT8_T         reduce using rule 44 (name -> access .)
    UINT16_T        reduce using rule 44 (name -> access .)
    LPAREN          reduce using rule 44 (name -> access .)
    SIZEOF          reduce using rule 44 (name -> access .)
    FLOAT_L         reduce using rule 44 (name -> access .)
    INT_L           reduce using rule 44 (name -> access .)
    CHAR_L          reduce using rule 44 (name -> access .)
    STRING_L        reduce using rule 44 (name -> access .)
    NONDECIMAL_L    reduce using rule 44 (name -> access .)
    STRUCT          reduce using rule 44 (name -> access .)


state 52

    (20) modifier -> CONST .

    CHAR            reduce using rule 20 (modifier -> CONST .)
    DOUBLE          reduce using rule 20 (modifier -> CONST .)
    FLOAT           reduce using rule 20 (modifier -> CONST .)
    INT             reduce using rule 20 (modifier -> CONST .)
    VOID            reduce using rule 20 (modifier -> CONST .)
    UINT8_T         reduce using rule 20 (modifier -> CONST .)
    UINT16_T        reduce using rule 20 (modifier -> CONST .)
    ID              reduce using rule 20 (modifier -> CONST .)
    STRUCT          reduce using rule 20 (modifier -> CONST .)


state 53

    (21) modifier -> EXTERN .

    CHAR            reduce using rule 21 (modifier -> EXTERN .)
    DOUBLE          reduce using rule 21 (modifier -> EXTERN .)
    FLOAT           reduce using rule 21 (modifier -> EXTERN .)
    INT             reduce using rule 21 (modifier -> EXTERN .)
    VOID            reduce using rule 21 (modifier -> EXTERN .)
    UINT8_T         reduce using rule 21 (modifier -> EXTERN .)
    UINT16_T        reduce using rule 21 (modifier -> EXTERN .)
    ID              reduce using rule 21 (modifier -> EXTERN .)
    STRUCT          reduce using rule 21 (modifier -> EXTERN .)


state 54

    (22) modifier -> INLINE .

    CHAR            reduce using rule 22 (modifier -> INLINE .)
    DOUBLE          reduce using rule 22 (modifier -> INLINE .)
    FLOAT           reduce using rule 22 (modifier -> INLINE .)
    INT             reduce using rule 22 (modifier -> INLINE .)
    VOID            reduce using rule 22 (modifier -> INLINE .)
    UINT8_T         reduce using rule 22 (modifier -> INLINE .)
    UINT16_T        reduce using rule 22 (modifier -> INLINE .)
    ID              reduce using rule 22 (modifier -> INLINE .)
    STRUCT          reduce using rule 22 (modifier -> INLINE .)


state 55

    (23) modifier -> LONG .

    CHAR            reduce using rule 23 (modifier -> LONG .)
    DOUBLE          reduce using rule 23 (modifier -> LONG .)
    FLOAT           reduce using rule 23 (modifier -> LONG .)
    INT             reduce using rule 23 (modifier -> LONG .)
    VOID            reduce using rule 23 (modifier -> LONG .)
    UINT8_T         reduce using rule 23 (modifier -> LONG .)
    UINT16_T        reduce using rule 23 (modifier -> LONG .)
    ID              reduce using rule 23 (modifier -> LONG .)
    STRUCT          reduce using rule 23 (modifier -> LONG .)


state 56

    (24) modifier -> SHORT .

    CHAR            reduce using rule 24 (modifier -> SHORT .)
    DOUBLE          reduce using rule 24 (modifier -> SHORT .)
    FLOAT           reduce using rule 24 (modifier -> SHORT .)
    INT             reduce using rule 24 (modifier -> SHORT .)
    VOID            reduce using rule 24 (modifier -> SHORT .)
    UINT8_T         reduce using rule 24 (modifier -> SHORT .)
    UINT16_T        reduce using rule 24 (modifier -> SHORT .)
    ID              reduce using rule 24 (modifier -> SHORT .)
    STRUCT          reduce using rule 24 (modifier -> SHORT .)


state 57

    (25) modifier -> SIGNED .

    CHAR            reduce using rule 25 (modifier -> SIGNED .)
    DOUBLE          reduce using rule 25 (modifier -> SIGNED .)
    FLOAT           reduce using rule 25 (modifier -> SIGNED .)
    INT             reduce using rule 25 (modifier -> SIGNED .)
    VOID            reduce using rule 25 (modifier -> SIGNED .)
    UINT8_T         reduce using rule 25 (modifier -> SIGNED .)
    UINT16_T        reduce using rule 25 (modifier -> SIGNED .)
    ID              reduce using rule 25 (modifier -> SIGNED .)
    STRUCT          reduce using rule 25 (modifier -> SIGNED .)


state 58

    (26) modifier -> UNSIGNED .

    CHAR            reduce using rule 26 (modifier -> UNSIGNED .)
    DOUBLE          reduce using rule 26 (modifier -> UNSIGNED .)
    FLOAT           reduce using rule 26 (modifier -> UNSIGNED .)
    INT             reduce using rule 26 (modifier -> UNSIGNED .)
    VOID            reduce using rule 26 (modifier -> UNSIGNED .)
    UINT8_T         reduce using rule 26 (modifier -> UNSIGNED .)
    UINT16_T        reduce using rule 26 (modifier -> UNSIGNED .)
    ID              reduce using rule 26 (modifier -> UNSIGNED .)
    STRUCT          reduce using rule 26 (modifier -> UNSIGNED .)


state 59

    (27) modifier -> VOLATILE .

    CHAR            reduce using rule 27 (modifier -> VOLATILE .)
    DOUBLE          reduce using rule 27 (modifier -> VOLATILE .)
    FLOAT           reduce using rule 27 (modifier -> VOLATILE .)
    INT             reduce using rule 27 (modifier -> VOLATILE .)
    VOID            reduce using rule 27 (modifier -> VOLATILE .)
    UINT8_T         reduce using rule 27 (modifier -> VOLATILE .)
    UINT16_T        reduce using rule 27 (modifier -> VOLATILE .)
    ID              reduce using rule 27 (modifier -> VOLATILE .)
    STRUCT          reduce using rule 27 (modifier -> VOLATILE .)


state 60

    (11) literal -> FLOAT_L .

    INCREMENT       reduce using rule 11 (literal -> FLOAT_L .)
    LBRACK          reduce using rule 11 (literal -> FLOAT_L .)
    MEMBER          reduce using rule 11 (literal -> FLOAT_L .)
    SIMPLE_ASSIGN   reduce using rule 11 (literal -> FLOAT_L .)
    COMPLEX_ASSIGN  reduce using rule 11 (literal -> FLOAT_L .)
    PLUS            reduce using rule 11 (literal -> FLOAT_L .)
    MINUS           reduce using rule 11 (literal -> FLOAT_L .)
    ASTERISK        reduce using rule 11 (literal -> FLOAT_L .)
    DIVIDE          reduce using rule 11 (literal -> FLOAT_L .)
    LSHIFT          reduce using rule 11 (literal -> FLOAT_L .)
    RSHIFT          reduce using rule 11 (literal -> FLOAT_L .)
    PERCENT         reduce using rule 11 (literal -> FLOAT_L .)
    BITAND          reduce using rule 11 (literal -> FLOAT_L .)
    BITOR           reduce using rule 11 (literal -> FLOAT_L .)
    EQ              reduce using rule 11 (literal -> FLOAT_L .)
    NEQ             reduce using rule 11 (literal -> FLOAT_L .)
    LT              reduce using rule 11 (literal -> FLOAT_L .)
    GT              reduce using rule 11 (literal -> FLOAT_L .)
    LE              reduce using rule 11 (literal -> FLOAT_L .)
    GE              reduce using rule 11 (literal -> FLOAT_L .)
    AND             reduce using rule 11 (literal -> FLOAT_L .)
    OR              reduce using rule 11 (literal -> FLOAT_L .)
    RPAREN          reduce using rule 11 (literal -> FLOAT_L .)
    ID              reduce using rule 11 (literal -> FLOAT_L .)
    SEMI            reduce using rule 11 (literal -> FLOAT_L .)
    RBRACK          reduce using rule 11 (literal -> FLOAT_L .)
    COMMA           reduce using rule 11 (literal -> FLOAT_L .)
    CHAR            reduce using rule 11 (literal -> FLOAT_L .)
    DOUBLE          reduce using rule 11 (literal -> FLOAT_L .)
    FLOAT           reduce using rule 11 (literal -> FLOAT_L .)
    INT             reduce using rule 11 (literal -> FLOAT_L .)
    VOID            reduce using rule 11 (literal -> FLOAT_L .)
    UINT8_T         reduce using rule 11 (literal -> FLOAT_L .)
    UINT16_T        reduce using rule 11 (literal -> FLOAT_L .)
    LPAREN          reduce using rule 11 (literal -> FLOAT_L .)
    SIZEOF          reduce using rule 11 (literal -> FLOAT_L .)
    FLOAT_L         reduce using rule 11 (literal -> FLOAT_L .)
    INT_L           reduce using rule 11 (literal -> FLOAT_L .)
    CHAR_L          reduce using rule 11 (literal -> FLOAT_L .)
    STRING_L        reduce using rule 11 (literal -> FLOAT_L .)
    NONDECIMAL_L    reduce using rule 11 (literal -> FLOAT_L .)
    STRUCT          reduce using rule 11 (literal -> FLOAT_L .)


state 61

    (12) literal -> INT_L .

    INCREMENT       reduce using rule 12 (literal -> INT_L .)
    LBRACK          reduce using rule 12 (literal -> INT_L .)
    MEMBER          reduce using rule 12 (literal -> INT_L .)
    SIMPLE_ASSIGN   reduce using rule 12 (literal -> INT_L .)
    COMPLEX_ASSIGN  reduce using rule 12 (literal -> INT_L .)
    PLUS            reduce using rule 12 (literal -> INT_L .)
    MINUS           reduce using rule 12 (literal -> INT_L .)
    ASTERISK        reduce using rule 12 (literal -> INT_L .)
    DIVIDE          reduce using rule 12 (literal -> INT_L .)
    LSHIFT          reduce using rule 12 (literal -> INT_L .)
    RSHIFT          reduce using rule 12 (literal -> INT_L .)
    PERCENT         reduce using rule 12 (literal -> INT_L .)
    BITAND          reduce using rule 12 (literal -> INT_L .)
    BITOR           reduce using rule 12 (literal -> INT_L .)
    EQ              reduce using rule 12 (literal -> INT_L .)
    NEQ             reduce using rule 12 (literal -> INT_L .)
    LT              reduce using rule 12 (literal -> INT_L .)
    GT              reduce using rule 12 (literal -> INT_L .)
    LE              reduce using rule 12 (literal -> INT_L .)
    GE              reduce using rule 12 (literal -> INT_L .)
    AND             reduce using rule 12 (literal -> INT_L .)
    OR              reduce using rule 12 (literal -> INT_L .)
    RPAREN          reduce using rule 12 (literal -> INT_L .)
    ID              reduce using rule 12 (literal -> INT_L .)
    SEMI            reduce using rule 12 (literal -> INT_L .)
    RBRACK          reduce using rule 12 (literal -> INT_L .)
    COMMA           reduce using rule 12 (literal -> INT_L .)
    CHAR            reduce using rule 12 (literal -> INT_L .)
    DOUBLE          reduce using rule 12 (literal -> INT_L .)
    FLOAT           reduce using rule 12 (literal -> INT_L .)
    INT             reduce using rule 12 (literal -> INT_L .)
    VOID            reduce using rule 12 (literal -> INT_L .)
    UINT8_T         reduce using rule 12 (literal -> INT_L .)
    UINT16_T        reduce using rule 12 (literal -> INT_L .)
    LPAREN          reduce using rule 12 (literal -> INT_L .)
    SIZEOF          reduce using rule 12 (literal -> INT_L .)
    FLOAT_L         reduce using rule 12 (literal -> INT_L .)
    INT_L           reduce using rule 12 (literal -> INT_L .)
    CHAR_L          reduce using rule 12 (literal -> INT_L .)
    STRING_L        reduce using rule 12 (literal -> INT_L .)
    NONDECIMAL_L    reduce using rule 12 (literal -> INT_L .)
    STRUCT          reduce using rule 12 (literal -> INT_L .)


state 62

    (13) literal -> CHAR_L .

    INCREMENT       reduce using rule 13 (literal -> CHAR_L .)
    LBRACK          reduce using rule 13 (literal -> CHAR_L .)
    MEMBER          reduce using rule 13 (literal -> CHAR_L .)
    SIMPLE_ASSIGN   reduce using rule 13 (literal -> CHAR_L .)
    COMPLEX_ASSIGN  reduce using rule 13 (literal -> CHAR_L .)
    PLUS            reduce using rule 13 (literal -> CHAR_L .)
    MINUS           reduce using rule 13 (literal -> CHAR_L .)
    ASTERISK        reduce using rule 13 (literal -> CHAR_L .)
    DIVIDE          reduce using rule 13 (literal -> CHAR_L .)
    LSHIFT          reduce using rule 13 (literal -> CHAR_L .)
    RSHIFT          reduce using rule 13 (literal -> CHAR_L .)
    PERCENT         reduce using rule 13 (literal -> CHAR_L .)
    BITAND          reduce using rule 13 (literal -> CHAR_L .)
    BITOR           reduce using rule 13 (literal -> CHAR_L .)
    EQ              reduce using rule 13 (literal -> CHAR_L .)
    NEQ             reduce using rule 13 (literal -> CHAR_L .)
    LT              reduce using rule 13 (literal -> CHAR_L .)
    GT              reduce using rule 13 (literal -> CHAR_L .)
    LE              reduce using rule 13 (literal -> CHAR_L .)
    GE              reduce using rule 13 (literal -> CHAR_L .)
    AND             reduce using rule 13 (literal -> CHAR_L .)
    OR              reduce using rule 13 (literal -> CHAR_L .)
    RPAREN          reduce using rule 13 (literal -> CHAR_L .)
    ID              reduce using rule 13 (literal -> CHAR_L .)
    SEMI            reduce using rule 13 (literal -> CHAR_L .)
    RBRACK          reduce using rule 13 (literal -> CHAR_L .)
    COMMA           reduce using rule 13 (literal -> CHAR_L .)
    CHAR            reduce using rule 13 (literal -> CHAR_L .)
    DOUBLE          reduce using rule 13 (literal -> CHAR_L .)
    FLOAT           reduce using rule 13 (literal -> CHAR_L .)
    INT             reduce using rule 13 (literal -> CHAR_L .)
    VOID            reduce using rule 13 (literal -> CHAR_L .)
    UINT8_T         reduce using rule 13 (literal -> CHAR_L .)
    UINT16_T        reduce using rule 13 (literal -> CHAR_L .)
    LPAREN          reduce using rule 13 (literal -> CHAR_L .)
    SIZEOF          reduce using rule 13 (literal -> CHAR_L .)
    FLOAT_L         reduce using rule 13 (literal -> CHAR_L .)
    INT_L           reduce using rule 13 (literal -> CHAR_L .)
    CHAR_L          reduce using rule 13 (literal -> CHAR_L .)
    STRING_L        reduce using rule 13 (literal -> CHAR_L .)
    NONDECIMAL_L    reduce using rule 13 (literal -> CHAR_L .)
    STRUCT          reduce using rule 13 (literal -> CHAR_L .)


state 63

    (14) literal -> STRING_L .

    INCREMENT       reduce using rule 14 (literal -> STRING_L .)
    LBRACK          reduce using rule 14 (literal -> STRING_L .)
    MEMBER          reduce using rule 14 (literal -> STRING_L .)
    SIMPLE_ASSIGN   reduce using rule 14 (literal -> STRING_L .)
    COMPLEX_ASSIGN  reduce using rule 14 (literal -> STRING_L .)
    PLUS            reduce using rule 14 (literal -> STRING_L .)
    MINUS           reduce using rule 14 (literal -> STRING_L .)
    ASTERISK        reduce using rule 14 (literal -> STRING_L .)
    DIVIDE          reduce using rule 14 (literal -> STRING_L .)
    LSHIFT          reduce using rule 14 (literal -> STRING_L .)
    RSHIFT          reduce using rule 14 (literal -> STRING_L .)
    PERCENT         reduce using rule 14 (literal -> STRING_L .)
    BITAND          reduce using rule 14 (literal -> STRING_L .)
    BITOR           reduce using rule 14 (literal -> STRING_L .)
    EQ              reduce using rule 14 (literal -> STRING_L .)
    NEQ             reduce using rule 14 (literal -> STRING_L .)
    LT              reduce using rule 14 (literal -> STRING_L .)
    GT              reduce using rule 14 (literal -> STRING_L .)
    LE              reduce using rule 14 (literal -> STRING_L .)
    GE              reduce using rule 14 (literal -> STRING_L .)
    AND             reduce using rule 14 (literal -> STRING_L .)
    OR              reduce using rule 14 (literal -> STRING_L .)
    RPAREN          reduce using rule 14 (literal -> STRING_L .)
    ID              reduce using rule 14 (literal -> STRING_L .)
    SEMI            reduce using rule 14 (literal -> STRING_L .)
    RBRACK          reduce using rule 14 (literal -> STRING_L .)
    COMMA           reduce using rule 14 (literal -> STRING_L .)
    CHAR            reduce using rule 14 (literal -> STRING_L .)
    DOUBLE          reduce using rule 14 (literal -> STRING_L .)
    FLOAT           reduce using rule 14 (literal -> STRING_L .)
    INT             reduce using rule 14 (literal -> STRING_L .)
    VOID            reduce using rule 14 (literal -> STRING_L .)
    UINT8_T         reduce using rule 14 (literal -> STRING_L .)
    UINT16_T        reduce using rule 14 (literal -> STRING_L .)
    LPAREN          reduce using rule 14 (literal -> STRING_L .)
    SIZEOF          reduce using rule 14 (literal -> STRING_L .)
    FLOAT_L         reduce using rule 14 (literal -> STRING_L .)
    INT_L           reduce using rule 14 (literal -> STRING_L .)
    CHAR_L          reduce using rule 14 (literal -> STRING_L .)
    STRING_L        reduce using rule 14 (literal -> STRING_L .)
    NONDECIMAL_L    reduce using rule 14 (literal -> STRING_L .)
    STRUCT          reduce using rule 14 (literal -> STRING_L .)


state 64

    (15) literal -> NONDECIMAL_L .

    INCREMENT       reduce using rule 15 (literal -> NONDECIMAL_L .)
    LBRACK          reduce using rule 15 (literal -> NONDECIMAL_L .)
    MEMBER          reduce using rule 15 (literal -> NONDECIMAL_L .)
    SIMPLE_ASSIGN   reduce using rule 15 (literal -> NONDECIMAL_L .)
    COMPLEX_ASSIGN  reduce using rule 15 (literal -> NONDECIMAL_L .)
    PLUS            reduce using rule 15 (literal -> NONDECIMAL_L .)
    MINUS           reduce using rule 15 (literal -> NONDECIMAL_L .)
    ASTERISK        reduce using rule 15 (literal -> NONDECIMAL_L .)
    DIVIDE          reduce using rule 15 (literal -> NONDECIMAL_L .)
    LSHIFT          reduce using rule 15 (literal -> NONDECIMAL_L .)
    RSHIFT          reduce using rule 15 (literal -> NONDECIMAL_L .)
    PERCENT         reduce using rule 15 (literal -> NONDECIMAL_L .)
    BITAND          reduce using rule 15 (literal -> NONDECIMAL_L .)
    BITOR           reduce using rule 15 (literal -> NONDECIMAL_L .)
    EQ              reduce using rule 15 (literal -> NONDECIMAL_L .)
    NEQ             reduce using rule 15 (literal -> NONDECIMAL_L .)
    LT              reduce using rule 15 (literal -> NONDECIMAL_L .)
    GT              reduce using rule 15 (literal -> NONDECIMAL_L .)
    LE              reduce using rule 15 (literal -> NONDECIMAL_L .)
    GE              reduce using rule 15 (literal -> NONDECIMAL_L .)
    AND             reduce using rule 15 (literal -> NONDECIMAL_L .)
    OR              reduce using rule 15 (literal -> NONDECIMAL_L .)
    RPAREN          reduce using rule 15 (literal -> NONDECIMAL_L .)
    ID              reduce using rule 15 (literal -> NONDECIMAL_L .)
    SEMI            reduce using rule 15 (literal -> NONDECIMAL_L .)
    RBRACK          reduce using rule 15 (literal -> NONDECIMAL_L .)
    COMMA           reduce using rule 15 (literal -> NONDECIMAL_L .)
    CHAR            reduce using rule 15 (literal -> NONDECIMAL_L .)
    DOUBLE          reduce using rule 15 (literal -> NONDECIMAL_L .)
    FLOAT           reduce using rule 15 (literal -> NONDECIMAL_L .)
    INT             reduce using rule 15 (literal -> NONDECIMAL_L .)
    VOID            reduce using rule 15 (literal -> NONDECIMAL_L .)
    UINT8_T         reduce using rule 15 (literal -> NONDECIMAL_L .)
    UINT16_T        reduce using rule 15 (literal -> NONDECIMAL_L .)
    LPAREN          reduce using rule 15 (literal -> NONDECIMAL_L .)
    SIZEOF          reduce using rule 15 (literal -> NONDECIMAL_L .)
    FLOAT_L         reduce using rule 15 (literal -> NONDECIMAL_L .)
    INT_L           reduce using rule 15 (literal -> NONDECIMAL_L .)
    CHAR_L          reduce using rule 15 (literal -> NONDECIMAL_L .)
    STRING_L        reduce using rule 15 (literal -> NONDECIMAL_L .)
    NONDECIMAL_L    reduce using rule 15 (literal -> NONDECIMAL_L .)
    STRUCT          reduce using rule 15 (literal -> NONDECIMAL_L .)


state 65

    (88) access -> BITAND . name
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    ID              shift and go to state 134
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    name                           shift and go to state 135
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 66

    (80) func_def -> dtype ID . LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (84) func_decl -> dtype ID . LPAREN func_arglist RPAREN SEMI
    (123) declare_var_ls -> dtype ID .

    LPAREN          shift and go to state 136
    SEMI            reduce using rule 123 (declare_var_ls -> dtype ID .)
    SIMPLE_ASSIGN   reduce using rule 123 (declare_var_ls -> dtype ID .)
    COMPLEX_ASSIGN  reduce using rule 123 (declare_var_ls -> dtype ID .)
    LBRACK          reduce using rule 123 (declare_var_ls -> dtype ID .)


state 67

    (41) dtype -> dtype ASTERISK .

    ID              reduce using rule 41 (dtype -> dtype ASTERISK .)
    ASTERISK        reduce using rule 41 (dtype -> dtype ASTERISK .)
    RPAREN          reduce using rule 41 (dtype -> dtype ASTERISK .)
    FLOAT_L         reduce using rule 41 (dtype -> dtype ASTERISK .)
    INT_L           reduce using rule 41 (dtype -> dtype ASTERISK .)
    CHAR_L          reduce using rule 41 (dtype -> dtype ASTERISK .)
    STRING_L        reduce using rule 41 (dtype -> dtype ASTERISK .)
    NONDECIMAL_L    reduce using rule 41 (dtype -> dtype ASTERISK .)
    BITAND          reduce using rule 41 (dtype -> dtype ASTERISK .)
    COMMA           reduce using rule 41 (dtype -> dtype ASTERISK .)
    CHAR            reduce using rule 41 (dtype -> dtype ASTERISK .)
    DOUBLE          reduce using rule 41 (dtype -> dtype ASTERISK .)
    FLOAT           reduce using rule 41 (dtype -> dtype ASTERISK .)
    INT             reduce using rule 41 (dtype -> dtype ASTERISK .)
    VOID            reduce using rule 41 (dtype -> dtype ASTERISK .)
    UINT8_T         reduce using rule 41 (dtype -> dtype ASTERISK .)
    UINT16_T        reduce using rule 41 (dtype -> dtype ASTERISK .)
    LPAREN          reduce using rule 41 (dtype -> dtype ASTERISK .)
    SIZEOF          reduce using rule 41 (dtype -> dtype ASTERISK .)
    STRUCT          reduce using rule 41 (dtype -> dtype ASTERISK .)


state 68

    (81) func_def -> ID LPAREN . func_arglist RPAREN LBRACE node_list RBRACE
    (82) func_call -> ID LPAREN . func_arglist RPAREN
    (77) func_arglist -> .
    (78) func_arglist -> . func_arglist func_arg
    (79) func_arglist -> . func_arglist func_arg COMMA

    RPAREN          reduce using rule 77 (func_arglist -> .)
    ID              reduce using rule 77 (func_arglist -> .)
    CHAR            reduce using rule 77 (func_arglist -> .)
    DOUBLE          reduce using rule 77 (func_arglist -> .)
    FLOAT           reduce using rule 77 (func_arglist -> .)
    INT             reduce using rule 77 (func_arglist -> .)
    VOID            reduce using rule 77 (func_arglist -> .)
    UINT8_T         reduce using rule 77 (func_arglist -> .)
    UINT16_T        reduce using rule 77 (func_arglist -> .)
    LPAREN          reduce using rule 77 (func_arglist -> .)
    SIZEOF          reduce using rule 77 (func_arglist -> .)
    FLOAT_L         reduce using rule 77 (func_arglist -> .)
    INT_L           reduce using rule 77 (func_arglist -> .)
    CHAR_L          reduce using rule 77 (func_arglist -> .)
    STRING_L        reduce using rule 77 (func_arglist -> .)
    NONDECIMAL_L    reduce using rule 77 (func_arglist -> .)
    BITAND          reduce using rule 77 (func_arglist -> .)
    STRUCT          reduce using rule 77 (func_arglist -> .)

    func_arglist                   shift and go to state 137

state 69

    (97) expression -> LPAREN expression . RPAREN
    (114) operand -> expression .

    RPAREN          shift and go to state 138
    PLUS            reduce using rule 114 (operand -> expression .)
    MINUS           reduce using rule 114 (operand -> expression .)
    ASTERISK        reduce using rule 114 (operand -> expression .)
    DIVIDE          reduce using rule 114 (operand -> expression .)
    LSHIFT          reduce using rule 114 (operand -> expression .)
    RSHIFT          reduce using rule 114 (operand -> expression .)
    PERCENT         reduce using rule 114 (operand -> expression .)
    BITAND          reduce using rule 114 (operand -> expression .)
    BITOR           reduce using rule 114 (operand -> expression .)
    EQ              reduce using rule 114 (operand -> expression .)
    NEQ             reduce using rule 114 (operand -> expression .)
    LT              reduce using rule 114 (operand -> expression .)
    GT              reduce using rule 114 (operand -> expression .)
    LE              reduce using rule 114 (operand -> expression .)
    GE              reduce using rule 114 (operand -> expression .)
    AND             reduce using rule 114 (operand -> expression .)
    OR              reduce using rule 114 (operand -> expression .)


state 70

    (98) expression -> LPAREN name . RPAREN
    (118) expression -> name . INCREMENT
    (113) operand -> name .
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

    RPAREN          shift and go to state 139
    INCREMENT       shift and go to state 100
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITAND          reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              reduce using rule 113 (operand -> name .)
    NEQ             reduce using rule 113 (operand -> name .)
    LT              reduce using rule 113 (operand -> name .)
    GT              reduce using rule 113 (operand -> name .)
    LE              reduce using rule 113 (operand -> name .)
    GE              reduce using rule 113 (operand -> name .)
    AND             reduce using rule 113 (operand -> name .)
    OR              reduce using rule 113 (operand -> name .)
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103


state 71

    (19) type_cast -> LPAREN dtype . RPAREN
    (41) dtype -> dtype . ASTERISK

    RPAREN          shift and go to state 140
    ASTERISK        shift and go to state 67


state 72

    (42) name -> ID .
    (40) dtype -> ID .
    (82) func_call -> ID . LPAREN func_arglist RPAREN

  ! reduce/reduce conflict for RPAREN resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for ASTERISK resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for FLOAT_L resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for INT_L resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for CHAR_L resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for STRING_L resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for NONDECIMAL_L resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for BITAND resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for CHAR resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for INT resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for VOID resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for UINT8_T resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for UINT16_T resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for LPAREN resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for SIZEOF resolved using rule 40 (dtype -> ID .)
  ! reduce/reduce conflict for STRUCT resolved using rule 40 (dtype -> ID .)
  ! shift/reduce conflict for LPAREN resolved as shift
    INCREMENT       reduce using rule 42 (name -> ID .)
    LBRACK          reduce using rule 42 (name -> ID .)
    MEMBER          reduce using rule 42 (name -> ID .)
    PLUS            reduce using rule 42 (name -> ID .)
    MINUS           reduce using rule 42 (name -> ID .)
    DIVIDE          reduce using rule 42 (name -> ID .)
    LSHIFT          reduce using rule 42 (name -> ID .)
    RSHIFT          reduce using rule 42 (name -> ID .)
    PERCENT         reduce using rule 42 (name -> ID .)
    BITOR           reduce using rule 42 (name -> ID .)
    EQ              reduce using rule 42 (name -> ID .)
    NEQ             reduce using rule 42 (name -> ID .)
    LT              reduce using rule 42 (name -> ID .)
    GT              reduce using rule 42 (name -> ID .)
    LE              reduce using rule 42 (name -> ID .)
    GE              reduce using rule 42 (name -> ID .)
    AND             reduce using rule 42 (name -> ID .)
    OR              reduce using rule 42 (name -> ID .)
    RPAREN          reduce using rule 40 (dtype -> ID .)
    ASTERISK        reduce using rule 40 (dtype -> ID .)
    ID              reduce using rule 40 (dtype -> ID .)
    FLOAT_L         reduce using rule 40 (dtype -> ID .)
    INT_L           reduce using rule 40 (dtype -> ID .)
    CHAR_L          reduce using rule 40 (dtype -> ID .)
    STRING_L        reduce using rule 40 (dtype -> ID .)
    NONDECIMAL_L    reduce using rule 40 (dtype -> ID .)
    BITAND          reduce using rule 40 (dtype -> ID .)
    COMMA           reduce using rule 40 (dtype -> ID .)
    CHAR            reduce using rule 40 (dtype -> ID .)
    DOUBLE          reduce using rule 40 (dtype -> ID .)
    FLOAT           reduce using rule 40 (dtype -> ID .)
    INT             reduce using rule 40 (dtype -> ID .)
    VOID            reduce using rule 40 (dtype -> ID .)
    UINT8_T         reduce using rule 40 (dtype -> ID .)
    UINT16_T        reduce using rule 40 (dtype -> ID .)
    SIZEOF          reduce using rule 40 (dtype -> ID .)
    STRUCT          reduce using rule 40 (dtype -> ID .)
    LPAREN          shift and go to state 141

  ! RPAREN          [ reduce using rule 42 (name -> ID .) ]
  ! ASTERISK        [ reduce using rule 42 (name -> ID .) ]
  ! BITAND          [ reduce using rule 42 (name -> ID .) ]
  ! COMMA           [ reduce using rule 42 (name -> ID .) ]
  ! ID              [ reduce using rule 42 (name -> ID .) ]
  ! CHAR            [ reduce using rule 42 (name -> ID .) ]
  ! DOUBLE          [ reduce using rule 42 (name -> ID .) ]
  ! FLOAT           [ reduce using rule 42 (name -> ID .) ]
  ! INT             [ reduce using rule 42 (name -> ID .) ]
  ! VOID            [ reduce using rule 42 (name -> ID .) ]
  ! UINT8_T         [ reduce using rule 42 (name -> ID .) ]
  ! UINT16_T        [ reduce using rule 42 (name -> ID .) ]
  ! LPAREN          [ reduce using rule 42 (name -> ID .) ]
  ! SIZEOF          [ reduce using rule 42 (name -> ID .) ]
  ! FLOAT_L         [ reduce using rule 42 (name -> ID .) ]
  ! INT_L           [ reduce using rule 42 (name -> ID .) ]
  ! CHAR_L          [ reduce using rule 42 (name -> ID .) ]
  ! STRING_L        [ reduce using rule 42 (name -> ID .) ]
  ! NONDECIMAL_L    [ reduce using rule 42 (name -> ID .) ]
  ! STRUCT          [ reduce using rule 42 (name -> ID .) ]
  ! LPAREN          [ reduce using rule 40 (dtype -> ID .) ]


state 73

    (116) operand -> func_call .

    PLUS            reduce using rule 116 (operand -> func_call .)
    MINUS           reduce using rule 116 (operand -> func_call .)
    ASTERISK        reduce using rule 116 (operand -> func_call .)
    DIVIDE          reduce using rule 116 (operand -> func_call .)
    LSHIFT          reduce using rule 116 (operand -> func_call .)
    RSHIFT          reduce using rule 116 (operand -> func_call .)
    PERCENT         reduce using rule 116 (operand -> func_call .)
    BITAND          reduce using rule 116 (operand -> func_call .)
    BITOR           reduce using rule 116 (operand -> func_call .)
    EQ              reduce using rule 116 (operand -> func_call .)
    NEQ             reduce using rule 116 (operand -> func_call .)
    LT              reduce using rule 116 (operand -> func_call .)
    GT              reduce using rule 116 (operand -> func_call .)
    LE              reduce using rule 116 (operand -> func_call .)
    GE              reduce using rule 116 (operand -> func_call .)
    AND             reduce using rule 116 (operand -> func_call .)
    OR              reduce using rule 116 (operand -> func_call .)
    SEMI            reduce using rule 116 (operand -> func_call .)
    RPAREN          reduce using rule 116 (operand -> func_call .)
    RBRACK          reduce using rule 116 (operand -> func_call .)
    COMMA           reduce using rule 116 (operand -> func_call .)
    ID              reduce using rule 116 (operand -> func_call .)
    CHAR            reduce using rule 116 (operand -> func_call .)
    DOUBLE          reduce using rule 116 (operand -> func_call .)
    FLOAT           reduce using rule 116 (operand -> func_call .)
    INT             reduce using rule 116 (operand -> func_call .)
    VOID            reduce using rule 116 (operand -> func_call .)
    UINT8_T         reduce using rule 116 (operand -> func_call .)
    UINT16_T        reduce using rule 116 (operand -> func_call .)
    LPAREN          reduce using rule 116 (operand -> func_call .)
    SIZEOF          reduce using rule 116 (operand -> func_call .)
    FLOAT_L         reduce using rule 116 (operand -> func_call .)
    INT_L           reduce using rule 116 (operand -> func_call .)
    CHAR_L          reduce using rule 116 (operand -> func_call .)
    STRING_L        reduce using rule 116 (operand -> func_call .)
    NONDECIMAL_L    reduce using rule 116 (operand -> func_call .)
    STRUCT          reduce using rule 116 (operand -> func_call .)


state 74

    (18) struct_type -> STRUCT . name
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    ID              shift and go to state 134
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    name                           shift and go to state 82
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 75

    (94) statement -> expression SEMI .

    INCLUDE         reduce using rule 94 (statement -> expression SEMI .)
    DEFINE          reduce using rule 94 (statement -> expression SEMI .)
    IFNDEF          reduce using rule 94 (statement -> expression SEMI .)
    ENDIF           reduce using rule 94 (statement -> expression SEMI .)
    ID              reduce using rule 94 (statement -> expression SEMI .)
    STRUCT          reduce using rule 94 (statement -> expression SEMI .)
    CHAR            reduce using rule 94 (statement -> expression SEMI .)
    DOUBLE          reduce using rule 94 (statement -> expression SEMI .)
    FLOAT           reduce using rule 94 (statement -> expression SEMI .)
    INT             reduce using rule 94 (statement -> expression SEMI .)
    VOID            reduce using rule 94 (statement -> expression SEMI .)
    UINT8_T         reduce using rule 94 (statement -> expression SEMI .)
    UINT16_T        reduce using rule 94 (statement -> expression SEMI .)
    LPAREN          reduce using rule 94 (statement -> expression SEMI .)
    NEGATE          reduce using rule 94 (statement -> expression SEMI .)
    MINUS           reduce using rule 94 (statement -> expression SEMI .)
    SIZEOF          reduce using rule 94 (statement -> expression SEMI .)
    RETURN          reduce using rule 94 (statement -> expression SEMI .)
    WHILE           reduce using rule 94 (statement -> expression SEMI .)
    IF              reduce using rule 94 (statement -> expression SEMI .)
    ELSE            reduce using rule 94 (statement -> expression SEMI .)
    FOR             reduce using rule 94 (statement -> expression SEMI .)
    CONST           reduce using rule 94 (statement -> expression SEMI .)
    EXTERN          reduce using rule 94 (statement -> expression SEMI .)
    INLINE          reduce using rule 94 (statement -> expression SEMI .)
    LONG            reduce using rule 94 (statement -> expression SEMI .)
    SHORT           reduce using rule 94 (statement -> expression SEMI .)
    SIGNED          reduce using rule 94 (statement -> expression SEMI .)
    UNSIGNED        reduce using rule 94 (statement -> expression SEMI .)
    VOLATILE        reduce using rule 94 (statement -> expression SEMI .)
    FLOAT_L         reduce using rule 94 (statement -> expression SEMI .)
    INT_L           reduce using rule 94 (statement -> expression SEMI .)
    CHAR_L          reduce using rule 94 (statement -> expression SEMI .)
    STRING_L        reduce using rule 94 (statement -> expression SEMI .)
    NONDECIMAL_L    reduce using rule 94 (statement -> expression SEMI .)
    BITAND          reduce using rule 94 (statement -> expression SEMI .)
    $end            reduce using rule 94 (statement -> expression SEMI .)
    RBRACE          reduce using rule 94 (statement -> expression SEMI .)


state 76

    (95) statement -> func_call SEMI .

    INCLUDE         reduce using rule 95 (statement -> func_call SEMI .)
    DEFINE          reduce using rule 95 (statement -> func_call SEMI .)
    IFNDEF          reduce using rule 95 (statement -> func_call SEMI .)
    ENDIF           reduce using rule 95 (statement -> func_call SEMI .)
    ID              reduce using rule 95 (statement -> func_call SEMI .)
    STRUCT          reduce using rule 95 (statement -> func_call SEMI .)
    CHAR            reduce using rule 95 (statement -> func_call SEMI .)
    DOUBLE          reduce using rule 95 (statement -> func_call SEMI .)
    FLOAT           reduce using rule 95 (statement -> func_call SEMI .)
    INT             reduce using rule 95 (statement -> func_call SEMI .)
    VOID            reduce using rule 95 (statement -> func_call SEMI .)
    UINT8_T         reduce using rule 95 (statement -> func_call SEMI .)
    UINT16_T        reduce using rule 95 (statement -> func_call SEMI .)
    LPAREN          reduce using rule 95 (statement -> func_call SEMI .)
    NEGATE          reduce using rule 95 (statement -> func_call SEMI .)
    MINUS           reduce using rule 95 (statement -> func_call SEMI .)
    SIZEOF          reduce using rule 95 (statement -> func_call SEMI .)
    RETURN          reduce using rule 95 (statement -> func_call SEMI .)
    WHILE           reduce using rule 95 (statement -> func_call SEMI .)
    IF              reduce using rule 95 (statement -> func_call SEMI .)
    ELSE            reduce using rule 95 (statement -> func_call SEMI .)
    FOR             reduce using rule 95 (statement -> func_call SEMI .)
    CONST           reduce using rule 95 (statement -> func_call SEMI .)
    EXTERN          reduce using rule 95 (statement -> func_call SEMI .)
    INLINE          reduce using rule 95 (statement -> func_call SEMI .)
    LONG            reduce using rule 95 (statement -> func_call SEMI .)
    SHORT           reduce using rule 95 (statement -> func_call SEMI .)
    SIGNED          reduce using rule 95 (statement -> func_call SEMI .)
    UNSIGNED        reduce using rule 95 (statement -> func_call SEMI .)
    VOLATILE        reduce using rule 95 (statement -> func_call SEMI .)
    FLOAT_L         reduce using rule 95 (statement -> func_call SEMI .)
    INT_L           reduce using rule 95 (statement -> func_call SEMI .)
    CHAR_L          reduce using rule 95 (statement -> func_call SEMI .)
    STRING_L        reduce using rule 95 (statement -> func_call SEMI .)
    NONDECIMAL_L    reduce using rule 95 (statement -> func_call SEMI .)
    BITAND          reduce using rule 95 (statement -> func_call SEMI .)
    $end            reduce using rule 95 (statement -> func_call SEMI .)
    RBRACE          reduce using rule 95 (statement -> func_call SEMI .)


state 77

    (96) statement -> return SEMI .

    INCLUDE         reduce using rule 96 (statement -> return SEMI .)
    DEFINE          reduce using rule 96 (statement -> return SEMI .)
    IFNDEF          reduce using rule 96 (statement -> return SEMI .)
    ENDIF           reduce using rule 96 (statement -> return SEMI .)
    ID              reduce using rule 96 (statement -> return SEMI .)
    STRUCT          reduce using rule 96 (statement -> return SEMI .)
    CHAR            reduce using rule 96 (statement -> return SEMI .)
    DOUBLE          reduce using rule 96 (statement -> return SEMI .)
    FLOAT           reduce using rule 96 (statement -> return SEMI .)
    INT             reduce using rule 96 (statement -> return SEMI .)
    VOID            reduce using rule 96 (statement -> return SEMI .)
    UINT8_T         reduce using rule 96 (statement -> return SEMI .)
    UINT16_T        reduce using rule 96 (statement -> return SEMI .)
    LPAREN          reduce using rule 96 (statement -> return SEMI .)
    NEGATE          reduce using rule 96 (statement -> return SEMI .)
    MINUS           reduce using rule 96 (statement -> return SEMI .)
    SIZEOF          reduce using rule 96 (statement -> return SEMI .)
    RETURN          reduce using rule 96 (statement -> return SEMI .)
    WHILE           reduce using rule 96 (statement -> return SEMI .)
    IF              reduce using rule 96 (statement -> return SEMI .)
    ELSE            reduce using rule 96 (statement -> return SEMI .)
    FOR             reduce using rule 96 (statement -> return SEMI .)
    CONST           reduce using rule 96 (statement -> return SEMI .)
    EXTERN          reduce using rule 96 (statement -> return SEMI .)
    INLINE          reduce using rule 96 (statement -> return SEMI .)
    LONG            reduce using rule 96 (statement -> return SEMI .)
    SHORT           reduce using rule 96 (statement -> return SEMI .)
    SIGNED          reduce using rule 96 (statement -> return SEMI .)
    UNSIGNED        reduce using rule 96 (statement -> return SEMI .)
    VOLATILE        reduce using rule 96 (statement -> return SEMI .)
    FLOAT_L         reduce using rule 96 (statement -> return SEMI .)
    INT_L           reduce using rule 96 (statement -> return SEMI .)
    CHAR_L          reduce using rule 96 (statement -> return SEMI .)
    STRING_L        reduce using rule 96 (statement -> return SEMI .)
    NONDECIMAL_L    reduce using rule 96 (statement -> return SEMI .)
    BITAND          reduce using rule 96 (statement -> return SEMI .)
    $end            reduce using rule 96 (statement -> return SEMI .)
    RBRACE          reduce using rule 96 (statement -> return SEMI .)


state 78

    (67) control_expr -> control LPAREN . conditional_expr RPAREN LBRACE node_list RBRACE
    (60) conditional_expr -> . name conditional expression
    (61) conditional_expr -> . expression conditional name
    (62) conditional_expr -> . expression conditional expression
    (63) conditional_expr -> . name conditional name
    (64) conditional_expr -> . name
    (65) conditional_expr -> . expression
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN

    ID              shift and go to state 90
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    SIZEOF          shift and go to state 42

    conditional_expr               shift and go to state 142
    name                           shift and go to state 143
    expression                     shift and go to state 144
    literal                        shift and go to state 50
    access                         shift and go to state 51
    operand                        shift and go to state 41
    type_cast                      shift and go to state 49
    func_call                      shift and go to state 73

state 79

    (68) control_expr -> control LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    SIZEOF          reduce using rule 1 (node_list -> .)
    RETURN          reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)
    BITAND          reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 145

state 80

    (69) control_expr -> for_loop LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    SIZEOF          reduce using rule 1 (node_list -> .)
    RETURN          reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)
    BITAND          reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 146

state 81

    (89) struct_def -> STRUCT ID . LBRACE node_list RBRACE SEMI
    (42) name -> ID .

    LBRACE          shift and go to state 147
    LBRACK          reduce using rule 42 (name -> ID .)
    MEMBER          reduce using rule 42 (name -> ID .)
    ID              reduce using rule 42 (name -> ID .)
    ASTERISK        reduce using rule 42 (name -> ID .)


state 82

    (18) struct_type -> STRUCT name .
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

    ID              reduce using rule 18 (struct_type -> STRUCT name .)
    ASTERISK        reduce using rule 18 (struct_type -> STRUCT name .)
    RPAREN          reduce using rule 18 (struct_type -> STRUCT name .)
    FLOAT_L         reduce using rule 18 (struct_type -> STRUCT name .)
    INT_L           reduce using rule 18 (struct_type -> STRUCT name .)
    CHAR_L          reduce using rule 18 (struct_type -> STRUCT name .)
    STRING_L        reduce using rule 18 (struct_type -> STRUCT name .)
    NONDECIMAL_L    reduce using rule 18 (struct_type -> STRUCT name .)
    BITAND          reduce using rule 18 (struct_type -> STRUCT name .)
    COMMA           reduce using rule 18 (struct_type -> STRUCT name .)
    CHAR            reduce using rule 18 (struct_type -> STRUCT name .)
    DOUBLE          reduce using rule 18 (struct_type -> STRUCT name .)
    FLOAT           reduce using rule 18 (struct_type -> STRUCT name .)
    INT             reduce using rule 18 (struct_type -> STRUCT name .)
    VOID            reduce using rule 18 (struct_type -> STRUCT name .)
    UINT8_T         reduce using rule 18 (struct_type -> STRUCT name .)
    UINT16_T        reduce using rule 18 (struct_type -> STRUCT name .)
    LPAREN          reduce using rule 18 (struct_type -> STRUCT name .)
    SIZEOF          reduce using rule 18 (struct_type -> STRUCT name .)
    STRUCT          reduce using rule 18 (struct_type -> STRUCT name .)
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103


state 83

    (139) init_var -> init_var_ls init_var_rs .

    INCLUDE         reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    DEFINE          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    IFNDEF          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    ENDIF           reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    ID              reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    STRUCT          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    CHAR            reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    DOUBLE          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    FLOAT           reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    INT             reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    VOID            reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    UINT8_T         reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    UINT16_T        reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    LPAREN          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    NEGATE          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    MINUS           reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    SIZEOF          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    RETURN          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    WHILE           reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    IF              reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    ELSE            reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    FOR             reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    CONST           reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    EXTERN          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    INLINE          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    LONG            reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    SHORT           reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    SIGNED          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    UNSIGNED        reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    VOLATILE        reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    FLOAT_L         reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    INT_L           reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    CHAR_L          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    STRING_L        reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    NONDECIMAL_L    reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    BITAND          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    $end            reduce using rule 139 (init_var -> init_var_ls init_var_rs .)
    RBRACE          reduce using rule 139 (init_var -> init_var_ls init_var_rs .)


state 84

    (133) init_var_rs -> name . SEMI
    (118) expression -> name . INCREMENT
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name
    (113) operand -> name .

    SEMI            shift and go to state 148
    INCREMENT       shift and go to state 100
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITAND          reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              reduce using rule 113 (operand -> name .)
    NEQ             reduce using rule 113 (operand -> name .)
    LT              reduce using rule 113 (operand -> name .)
    GT              reduce using rule 113 (operand -> name .)
    LE              reduce using rule 113 (operand -> name .)
    GE              reduce using rule 113 (operand -> name .)
    AND             reduce using rule 113 (operand -> name .)
    OR              reduce using rule 113 (operand -> name .)


state 85

    (134) init_var_rs -> func_call . SEMI
    (116) operand -> func_call .

    SEMI            shift and go to state 149
    PLUS            reduce using rule 116 (operand -> func_call .)
    MINUS           reduce using rule 116 (operand -> func_call .)
    ASTERISK        reduce using rule 116 (operand -> func_call .)
    DIVIDE          reduce using rule 116 (operand -> func_call .)
    LSHIFT          reduce using rule 116 (operand -> func_call .)
    RSHIFT          reduce using rule 116 (operand -> func_call .)
    PERCENT         reduce using rule 116 (operand -> func_call .)
    BITAND          reduce using rule 116 (operand -> func_call .)
    BITOR           reduce using rule 116 (operand -> func_call .)
    EQ              reduce using rule 116 (operand -> func_call .)
    NEQ             reduce using rule 116 (operand -> func_call .)
    LT              reduce using rule 116 (operand -> func_call .)
    GT              reduce using rule 116 (operand -> func_call .)
    LE              reduce using rule 116 (operand -> func_call .)
    GE              reduce using rule 116 (operand -> func_call .)
    AND             reduce using rule 116 (operand -> func_call .)
    OR              reduce using rule 116 (operand -> func_call .)


state 86

    (135) init_var_rs -> expression . SEMI
    (114) operand -> expression .

    SEMI            shift and go to state 150
    PLUS            reduce using rule 114 (operand -> expression .)
    MINUS           reduce using rule 114 (operand -> expression .)
    ASTERISK        reduce using rule 114 (operand -> expression .)
    DIVIDE          reduce using rule 114 (operand -> expression .)
    LSHIFT          reduce using rule 114 (operand -> expression .)
    RSHIFT          reduce using rule 114 (operand -> expression .)
    PERCENT         reduce using rule 114 (operand -> expression .)
    BITAND          reduce using rule 114 (operand -> expression .)
    BITOR           reduce using rule 114 (operand -> expression .)
    EQ              reduce using rule 114 (operand -> expression .)
    NEQ             reduce using rule 114 (operand -> expression .)
    LT              reduce using rule 114 (operand -> expression .)
    GT              reduce using rule 114 (operand -> expression .)
    LE              reduce using rule 114 (operand -> expression .)
    GE              reduce using rule 114 (operand -> expression .)
    AND             reduce using rule 114 (operand -> expression .)
    OR              reduce using rule 114 (operand -> expression .)


state 87

    (136) init_var_rs -> typecast_init .

    INCLUDE         reduce using rule 136 (init_var_rs -> typecast_init .)
    DEFINE          reduce using rule 136 (init_var_rs -> typecast_init .)
    IFNDEF          reduce using rule 136 (init_var_rs -> typecast_init .)
    ENDIF           reduce using rule 136 (init_var_rs -> typecast_init .)
    ID              reduce using rule 136 (init_var_rs -> typecast_init .)
    STRUCT          reduce using rule 136 (init_var_rs -> typecast_init .)
    CHAR            reduce using rule 136 (init_var_rs -> typecast_init .)
    DOUBLE          reduce using rule 136 (init_var_rs -> typecast_init .)
    FLOAT           reduce using rule 136 (init_var_rs -> typecast_init .)
    INT             reduce using rule 136 (init_var_rs -> typecast_init .)
    VOID            reduce using rule 136 (init_var_rs -> typecast_init .)
    UINT8_T         reduce using rule 136 (init_var_rs -> typecast_init .)
    UINT16_T        reduce using rule 136 (init_var_rs -> typecast_init .)
    LPAREN          reduce using rule 136 (init_var_rs -> typecast_init .)
    NEGATE          reduce using rule 136 (init_var_rs -> typecast_init .)
    MINUS           reduce using rule 136 (init_var_rs -> typecast_init .)
    SIZEOF          reduce using rule 136 (init_var_rs -> typecast_init .)
    RETURN          reduce using rule 136 (init_var_rs -> typecast_init .)
    WHILE           reduce using rule 136 (init_var_rs -> typecast_init .)
    IF              reduce using rule 136 (init_var_rs -> typecast_init .)
    ELSE            reduce using rule 136 (init_var_rs -> typecast_init .)
    FOR             reduce using rule 136 (init_var_rs -> typecast_init .)
    CONST           reduce using rule 136 (init_var_rs -> typecast_init .)
    EXTERN          reduce using rule 136 (init_var_rs -> typecast_init .)
    INLINE          reduce using rule 136 (init_var_rs -> typecast_init .)
    LONG            reduce using rule 136 (init_var_rs -> typecast_init .)
    SHORT           reduce using rule 136 (init_var_rs -> typecast_init .)
    SIGNED          reduce using rule 136 (init_var_rs -> typecast_init .)
    UNSIGNED        reduce using rule 136 (init_var_rs -> typecast_init .)
    VOLATILE        reduce using rule 136 (init_var_rs -> typecast_init .)
    FLOAT_L         reduce using rule 136 (init_var_rs -> typecast_init .)
    INT_L           reduce using rule 136 (init_var_rs -> typecast_init .)
    CHAR_L          reduce using rule 136 (init_var_rs -> typecast_init .)
    STRING_L        reduce using rule 136 (init_var_rs -> typecast_init .)
    NONDECIMAL_L    reduce using rule 136 (init_var_rs -> typecast_init .)
    BITAND          reduce using rule 136 (init_var_rs -> typecast_init .)
    $end            reduce using rule 136 (init_var_rs -> typecast_init .)
    RBRACE          reduce using rule 136 (init_var_rs -> typecast_init .)


state 88

    (137) init_var_rs -> LPAREN . name RPAREN
    (97) expression -> LPAREN . expression RPAREN
    (98) expression -> LPAREN . name RPAREN
    (19) type_cast -> LPAREN . dtype RPAREN
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (18) struct_type -> . STRUCT name
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN

    ID              shift and go to state 72
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    STRUCT          shift and go to state 74
    SIZEOF          shift and go to state 42

    name                           shift and go to state 151
    expression                     shift and go to state 69
    dtype                          shift and go to state 71
    literal                        shift and go to state 50
    access                         shift and go to state 51
    operand                        shift and go to state 41
    struct_type                    shift and go to state 34
    type_cast                      shift and go to state 49
    func_call                      shift and go to state 73

state 89

    (138) init_var_rs -> error . SEMI

    SEMI            shift and go to state 152


state 90

    (42) name -> ID .
    (82) func_call -> ID . LPAREN func_arglist RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    SEMI            reduce using rule 42 (name -> ID .)
    INCREMENT       reduce using rule 42 (name -> ID .)
    LBRACK          reduce using rule 42 (name -> ID .)
    MEMBER          reduce using rule 42 (name -> ID .)
    PLUS            reduce using rule 42 (name -> ID .)
    MINUS           reduce using rule 42 (name -> ID .)
    ASTERISK        reduce using rule 42 (name -> ID .)
    DIVIDE          reduce using rule 42 (name -> ID .)
    LSHIFT          reduce using rule 42 (name -> ID .)
    RSHIFT          reduce using rule 42 (name -> ID .)
    PERCENT         reduce using rule 42 (name -> ID .)
    BITAND          reduce using rule 42 (name -> ID .)
    BITOR           reduce using rule 42 (name -> ID .)
    EQ              reduce using rule 42 (name -> ID .)
    NEQ             reduce using rule 42 (name -> ID .)
    LT              reduce using rule 42 (name -> ID .)
    GT              reduce using rule 42 (name -> ID .)
    LE              reduce using rule 42 (name -> ID .)
    GE              reduce using rule 42 (name -> ID .)
    AND             reduce using rule 42 (name -> ID .)
    OR              reduce using rule 42 (name -> ID .)
    RPAREN          reduce using rule 42 (name -> ID .)
    RBRACK          reduce using rule 42 (name -> ID .)
    COMMA           reduce using rule 42 (name -> ID .)
    ID              reduce using rule 42 (name -> ID .)
    CHAR            reduce using rule 42 (name -> ID .)
    DOUBLE          reduce using rule 42 (name -> ID .)
    FLOAT           reduce using rule 42 (name -> ID .)
    INT             reduce using rule 42 (name -> ID .)
    VOID            reduce using rule 42 (name -> ID .)
    UINT8_T         reduce using rule 42 (name -> ID .)
    UINT16_T        reduce using rule 42 (name -> ID .)
    SIZEOF          reduce using rule 42 (name -> ID .)
    FLOAT_L         reduce using rule 42 (name -> ID .)
    INT_L           reduce using rule 42 (name -> ID .)
    CHAR_L          reduce using rule 42 (name -> ID .)
    STRING_L        reduce using rule 42 (name -> ID .)
    NONDECIMAL_L    reduce using rule 42 (name -> ID .)
    STRUCT          reduce using rule 42 (name -> ID .)
    LPAREN          shift and go to state 141

  ! LPAREN          [ reduce using rule 42 (name -> ID .) ]


state 91

    (132) typecast_init -> type_cast . init_var_rs
    (115) operand -> type_cast . name
    (133) init_var_rs -> . name SEMI
    (134) init_var_rs -> . func_call SEMI
    (135) init_var_rs -> . expression SEMI
    (136) init_var_rs -> . typecast_init
    (137) init_var_rs -> . LPAREN name RPAREN
    (138) init_var_rs -> . error SEMI
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (132) typecast_init -> . type_cast init_var_rs
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (19) type_cast -> . LPAREN dtype RPAREN

    LPAREN          shift and go to state 88
    error           shift and go to state 89
    ID              shift and go to state 90
    SIZEOF          shift and go to state 42
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    type_cast                      shift and go to state 91
    init_var_rs                    shift and go to state 153
    name                           shift and go to state 154
    func_call                      shift and go to state 85
    expression                     shift and go to state 86
    typecast_init                  shift and go to state 87
    literal                        shift and go to state 50
    access                         shift and go to state 51
    operand                        shift and go to state 41

state 92

    (142) assign_var -> assign_var_ls assign_var_rs .

    INCLUDE         reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    DEFINE          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    IFNDEF          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    ENDIF           reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    ID              reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    STRUCT          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    CHAR            reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    DOUBLE          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    FLOAT           reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    INT             reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    VOID            reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    UINT8_T         reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    UINT16_T        reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    LPAREN          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    NEGATE          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    MINUS           reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    SIZEOF          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    RETURN          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    WHILE           reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    IF              reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    ELSE            reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    FOR             reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    CONST           reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    EXTERN          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    INLINE          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    LONG            reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    SHORT           reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    SIGNED          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    UNSIGNED        reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    VOLATILE        reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    FLOAT_L         reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    INT_L           reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    CHAR_L          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    STRING_L        reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    NONDECIMAL_L    reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    BITAND          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    $end            reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)
    RBRACE          reduce using rule 142 (assign_var -> assign_var_ls assign_var_rs .)


state 93

    (141) assign_var_rs -> init_var_rs .

    INCLUDE         reduce using rule 141 (assign_var_rs -> init_var_rs .)
    DEFINE          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    IFNDEF          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    ENDIF           reduce using rule 141 (assign_var_rs -> init_var_rs .)
    ID              reduce using rule 141 (assign_var_rs -> init_var_rs .)
    STRUCT          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    CHAR            reduce using rule 141 (assign_var_rs -> init_var_rs .)
    DOUBLE          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    FLOAT           reduce using rule 141 (assign_var_rs -> init_var_rs .)
    INT             reduce using rule 141 (assign_var_rs -> init_var_rs .)
    VOID            reduce using rule 141 (assign_var_rs -> init_var_rs .)
    UINT8_T         reduce using rule 141 (assign_var_rs -> init_var_rs .)
    UINT16_T        reduce using rule 141 (assign_var_rs -> init_var_rs .)
    LPAREN          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    NEGATE          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    MINUS           reduce using rule 141 (assign_var_rs -> init_var_rs .)
    SIZEOF          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    RETURN          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    WHILE           reduce using rule 141 (assign_var_rs -> init_var_rs .)
    IF              reduce using rule 141 (assign_var_rs -> init_var_rs .)
    ELSE            reduce using rule 141 (assign_var_rs -> init_var_rs .)
    FOR             reduce using rule 141 (assign_var_rs -> init_var_rs .)
    CONST           reduce using rule 141 (assign_var_rs -> init_var_rs .)
    EXTERN          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    INLINE          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    LONG            reduce using rule 141 (assign_var_rs -> init_var_rs .)
    SHORT           reduce using rule 141 (assign_var_rs -> init_var_rs .)
    SIGNED          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    UNSIGNED        reduce using rule 141 (assign_var_rs -> init_var_rs .)
    VOLATILE        reduce using rule 141 (assign_var_rs -> init_var_rs .)
    FLOAT_L         reduce using rule 141 (assign_var_rs -> init_var_rs .)
    INT_L           reduce using rule 141 (assign_var_rs -> init_var_rs .)
    CHAR_L          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    STRING_L        reduce using rule 141 (assign_var_rs -> init_var_rs .)
    NONDECIMAL_L    reduce using rule 141 (assign_var_rs -> init_var_rs .)
    BITAND          reduce using rule 141 (assign_var_rs -> init_var_rs .)
    $end            reduce using rule 141 (assign_var_rs -> init_var_rs .)
    RBRACE          reduce using rule 141 (assign_var_rs -> init_var_rs .)


state 94

    (125) declare_var -> declare_var_ls SEMI .

    INCLUDE         reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    DEFINE          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    IFNDEF          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    ENDIF           reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    ID              reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    STRUCT          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    CHAR            reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    DOUBLE          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    FLOAT           reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    INT             reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    VOID            reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    UINT8_T         reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    UINT16_T        reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    LPAREN          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    NEGATE          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    MINUS           reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    SIZEOF          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    RETURN          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    WHILE           reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    IF              reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    ELSE            reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    FOR             reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    CONST           reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    EXTERN          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    INLINE          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    LONG            reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    SHORT           reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    SIGNED          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    UNSIGNED        reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    VOLATILE        reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    FLOAT_L         reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    INT_L           reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    CHAR_L          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    STRING_L        reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    NONDECIMAL_L    reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    BITAND          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    $end            reduce using rule 125 (declare_var -> declare_var_ls SEMI .)
    RBRACE          reduce using rule 125 (declare_var -> declare_var_ls SEMI .)


state 95

    (130) init_var_ls -> declare_var_ls assign .

    LPAREN          reduce using rule 130 (init_var_ls -> declare_var_ls assign .)
    error           reduce using rule 130 (init_var_ls -> declare_var_ls assign .)
    ID              reduce using rule 130 (init_var_ls -> declare_var_ls assign .)
    SIZEOF          reduce using rule 130 (init_var_ls -> declare_var_ls assign .)
    NEGATE          reduce using rule 130 (init_var_ls -> declare_var_ls assign .)
    MINUS           reduce using rule 130 (init_var_ls -> declare_var_ls assign .)
    FLOAT_L         reduce using rule 130 (init_var_ls -> declare_var_ls assign .)
    INT_L           reduce using rule 130 (init_var_ls -> declare_var_ls assign .)
    CHAR_L          reduce using rule 130 (init_var_ls -> declare_var_ls assign .)
    STRING_L        reduce using rule 130 (init_var_ls -> declare_var_ls assign .)
    NONDECIMAL_L    reduce using rule 130 (init_var_ls -> declare_var_ls assign .)
    BITAND          reduce using rule 130 (init_var_ls -> declare_var_ls assign .)


state 96

    (131) init_var_ls -> declare_var_ls vector_init . assign
    (16) assign -> . SIMPLE_ASSIGN
    (17) assign -> . COMPLEX_ASSIGN

    SIMPLE_ASSIGN   shift and go to state 97
    COMPLEX_ASSIGN  shift and go to state 98

    assign                         shift and go to state 155

state 97

    (16) assign -> SIMPLE_ASSIGN .

    LPAREN          reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    error           reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    ID              reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    SIZEOF          reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    NEGATE          reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    MINUS           reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    FLOAT_L         reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    INT_L           reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    CHAR_L          reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    STRING_L        reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    NONDECIMAL_L    reduce using rule 16 (assign -> SIMPLE_ASSIGN .)
    BITAND          reduce using rule 16 (assign -> SIMPLE_ASSIGN .)


state 98

    (17) assign -> COMPLEX_ASSIGN .

    LPAREN          reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    error           reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    ID              reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    SIZEOF          reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    NEGATE          reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    MINUS           reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    FLOAT_L         reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    INT_L           reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    CHAR_L          reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    STRING_L        reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    NONDECIMAL_L    reduce using rule 17 (assign -> COMPLEX_ASSIGN .)
    BITAND          reduce using rule 17 (assign -> COMPLEX_ASSIGN .)


state 99

    (126) vector_init -> LBRACK . RBRACK
    (127) vector_init -> LBRACK . name RBRACK
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    RBRACK          shift and go to state 156
    ID              shift and go to state 134
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    name                           shift and go to state 157
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 100

    (118) expression -> name INCREMENT .

    SEMI            reduce using rule 118 (expression -> name INCREMENT .)
    PLUS            reduce using rule 118 (expression -> name INCREMENT .)
    MINUS           reduce using rule 118 (expression -> name INCREMENT .)
    ASTERISK        reduce using rule 118 (expression -> name INCREMENT .)
    DIVIDE          reduce using rule 118 (expression -> name INCREMENT .)
    LSHIFT          reduce using rule 118 (expression -> name INCREMENT .)
    RSHIFT          reduce using rule 118 (expression -> name INCREMENT .)
    PERCENT         reduce using rule 118 (expression -> name INCREMENT .)
    BITAND          reduce using rule 118 (expression -> name INCREMENT .)
    BITOR           reduce using rule 118 (expression -> name INCREMENT .)
    EQ              reduce using rule 118 (expression -> name INCREMENT .)
    NEQ             reduce using rule 118 (expression -> name INCREMENT .)
    LT              reduce using rule 118 (expression -> name INCREMENT .)
    GT              reduce using rule 118 (expression -> name INCREMENT .)
    LE              reduce using rule 118 (expression -> name INCREMENT .)
    GE              reduce using rule 118 (expression -> name INCREMENT .)
    AND             reduce using rule 118 (expression -> name INCREMENT .)
    OR              reduce using rule 118 (expression -> name INCREMENT .)
    RPAREN          reduce using rule 118 (expression -> name INCREMENT .)
    RBRACK          reduce using rule 118 (expression -> name INCREMENT .)
    COMMA           reduce using rule 118 (expression -> name INCREMENT .)
    ID              reduce using rule 118 (expression -> name INCREMENT .)
    CHAR            reduce using rule 118 (expression -> name INCREMENT .)
    DOUBLE          reduce using rule 118 (expression -> name INCREMENT .)
    FLOAT           reduce using rule 118 (expression -> name INCREMENT .)
    INT             reduce using rule 118 (expression -> name INCREMENT .)
    VOID            reduce using rule 118 (expression -> name INCREMENT .)
    UINT8_T         reduce using rule 118 (expression -> name INCREMENT .)
    UINT16_T        reduce using rule 118 (expression -> name INCREMENT .)
    LPAREN          reduce using rule 118 (expression -> name INCREMENT .)
    SIZEOF          reduce using rule 118 (expression -> name INCREMENT .)
    FLOAT_L         reduce using rule 118 (expression -> name INCREMENT .)
    INT_L           reduce using rule 118 (expression -> name INCREMENT .)
    CHAR_L          reduce using rule 118 (expression -> name INCREMENT .)
    STRING_L        reduce using rule 118 (expression -> name INCREMENT .)
    NONDECIMAL_L    reduce using rule 118 (expression -> name INCREMENT .)
    STRUCT          reduce using rule 118 (expression -> name INCREMENT .)


state 101

    (140) assign_var_ls -> name assign .

    LPAREN          reduce using rule 140 (assign_var_ls -> name assign .)
    error           reduce using rule 140 (assign_var_ls -> name assign .)
    ID              reduce using rule 140 (assign_var_ls -> name assign .)
    SIZEOF          reduce using rule 140 (assign_var_ls -> name assign .)
    NEGATE          reduce using rule 140 (assign_var_ls -> name assign .)
    MINUS           reduce using rule 140 (assign_var_ls -> name assign .)
    FLOAT_L         reduce using rule 140 (assign_var_ls -> name assign .)
    INT_L           reduce using rule 140 (assign_var_ls -> name assign .)
    CHAR_L          reduce using rule 140 (assign_var_ls -> name assign .)
    STRING_L        reduce using rule 140 (assign_var_ls -> name assign .)
    NONDECIMAL_L    reduce using rule 140 (assign_var_ls -> name assign .)
    BITAND          reduce using rule 140 (assign_var_ls -> name assign .)


state 102

    (85) access -> name LBRACK . name RBRACK
    (86) access -> name LBRACK . expression RBRACK
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN

    ID              shift and go to state 90
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    SIZEOF          shift and go to state 42

    name                           shift and go to state 158
    expression                     shift and go to state 159
    literal                        shift and go to state 50
    access                         shift and go to state 51
    operand                        shift and go to state 41
    type_cast                      shift and go to state 49
    func_call                      shift and go to state 73

state 103

    (87) access -> name MEMBER . name
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    ID              shift and go to state 134
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    name                           shift and go to state 160
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 104

    (99) expression -> NEGATE expression .
    (114) operand -> expression .

  ! reduce/reduce conflict for PLUS resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for ASTERISK resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for LSHIFT resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for RSHIFT resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for PERCENT resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for BITAND resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for BITOR resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for EQ resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for NEQ resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for LT resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for GT resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for LE resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for GE resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for AND resolved using rule 99 (expression -> NEGATE expression .)
  ! reduce/reduce conflict for OR resolved using rule 99 (expression -> NEGATE expression .)
    SEMI            reduce using rule 99 (expression -> NEGATE expression .)
    PLUS            reduce using rule 99 (expression -> NEGATE expression .)
    MINUS           reduce using rule 99 (expression -> NEGATE expression .)
    ASTERISK        reduce using rule 99 (expression -> NEGATE expression .)
    DIVIDE          reduce using rule 99 (expression -> NEGATE expression .)
    LSHIFT          reduce using rule 99 (expression -> NEGATE expression .)
    RSHIFT          reduce using rule 99 (expression -> NEGATE expression .)
    PERCENT         reduce using rule 99 (expression -> NEGATE expression .)
    BITAND          reduce using rule 99 (expression -> NEGATE expression .)
    BITOR           reduce using rule 99 (expression -> NEGATE expression .)
    EQ              reduce using rule 99 (expression -> NEGATE expression .)
    NEQ             reduce using rule 99 (expression -> NEGATE expression .)
    LT              reduce using rule 99 (expression -> NEGATE expression .)
    GT              reduce using rule 99 (expression -> NEGATE expression .)
    LE              reduce using rule 99 (expression -> NEGATE expression .)
    GE              reduce using rule 99 (expression -> NEGATE expression .)
    AND             reduce using rule 99 (expression -> NEGATE expression .)
    OR              reduce using rule 99 (expression -> NEGATE expression .)
    RPAREN          reduce using rule 99 (expression -> NEGATE expression .)
    RBRACK          reduce using rule 99 (expression -> NEGATE expression .)
    COMMA           reduce using rule 99 (expression -> NEGATE expression .)
    ID              reduce using rule 99 (expression -> NEGATE expression .)
    CHAR            reduce using rule 99 (expression -> NEGATE expression .)
    DOUBLE          reduce using rule 99 (expression -> NEGATE expression .)
    FLOAT           reduce using rule 99 (expression -> NEGATE expression .)
    INT             reduce using rule 99 (expression -> NEGATE expression .)
    VOID            reduce using rule 99 (expression -> NEGATE expression .)
    UINT8_T         reduce using rule 99 (expression -> NEGATE expression .)
    UINT16_T        reduce using rule 99 (expression -> NEGATE expression .)
    LPAREN          reduce using rule 99 (expression -> NEGATE expression .)
    SIZEOF          reduce using rule 99 (expression -> NEGATE expression .)
    FLOAT_L         reduce using rule 99 (expression -> NEGATE expression .)
    INT_L           reduce using rule 99 (expression -> NEGATE expression .)
    CHAR_L          reduce using rule 99 (expression -> NEGATE expression .)
    STRING_L        reduce using rule 99 (expression -> NEGATE expression .)
    NONDECIMAL_L    reduce using rule 99 (expression -> NEGATE expression .)
    STRUCT          reduce using rule 99 (expression -> NEGATE expression .)

  ! PLUS            [ reduce using rule 114 (operand -> expression .) ]
  ! MINUS           [ reduce using rule 114 (operand -> expression .) ]
  ! ASTERISK        [ reduce using rule 114 (operand -> expression .) ]
  ! DIVIDE          [ reduce using rule 114 (operand -> expression .) ]
  ! LSHIFT          [ reduce using rule 114 (operand -> expression .) ]
  ! RSHIFT          [ reduce using rule 114 (operand -> expression .) ]
  ! PERCENT         [ reduce using rule 114 (operand -> expression .) ]
  ! BITAND          [ reduce using rule 114 (operand -> expression .) ]
  ! BITOR           [ reduce using rule 114 (operand -> expression .) ]
  ! EQ              [ reduce using rule 114 (operand -> expression .) ]
  ! NEQ             [ reduce using rule 114 (operand -> expression .) ]
  ! LT              [ reduce using rule 114 (operand -> expression .) ]
  ! GT              [ reduce using rule 114 (operand -> expression .) ]
  ! LE              [ reduce using rule 114 (operand -> expression .) ]
  ! GE              [ reduce using rule 114 (operand -> expression .) ]
  ! AND             [ reduce using rule 114 (operand -> expression .) ]
  ! OR              [ reduce using rule 114 (operand -> expression .) ]


state 105

    (101) expression -> NEGATE name .
    (118) expression -> name . INCREMENT
    (113) operand -> name .
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

  ! reduce/reduce conflict for PLUS resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for MINUS resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for ASTERISK resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for LSHIFT resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for RSHIFT resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for PERCENT resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for BITAND resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for BITOR resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for EQ resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for NEQ resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for LT resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for GT resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for LE resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for GE resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for AND resolved using rule 101 (expression -> NEGATE name .)
  ! reduce/reduce conflict for OR resolved using rule 101 (expression -> NEGATE name .)
    SEMI            reduce using rule 101 (expression -> NEGATE name .)
    PLUS            reduce using rule 101 (expression -> NEGATE name .)
    MINUS           reduce using rule 101 (expression -> NEGATE name .)
    ASTERISK        reduce using rule 101 (expression -> NEGATE name .)
    DIVIDE          reduce using rule 101 (expression -> NEGATE name .)
    LSHIFT          reduce using rule 101 (expression -> NEGATE name .)
    RSHIFT          reduce using rule 101 (expression -> NEGATE name .)
    PERCENT         reduce using rule 101 (expression -> NEGATE name .)
    BITAND          reduce using rule 101 (expression -> NEGATE name .)
    BITOR           reduce using rule 101 (expression -> NEGATE name .)
    EQ              reduce using rule 101 (expression -> NEGATE name .)
    NEQ             reduce using rule 101 (expression -> NEGATE name .)
    LT              reduce using rule 101 (expression -> NEGATE name .)
    GT              reduce using rule 101 (expression -> NEGATE name .)
    LE              reduce using rule 101 (expression -> NEGATE name .)
    GE              reduce using rule 101 (expression -> NEGATE name .)
    AND             reduce using rule 101 (expression -> NEGATE name .)
    OR              reduce using rule 101 (expression -> NEGATE name .)
    RPAREN          reduce using rule 101 (expression -> NEGATE name .)
    RBRACK          reduce using rule 101 (expression -> NEGATE name .)
    COMMA           reduce using rule 101 (expression -> NEGATE name .)
    ID              reduce using rule 101 (expression -> NEGATE name .)
    CHAR            reduce using rule 101 (expression -> NEGATE name .)
    DOUBLE          reduce using rule 101 (expression -> NEGATE name .)
    FLOAT           reduce using rule 101 (expression -> NEGATE name .)
    INT             reduce using rule 101 (expression -> NEGATE name .)
    VOID            reduce using rule 101 (expression -> NEGATE name .)
    UINT8_T         reduce using rule 101 (expression -> NEGATE name .)
    UINT16_T        reduce using rule 101 (expression -> NEGATE name .)
    LPAREN          reduce using rule 101 (expression -> NEGATE name .)
    SIZEOF          reduce using rule 101 (expression -> NEGATE name .)
    FLOAT_L         reduce using rule 101 (expression -> NEGATE name .)
    INT_L           reduce using rule 101 (expression -> NEGATE name .)
    CHAR_L          reduce using rule 101 (expression -> NEGATE name .)
    STRING_L        reduce using rule 101 (expression -> NEGATE name .)
    NONDECIMAL_L    reduce using rule 101 (expression -> NEGATE name .)
    STRUCT          reduce using rule 101 (expression -> NEGATE name .)
    INCREMENT       shift and go to state 100
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103

  ! PLUS            [ reduce using rule 113 (operand -> name .) ]
  ! MINUS           [ reduce using rule 113 (operand -> name .) ]
  ! ASTERISK        [ reduce using rule 113 (operand -> name .) ]
  ! DIVIDE          [ reduce using rule 113 (operand -> name .) ]
  ! LSHIFT          [ reduce using rule 113 (operand -> name .) ]
  ! RSHIFT          [ reduce using rule 113 (operand -> name .) ]
  ! PERCENT         [ reduce using rule 113 (operand -> name .) ]
  ! BITAND          [ reduce using rule 113 (operand -> name .) ]
  ! BITOR           [ reduce using rule 113 (operand -> name .) ]
  ! EQ              [ reduce using rule 113 (operand -> name .) ]
  ! NEQ             [ reduce using rule 113 (operand -> name .) ]
  ! LT              [ reduce using rule 113 (operand -> name .) ]
  ! GT              [ reduce using rule 113 (operand -> name .) ]
  ! LE              [ reduce using rule 113 (operand -> name .) ]
  ! GE              [ reduce using rule 113 (operand -> name .) ]
  ! AND             [ reduce using rule 113 (operand -> name .) ]
  ! OR              [ reduce using rule 113 (operand -> name .) ]


state 106

    (100) expression -> MINUS expression .
    (114) operand -> expression .

  ! reduce/reduce conflict for PLUS resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for ASTERISK resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for LSHIFT resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for RSHIFT resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for PERCENT resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for BITAND resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for BITOR resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for EQ resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for NEQ resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for LT resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for GT resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for LE resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for GE resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for AND resolved using rule 100 (expression -> MINUS expression .)
  ! reduce/reduce conflict for OR resolved using rule 100 (expression -> MINUS expression .)
    SEMI            reduce using rule 100 (expression -> MINUS expression .)
    PLUS            reduce using rule 100 (expression -> MINUS expression .)
    MINUS           reduce using rule 100 (expression -> MINUS expression .)
    ASTERISK        reduce using rule 100 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 100 (expression -> MINUS expression .)
    LSHIFT          reduce using rule 100 (expression -> MINUS expression .)
    RSHIFT          reduce using rule 100 (expression -> MINUS expression .)
    PERCENT         reduce using rule 100 (expression -> MINUS expression .)
    BITAND          reduce using rule 100 (expression -> MINUS expression .)
    BITOR           reduce using rule 100 (expression -> MINUS expression .)
    EQ              reduce using rule 100 (expression -> MINUS expression .)
    NEQ             reduce using rule 100 (expression -> MINUS expression .)
    LT              reduce using rule 100 (expression -> MINUS expression .)
    GT              reduce using rule 100 (expression -> MINUS expression .)
    LE              reduce using rule 100 (expression -> MINUS expression .)
    GE              reduce using rule 100 (expression -> MINUS expression .)
    AND             reduce using rule 100 (expression -> MINUS expression .)
    OR              reduce using rule 100 (expression -> MINUS expression .)
    RPAREN          reduce using rule 100 (expression -> MINUS expression .)
    RBRACK          reduce using rule 100 (expression -> MINUS expression .)
    COMMA           reduce using rule 100 (expression -> MINUS expression .)
    ID              reduce using rule 100 (expression -> MINUS expression .)
    CHAR            reduce using rule 100 (expression -> MINUS expression .)
    DOUBLE          reduce using rule 100 (expression -> MINUS expression .)
    FLOAT           reduce using rule 100 (expression -> MINUS expression .)
    INT             reduce using rule 100 (expression -> MINUS expression .)
    VOID            reduce using rule 100 (expression -> MINUS expression .)
    UINT8_T         reduce using rule 100 (expression -> MINUS expression .)
    UINT16_T        reduce using rule 100 (expression -> MINUS expression .)
    LPAREN          reduce using rule 100 (expression -> MINUS expression .)
    SIZEOF          reduce using rule 100 (expression -> MINUS expression .)
    FLOAT_L         reduce using rule 100 (expression -> MINUS expression .)
    INT_L           reduce using rule 100 (expression -> MINUS expression .)
    CHAR_L          reduce using rule 100 (expression -> MINUS expression .)
    STRING_L        reduce using rule 100 (expression -> MINUS expression .)
    NONDECIMAL_L    reduce using rule 100 (expression -> MINUS expression .)
    STRUCT          reduce using rule 100 (expression -> MINUS expression .)

  ! PLUS            [ reduce using rule 114 (operand -> expression .) ]
  ! MINUS           [ reduce using rule 114 (operand -> expression .) ]
  ! ASTERISK        [ reduce using rule 114 (operand -> expression .) ]
  ! DIVIDE          [ reduce using rule 114 (operand -> expression .) ]
  ! LSHIFT          [ reduce using rule 114 (operand -> expression .) ]
  ! RSHIFT          [ reduce using rule 114 (operand -> expression .) ]
  ! PERCENT         [ reduce using rule 114 (operand -> expression .) ]
  ! BITAND          [ reduce using rule 114 (operand -> expression .) ]
  ! BITOR           [ reduce using rule 114 (operand -> expression .) ]
  ! EQ              [ reduce using rule 114 (operand -> expression .) ]
  ! NEQ             [ reduce using rule 114 (operand -> expression .) ]
  ! LT              [ reduce using rule 114 (operand -> expression .) ]
  ! GT              [ reduce using rule 114 (operand -> expression .) ]
  ! LE              [ reduce using rule 114 (operand -> expression .) ]
  ! GE              [ reduce using rule 114 (operand -> expression .) ]
  ! AND             [ reduce using rule 114 (operand -> expression .) ]
  ! OR              [ reduce using rule 114 (operand -> expression .) ]


state 107

    (102) expression -> MINUS name .
    (118) expression -> name . INCREMENT
    (113) operand -> name .
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

  ! reduce/reduce conflict for PLUS resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for MINUS resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for ASTERISK resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for LSHIFT resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for RSHIFT resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for PERCENT resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for BITAND resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for BITOR resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for EQ resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for NEQ resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for LT resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for GT resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for LE resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for GE resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for AND resolved using rule 102 (expression -> MINUS name .)
  ! reduce/reduce conflict for OR resolved using rule 102 (expression -> MINUS name .)
    SEMI            reduce using rule 102 (expression -> MINUS name .)
    PLUS            reduce using rule 102 (expression -> MINUS name .)
    MINUS           reduce using rule 102 (expression -> MINUS name .)
    ASTERISK        reduce using rule 102 (expression -> MINUS name .)
    DIVIDE          reduce using rule 102 (expression -> MINUS name .)
    LSHIFT          reduce using rule 102 (expression -> MINUS name .)
    RSHIFT          reduce using rule 102 (expression -> MINUS name .)
    PERCENT         reduce using rule 102 (expression -> MINUS name .)
    BITAND          reduce using rule 102 (expression -> MINUS name .)
    BITOR           reduce using rule 102 (expression -> MINUS name .)
    EQ              reduce using rule 102 (expression -> MINUS name .)
    NEQ             reduce using rule 102 (expression -> MINUS name .)
    LT              reduce using rule 102 (expression -> MINUS name .)
    GT              reduce using rule 102 (expression -> MINUS name .)
    LE              reduce using rule 102 (expression -> MINUS name .)
    GE              reduce using rule 102 (expression -> MINUS name .)
    AND             reduce using rule 102 (expression -> MINUS name .)
    OR              reduce using rule 102 (expression -> MINUS name .)
    RPAREN          reduce using rule 102 (expression -> MINUS name .)
    RBRACK          reduce using rule 102 (expression -> MINUS name .)
    COMMA           reduce using rule 102 (expression -> MINUS name .)
    ID              reduce using rule 102 (expression -> MINUS name .)
    CHAR            reduce using rule 102 (expression -> MINUS name .)
    DOUBLE          reduce using rule 102 (expression -> MINUS name .)
    FLOAT           reduce using rule 102 (expression -> MINUS name .)
    INT             reduce using rule 102 (expression -> MINUS name .)
    VOID            reduce using rule 102 (expression -> MINUS name .)
    UINT8_T         reduce using rule 102 (expression -> MINUS name .)
    UINT16_T        reduce using rule 102 (expression -> MINUS name .)
    LPAREN          reduce using rule 102 (expression -> MINUS name .)
    SIZEOF          reduce using rule 102 (expression -> MINUS name .)
    FLOAT_L         reduce using rule 102 (expression -> MINUS name .)
    INT_L           reduce using rule 102 (expression -> MINUS name .)
    CHAR_L          reduce using rule 102 (expression -> MINUS name .)
    STRING_L        reduce using rule 102 (expression -> MINUS name .)
    NONDECIMAL_L    reduce using rule 102 (expression -> MINUS name .)
    STRUCT          reduce using rule 102 (expression -> MINUS name .)
    INCREMENT       shift and go to state 100
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103

  ! PLUS            [ reduce using rule 113 (operand -> name .) ]
  ! MINUS           [ reduce using rule 113 (operand -> name .) ]
  ! ASTERISK        [ reduce using rule 113 (operand -> name .) ]
  ! DIVIDE          [ reduce using rule 113 (operand -> name .) ]
  ! LSHIFT          [ reduce using rule 113 (operand -> name .) ]
  ! RSHIFT          [ reduce using rule 113 (operand -> name .) ]
  ! PERCENT         [ reduce using rule 113 (operand -> name .) ]
  ! BITAND          [ reduce using rule 113 (operand -> name .) ]
  ! BITOR           [ reduce using rule 113 (operand -> name .) ]
  ! EQ              [ reduce using rule 113 (operand -> name .) ]
  ! NEQ             [ reduce using rule 113 (operand -> name .) ]
  ! LT              [ reduce using rule 113 (operand -> name .) ]
  ! GT              [ reduce using rule 113 (operand -> name .) ]
  ! LE              [ reduce using rule 113 (operand -> name .) ]
  ! GE              [ reduce using rule 113 (operand -> name .) ]
  ! AND             [ reduce using rule 113 (operand -> name .) ]
  ! OR              [ reduce using rule 113 (operand -> name .) ]


state 108

    (117) expression -> operand binop . operand
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    ID              shift and go to state 90
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    SIZEOF          shift and go to state 42
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    operand                        shift and go to state 161
    name                           shift and go to state 162
    expression                     shift and go to state 163
    type_cast                      shift and go to state 49
    func_call                      shift and go to state 73
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 109

    (103) binop -> PLUS .

    ID              reduce using rule 103 (binop -> PLUS .)
    LPAREN          reduce using rule 103 (binop -> PLUS .)
    NEGATE          reduce using rule 103 (binop -> PLUS .)
    MINUS           reduce using rule 103 (binop -> PLUS .)
    SIZEOF          reduce using rule 103 (binop -> PLUS .)
    FLOAT_L         reduce using rule 103 (binop -> PLUS .)
    INT_L           reduce using rule 103 (binop -> PLUS .)
    CHAR_L          reduce using rule 103 (binop -> PLUS .)
    STRING_L        reduce using rule 103 (binop -> PLUS .)
    NONDECIMAL_L    reduce using rule 103 (binop -> PLUS .)
    BITAND          reduce using rule 103 (binop -> PLUS .)


state 110

    (104) binop -> MINUS .

    ID              reduce using rule 104 (binop -> MINUS .)
    LPAREN          reduce using rule 104 (binop -> MINUS .)
    NEGATE          reduce using rule 104 (binop -> MINUS .)
    MINUS           reduce using rule 104 (binop -> MINUS .)
    SIZEOF          reduce using rule 104 (binop -> MINUS .)
    FLOAT_L         reduce using rule 104 (binop -> MINUS .)
    INT_L           reduce using rule 104 (binop -> MINUS .)
    CHAR_L          reduce using rule 104 (binop -> MINUS .)
    STRING_L        reduce using rule 104 (binop -> MINUS .)
    NONDECIMAL_L    reduce using rule 104 (binop -> MINUS .)
    BITAND          reduce using rule 104 (binop -> MINUS .)


state 111

    (105) binop -> ASTERISK .

    ID              reduce using rule 105 (binop -> ASTERISK .)
    LPAREN          reduce using rule 105 (binop -> ASTERISK .)
    NEGATE          reduce using rule 105 (binop -> ASTERISK .)
    MINUS           reduce using rule 105 (binop -> ASTERISK .)
    SIZEOF          reduce using rule 105 (binop -> ASTERISK .)
    FLOAT_L         reduce using rule 105 (binop -> ASTERISK .)
    INT_L           reduce using rule 105 (binop -> ASTERISK .)
    CHAR_L          reduce using rule 105 (binop -> ASTERISK .)
    STRING_L        reduce using rule 105 (binop -> ASTERISK .)
    NONDECIMAL_L    reduce using rule 105 (binop -> ASTERISK .)
    BITAND          reduce using rule 105 (binop -> ASTERISK .)


state 112

    (106) binop -> DIVIDE .

    ID              reduce using rule 106 (binop -> DIVIDE .)
    LPAREN          reduce using rule 106 (binop -> DIVIDE .)
    NEGATE          reduce using rule 106 (binop -> DIVIDE .)
    MINUS           reduce using rule 106 (binop -> DIVIDE .)
    SIZEOF          reduce using rule 106 (binop -> DIVIDE .)
    FLOAT_L         reduce using rule 106 (binop -> DIVIDE .)
    INT_L           reduce using rule 106 (binop -> DIVIDE .)
    CHAR_L          reduce using rule 106 (binop -> DIVIDE .)
    STRING_L        reduce using rule 106 (binop -> DIVIDE .)
    NONDECIMAL_L    reduce using rule 106 (binop -> DIVIDE .)
    BITAND          reduce using rule 106 (binop -> DIVIDE .)


state 113

    (107) binop -> LSHIFT .

    ID              reduce using rule 107 (binop -> LSHIFT .)
    LPAREN          reduce using rule 107 (binop -> LSHIFT .)
    NEGATE          reduce using rule 107 (binop -> LSHIFT .)
    MINUS           reduce using rule 107 (binop -> LSHIFT .)
    SIZEOF          reduce using rule 107 (binop -> LSHIFT .)
    FLOAT_L         reduce using rule 107 (binop -> LSHIFT .)
    INT_L           reduce using rule 107 (binop -> LSHIFT .)
    CHAR_L          reduce using rule 107 (binop -> LSHIFT .)
    STRING_L        reduce using rule 107 (binop -> LSHIFT .)
    NONDECIMAL_L    reduce using rule 107 (binop -> LSHIFT .)
    BITAND          reduce using rule 107 (binop -> LSHIFT .)


state 114

    (108) binop -> RSHIFT .

    ID              reduce using rule 108 (binop -> RSHIFT .)
    LPAREN          reduce using rule 108 (binop -> RSHIFT .)
    NEGATE          reduce using rule 108 (binop -> RSHIFT .)
    MINUS           reduce using rule 108 (binop -> RSHIFT .)
    SIZEOF          reduce using rule 108 (binop -> RSHIFT .)
    FLOAT_L         reduce using rule 108 (binop -> RSHIFT .)
    INT_L           reduce using rule 108 (binop -> RSHIFT .)
    CHAR_L          reduce using rule 108 (binop -> RSHIFT .)
    STRING_L        reduce using rule 108 (binop -> RSHIFT .)
    NONDECIMAL_L    reduce using rule 108 (binop -> RSHIFT .)
    BITAND          reduce using rule 108 (binop -> RSHIFT .)


state 115

    (109) binop -> PERCENT .

    ID              reduce using rule 109 (binop -> PERCENT .)
    LPAREN          reduce using rule 109 (binop -> PERCENT .)
    NEGATE          reduce using rule 109 (binop -> PERCENT .)
    MINUS           reduce using rule 109 (binop -> PERCENT .)
    SIZEOF          reduce using rule 109 (binop -> PERCENT .)
    FLOAT_L         reduce using rule 109 (binop -> PERCENT .)
    INT_L           reduce using rule 109 (binop -> PERCENT .)
    CHAR_L          reduce using rule 109 (binop -> PERCENT .)
    STRING_L        reduce using rule 109 (binop -> PERCENT .)
    NONDECIMAL_L    reduce using rule 109 (binop -> PERCENT .)
    BITAND          reduce using rule 109 (binop -> PERCENT .)


state 116

    (110) binop -> BITAND .

    ID              reduce using rule 110 (binop -> BITAND .)
    LPAREN          reduce using rule 110 (binop -> BITAND .)
    NEGATE          reduce using rule 110 (binop -> BITAND .)
    MINUS           reduce using rule 110 (binop -> BITAND .)
    SIZEOF          reduce using rule 110 (binop -> BITAND .)
    FLOAT_L         reduce using rule 110 (binop -> BITAND .)
    INT_L           reduce using rule 110 (binop -> BITAND .)
    CHAR_L          reduce using rule 110 (binop -> BITAND .)
    STRING_L        reduce using rule 110 (binop -> BITAND .)
    NONDECIMAL_L    reduce using rule 110 (binop -> BITAND .)
    BITAND          reduce using rule 110 (binop -> BITAND .)


state 117

    (111) binop -> BITOR .

    ID              reduce using rule 111 (binop -> BITOR .)
    LPAREN          reduce using rule 111 (binop -> BITOR .)
    NEGATE          reduce using rule 111 (binop -> BITOR .)
    MINUS           reduce using rule 111 (binop -> BITOR .)
    SIZEOF          reduce using rule 111 (binop -> BITOR .)
    FLOAT_L         reduce using rule 111 (binop -> BITOR .)
    INT_L           reduce using rule 111 (binop -> BITOR .)
    CHAR_L          reduce using rule 111 (binop -> BITOR .)
    STRING_L        reduce using rule 111 (binop -> BITOR .)
    NONDECIMAL_L    reduce using rule 111 (binop -> BITOR .)
    BITAND          reduce using rule 111 (binop -> BITOR .)


state 118

    (112) binop -> conditional .

    ID              reduce using rule 112 (binop -> conditional .)
    LPAREN          reduce using rule 112 (binop -> conditional .)
    NEGATE          reduce using rule 112 (binop -> conditional .)
    MINUS           reduce using rule 112 (binop -> conditional .)
    SIZEOF          reduce using rule 112 (binop -> conditional .)
    FLOAT_L         reduce using rule 112 (binop -> conditional .)
    INT_L           reduce using rule 112 (binop -> conditional .)
    CHAR_L          reduce using rule 112 (binop -> conditional .)
    STRING_L        reduce using rule 112 (binop -> conditional .)
    NONDECIMAL_L    reduce using rule 112 (binop -> conditional .)
    BITAND          reduce using rule 112 (binop -> conditional .)


state 119

    (52) conditional -> EQ .

    ID              reduce using rule 52 (conditional -> EQ .)
    LPAREN          reduce using rule 52 (conditional -> EQ .)
    NEGATE          reduce using rule 52 (conditional -> EQ .)
    MINUS           reduce using rule 52 (conditional -> EQ .)
    SIZEOF          reduce using rule 52 (conditional -> EQ .)
    FLOAT_L         reduce using rule 52 (conditional -> EQ .)
    INT_L           reduce using rule 52 (conditional -> EQ .)
    CHAR_L          reduce using rule 52 (conditional -> EQ .)
    STRING_L        reduce using rule 52 (conditional -> EQ .)
    NONDECIMAL_L    reduce using rule 52 (conditional -> EQ .)
    BITAND          reduce using rule 52 (conditional -> EQ .)


state 120

    (53) conditional -> NEQ .

    ID              reduce using rule 53 (conditional -> NEQ .)
    LPAREN          reduce using rule 53 (conditional -> NEQ .)
    NEGATE          reduce using rule 53 (conditional -> NEQ .)
    MINUS           reduce using rule 53 (conditional -> NEQ .)
    SIZEOF          reduce using rule 53 (conditional -> NEQ .)
    FLOAT_L         reduce using rule 53 (conditional -> NEQ .)
    INT_L           reduce using rule 53 (conditional -> NEQ .)
    CHAR_L          reduce using rule 53 (conditional -> NEQ .)
    STRING_L        reduce using rule 53 (conditional -> NEQ .)
    NONDECIMAL_L    reduce using rule 53 (conditional -> NEQ .)
    BITAND          reduce using rule 53 (conditional -> NEQ .)


state 121

    (54) conditional -> LT .

    ID              reduce using rule 54 (conditional -> LT .)
    LPAREN          reduce using rule 54 (conditional -> LT .)
    NEGATE          reduce using rule 54 (conditional -> LT .)
    MINUS           reduce using rule 54 (conditional -> LT .)
    SIZEOF          reduce using rule 54 (conditional -> LT .)
    FLOAT_L         reduce using rule 54 (conditional -> LT .)
    INT_L           reduce using rule 54 (conditional -> LT .)
    CHAR_L          reduce using rule 54 (conditional -> LT .)
    STRING_L        reduce using rule 54 (conditional -> LT .)
    NONDECIMAL_L    reduce using rule 54 (conditional -> LT .)
    BITAND          reduce using rule 54 (conditional -> LT .)


state 122

    (55) conditional -> GT .

    ID              reduce using rule 55 (conditional -> GT .)
    LPAREN          reduce using rule 55 (conditional -> GT .)
    NEGATE          reduce using rule 55 (conditional -> GT .)
    MINUS           reduce using rule 55 (conditional -> GT .)
    SIZEOF          reduce using rule 55 (conditional -> GT .)
    FLOAT_L         reduce using rule 55 (conditional -> GT .)
    INT_L           reduce using rule 55 (conditional -> GT .)
    CHAR_L          reduce using rule 55 (conditional -> GT .)
    STRING_L        reduce using rule 55 (conditional -> GT .)
    NONDECIMAL_L    reduce using rule 55 (conditional -> GT .)
    BITAND          reduce using rule 55 (conditional -> GT .)


state 123

    (56) conditional -> LE .

    ID              reduce using rule 56 (conditional -> LE .)
    LPAREN          reduce using rule 56 (conditional -> LE .)
    NEGATE          reduce using rule 56 (conditional -> LE .)
    MINUS           reduce using rule 56 (conditional -> LE .)
    SIZEOF          reduce using rule 56 (conditional -> LE .)
    FLOAT_L         reduce using rule 56 (conditional -> LE .)
    INT_L           reduce using rule 56 (conditional -> LE .)
    CHAR_L          reduce using rule 56 (conditional -> LE .)
    STRING_L        reduce using rule 56 (conditional -> LE .)
    NONDECIMAL_L    reduce using rule 56 (conditional -> LE .)
    BITAND          reduce using rule 56 (conditional -> LE .)


state 124

    (57) conditional -> GE .

    ID              reduce using rule 57 (conditional -> GE .)
    LPAREN          reduce using rule 57 (conditional -> GE .)
    NEGATE          reduce using rule 57 (conditional -> GE .)
    MINUS           reduce using rule 57 (conditional -> GE .)
    SIZEOF          reduce using rule 57 (conditional -> GE .)
    FLOAT_L         reduce using rule 57 (conditional -> GE .)
    INT_L           reduce using rule 57 (conditional -> GE .)
    CHAR_L          reduce using rule 57 (conditional -> GE .)
    STRING_L        reduce using rule 57 (conditional -> GE .)
    NONDECIMAL_L    reduce using rule 57 (conditional -> GE .)
    BITAND          reduce using rule 57 (conditional -> GE .)


state 125

    (58) conditional -> AND .

    ID              reduce using rule 58 (conditional -> AND .)
    LPAREN          reduce using rule 58 (conditional -> AND .)
    NEGATE          reduce using rule 58 (conditional -> AND .)
    MINUS           reduce using rule 58 (conditional -> AND .)
    SIZEOF          reduce using rule 58 (conditional -> AND .)
    FLOAT_L         reduce using rule 58 (conditional -> AND .)
    INT_L           reduce using rule 58 (conditional -> AND .)
    CHAR_L          reduce using rule 58 (conditional -> AND .)
    STRING_L        reduce using rule 58 (conditional -> AND .)
    NONDECIMAL_L    reduce using rule 58 (conditional -> AND .)
    BITAND          reduce using rule 58 (conditional -> AND .)


state 126

    (59) conditional -> OR .

    ID              reduce using rule 59 (conditional -> OR .)
    LPAREN          reduce using rule 59 (conditional -> OR .)
    NEGATE          reduce using rule 59 (conditional -> OR .)
    MINUS           reduce using rule 59 (conditional -> OR .)
    SIZEOF          reduce using rule 59 (conditional -> OR .)
    FLOAT_L         reduce using rule 59 (conditional -> OR .)
    INT_L           reduce using rule 59 (conditional -> OR .)
    CHAR_L          reduce using rule 59 (conditional -> OR .)
    STRING_L        reduce using rule 59 (conditional -> OR .)
    NONDECIMAL_L    reduce using rule 59 (conditional -> OR .)
    BITAND          reduce using rule 59 (conditional -> OR .)


state 127

    (83) func_call -> SIZEOF LPAREN . func_arglist RPAREN
    (77) func_arglist -> .
    (78) func_arglist -> . func_arglist func_arg
    (79) func_arglist -> . func_arglist func_arg COMMA

    RPAREN          reduce using rule 77 (func_arglist -> .)
    ID              reduce using rule 77 (func_arglist -> .)
    CHAR            reduce using rule 77 (func_arglist -> .)
    DOUBLE          reduce using rule 77 (func_arglist -> .)
    FLOAT           reduce using rule 77 (func_arglist -> .)
    INT             reduce using rule 77 (func_arglist -> .)
    VOID            reduce using rule 77 (func_arglist -> .)
    UINT8_T         reduce using rule 77 (func_arglist -> .)
    UINT16_T        reduce using rule 77 (func_arglist -> .)
    LPAREN          reduce using rule 77 (func_arglist -> .)
    SIZEOF          reduce using rule 77 (func_arglist -> .)
    FLOAT_L         reduce using rule 77 (func_arglist -> .)
    INT_L           reduce using rule 77 (func_arglist -> .)
    CHAR_L          reduce using rule 77 (func_arglist -> .)
    STRING_L        reduce using rule 77 (func_arglist -> .)
    NONDECIMAL_L    reduce using rule 77 (func_arglist -> .)
    BITAND          reduce using rule 77 (func_arglist -> .)
    STRUCT          reduce using rule 77 (func_arglist -> .)

    func_arglist                   shift and go to state 164

state 128

    (119) return -> RETURN name .
    (118) expression -> name . INCREMENT
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name
    (113) operand -> name .

    SEMI            reduce using rule 119 (return -> RETURN name .)
    INCREMENT       shift and go to state 100
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITAND          reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              reduce using rule 113 (operand -> name .)
    NEQ             reduce using rule 113 (operand -> name .)
    LT              reduce using rule 113 (operand -> name .)
    GT              reduce using rule 113 (operand -> name .)
    LE              reduce using rule 113 (operand -> name .)
    GE              reduce using rule 113 (operand -> name .)
    AND             reduce using rule 113 (operand -> name .)
    OR              reduce using rule 113 (operand -> name .)


state 129

    (120) return -> RETURN expression .
    (114) operand -> expression .

    SEMI            reduce using rule 120 (return -> RETURN expression .)
    PLUS            reduce using rule 114 (operand -> expression .)
    MINUS           reduce using rule 114 (operand -> expression .)
    ASTERISK        reduce using rule 114 (operand -> expression .)
    DIVIDE          reduce using rule 114 (operand -> expression .)
    LSHIFT          reduce using rule 114 (operand -> expression .)
    RSHIFT          reduce using rule 114 (operand -> expression .)
    PERCENT         reduce using rule 114 (operand -> expression .)
    BITAND          reduce using rule 114 (operand -> expression .)
    BITOR           reduce using rule 114 (operand -> expression .)
    EQ              reduce using rule 114 (operand -> expression .)
    NEQ             reduce using rule 114 (operand -> expression .)
    LT              reduce using rule 114 (operand -> expression .)
    GT              reduce using rule 114 (operand -> expression .)
    LE              reduce using rule 114 (operand -> expression .)
    GE              reduce using rule 114 (operand -> expression .)
    AND             reduce using rule 114 (operand -> expression .)
    OR              reduce using rule 114 (operand -> expression .)


state 130

    (66) for_loop -> FOR LPAREN . init_var conditional_expr SEMI ID INCREMENT RPAREN
    (139) init_var -> . init_var_ls init_var_rs
    (130) init_var_ls -> . declare_var_ls assign
    (131) init_var_ls -> . declare_var_ls vector_init assign
    (123) declare_var_ls -> . dtype ID
    (124) declare_var_ls -> . modifier dtype ID
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (20) modifier -> . CONST
    (21) modifier -> . EXTERN
    (22) modifier -> . INLINE
    (23) modifier -> . LONG
    (24) modifier -> . SHORT
    (25) modifier -> . SIGNED
    (26) modifier -> . UNSIGNED
    (27) modifier -> . VOLATILE
    (18) struct_type -> . STRUCT name

    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    ID              shift and go to state 132
    CONST           shift and go to state 52
    EXTERN          shift and go to state 53
    INLINE          shift and go to state 54
    LONG            shift and go to state 55
    SHORT           shift and go to state 56
    SIGNED          shift and go to state 57
    UNSIGNED        shift and go to state 58
    VOLATILE        shift and go to state 59
    STRUCT          shift and go to state 74

    init_var                       shift and go to state 165
    init_var_ls                    shift and go to state 35
    declare_var_ls                 shift and go to state 166
    dtype                          shift and go to state 167
    modifier                       shift and go to state 48
    struct_type                    shift and go to state 34

state 131

    (124) declare_var_ls -> modifier dtype . ID
    (41) dtype -> dtype . ASTERISK

    ID              shift and go to state 168
    ASTERISK        shift and go to state 67


state 132

    (40) dtype -> ID .

    ID              reduce using rule 40 (dtype -> ID .)
    ASTERISK        reduce using rule 40 (dtype -> ID .)
    RPAREN          reduce using rule 40 (dtype -> ID .)


state 133

    (115) operand -> type_cast name .
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

    PLUS            reduce using rule 115 (operand -> type_cast name .)
    MINUS           reduce using rule 115 (operand -> type_cast name .)
    ASTERISK        reduce using rule 115 (operand -> type_cast name .)
    DIVIDE          reduce using rule 115 (operand -> type_cast name .)
    LSHIFT          reduce using rule 115 (operand -> type_cast name .)
    RSHIFT          reduce using rule 115 (operand -> type_cast name .)
    PERCENT         reduce using rule 115 (operand -> type_cast name .)
    BITAND          reduce using rule 115 (operand -> type_cast name .)
    BITOR           reduce using rule 115 (operand -> type_cast name .)
    EQ              reduce using rule 115 (operand -> type_cast name .)
    NEQ             reduce using rule 115 (operand -> type_cast name .)
    LT              reduce using rule 115 (operand -> type_cast name .)
    GT              reduce using rule 115 (operand -> type_cast name .)
    LE              reduce using rule 115 (operand -> type_cast name .)
    GE              reduce using rule 115 (operand -> type_cast name .)
    AND             reduce using rule 115 (operand -> type_cast name .)
    OR              reduce using rule 115 (operand -> type_cast name .)
    SEMI            reduce using rule 115 (operand -> type_cast name .)
    RPAREN          reduce using rule 115 (operand -> type_cast name .)
    RBRACK          reduce using rule 115 (operand -> type_cast name .)
    COMMA           reduce using rule 115 (operand -> type_cast name .)
    ID              reduce using rule 115 (operand -> type_cast name .)
    CHAR            reduce using rule 115 (operand -> type_cast name .)
    DOUBLE          reduce using rule 115 (operand -> type_cast name .)
    FLOAT           reduce using rule 115 (operand -> type_cast name .)
    INT             reduce using rule 115 (operand -> type_cast name .)
    VOID            reduce using rule 115 (operand -> type_cast name .)
    UINT8_T         reduce using rule 115 (operand -> type_cast name .)
    UINT16_T        reduce using rule 115 (operand -> type_cast name .)
    LPAREN          reduce using rule 115 (operand -> type_cast name .)
    SIZEOF          reduce using rule 115 (operand -> type_cast name .)
    FLOAT_L         reduce using rule 115 (operand -> type_cast name .)
    INT_L           reduce using rule 115 (operand -> type_cast name .)
    CHAR_L          reduce using rule 115 (operand -> type_cast name .)
    STRING_L        reduce using rule 115 (operand -> type_cast name .)
    NONDECIMAL_L    reduce using rule 115 (operand -> type_cast name .)
    STRUCT          reduce using rule 115 (operand -> type_cast name .)
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103


state 134

    (42) name -> ID .

    LBRACK          reduce using rule 42 (name -> ID .)
    MEMBER          reduce using rule 42 (name -> ID .)
    PLUS            reduce using rule 42 (name -> ID .)
    MINUS           reduce using rule 42 (name -> ID .)
    ASTERISK        reduce using rule 42 (name -> ID .)
    DIVIDE          reduce using rule 42 (name -> ID .)
    LSHIFT          reduce using rule 42 (name -> ID .)
    RSHIFT          reduce using rule 42 (name -> ID .)
    PERCENT         reduce using rule 42 (name -> ID .)
    BITAND          reduce using rule 42 (name -> ID .)
    BITOR           reduce using rule 42 (name -> ID .)
    EQ              reduce using rule 42 (name -> ID .)
    NEQ             reduce using rule 42 (name -> ID .)
    LT              reduce using rule 42 (name -> ID .)
    GT              reduce using rule 42 (name -> ID .)
    LE              reduce using rule 42 (name -> ID .)
    GE              reduce using rule 42 (name -> ID .)
    AND             reduce using rule 42 (name -> ID .)
    OR              reduce using rule 42 (name -> ID .)
    SEMI            reduce using rule 42 (name -> ID .)
    RPAREN          reduce using rule 42 (name -> ID .)
    RBRACK          reduce using rule 42 (name -> ID .)
    COMMA           reduce using rule 42 (name -> ID .)
    ID              reduce using rule 42 (name -> ID .)
    CHAR            reduce using rule 42 (name -> ID .)
    DOUBLE          reduce using rule 42 (name -> ID .)
    FLOAT           reduce using rule 42 (name -> ID .)
    INT             reduce using rule 42 (name -> ID .)
    VOID            reduce using rule 42 (name -> ID .)
    UINT8_T         reduce using rule 42 (name -> ID .)
    UINT16_T        reduce using rule 42 (name -> ID .)
    LPAREN          reduce using rule 42 (name -> ID .)
    SIZEOF          reduce using rule 42 (name -> ID .)
    FLOAT_L         reduce using rule 42 (name -> ID .)
    INT_L           reduce using rule 42 (name -> ID .)
    CHAR_L          reduce using rule 42 (name -> ID .)
    STRING_L        reduce using rule 42 (name -> ID .)
    NONDECIMAL_L    reduce using rule 42 (name -> ID .)
    STRUCT          reduce using rule 42 (name -> ID .)
    INCREMENT       reduce using rule 42 (name -> ID .)
    SIMPLE_ASSIGN   reduce using rule 42 (name -> ID .)
    COMPLEX_ASSIGN  reduce using rule 42 (name -> ID .)


state 135

    (88) access -> BITAND name .
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

  ! shift/reduce conflict for LBRACK resolved as shift
  ! shift/reduce conflict for MEMBER resolved as shift
    INCREMENT       reduce using rule 88 (access -> BITAND name .)
    SIMPLE_ASSIGN   reduce using rule 88 (access -> BITAND name .)
    COMPLEX_ASSIGN  reduce using rule 88 (access -> BITAND name .)
    PLUS            reduce using rule 88 (access -> BITAND name .)
    MINUS           reduce using rule 88 (access -> BITAND name .)
    ASTERISK        reduce using rule 88 (access -> BITAND name .)
    DIVIDE          reduce using rule 88 (access -> BITAND name .)
    LSHIFT          reduce using rule 88 (access -> BITAND name .)
    RSHIFT          reduce using rule 88 (access -> BITAND name .)
    PERCENT         reduce using rule 88 (access -> BITAND name .)
    BITAND          reduce using rule 88 (access -> BITAND name .)
    BITOR           reduce using rule 88 (access -> BITAND name .)
    EQ              reduce using rule 88 (access -> BITAND name .)
    NEQ             reduce using rule 88 (access -> BITAND name .)
    LT              reduce using rule 88 (access -> BITAND name .)
    GT              reduce using rule 88 (access -> BITAND name .)
    LE              reduce using rule 88 (access -> BITAND name .)
    GE              reduce using rule 88 (access -> BITAND name .)
    AND             reduce using rule 88 (access -> BITAND name .)
    OR              reduce using rule 88 (access -> BITAND name .)
    RPAREN          reduce using rule 88 (access -> BITAND name .)
    ID              reduce using rule 88 (access -> BITAND name .)
    SEMI            reduce using rule 88 (access -> BITAND name .)
    RBRACK          reduce using rule 88 (access -> BITAND name .)
    COMMA           reduce using rule 88 (access -> BITAND name .)
    CHAR            reduce using rule 88 (access -> BITAND name .)
    DOUBLE          reduce using rule 88 (access -> BITAND name .)
    FLOAT           reduce using rule 88 (access -> BITAND name .)
    INT             reduce using rule 88 (access -> BITAND name .)
    VOID            reduce using rule 88 (access -> BITAND name .)
    UINT8_T         reduce using rule 88 (access -> BITAND name .)
    UINT16_T        reduce using rule 88 (access -> BITAND name .)
    LPAREN          reduce using rule 88 (access -> BITAND name .)
    SIZEOF          reduce using rule 88 (access -> BITAND name .)
    FLOAT_L         reduce using rule 88 (access -> BITAND name .)
    INT_L           reduce using rule 88 (access -> BITAND name .)
    CHAR_L          reduce using rule 88 (access -> BITAND name .)
    STRING_L        reduce using rule 88 (access -> BITAND name .)
    NONDECIMAL_L    reduce using rule 88 (access -> BITAND name .)
    STRUCT          reduce using rule 88 (access -> BITAND name .)
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103

  ! LBRACK          [ reduce using rule 88 (access -> BITAND name .) ]
  ! MEMBER          [ reduce using rule 88 (access -> BITAND name .) ]


state 136

    (80) func_def -> dtype ID LPAREN . func_arglist RPAREN LBRACE node_list RBRACE
    (84) func_decl -> dtype ID LPAREN . func_arglist RPAREN SEMI
    (77) func_arglist -> .
    (78) func_arglist -> . func_arglist func_arg
    (79) func_arglist -> . func_arglist func_arg COMMA

    RPAREN          reduce using rule 77 (func_arglist -> .)
    ID              reduce using rule 77 (func_arglist -> .)
    CHAR            reduce using rule 77 (func_arglist -> .)
    DOUBLE          reduce using rule 77 (func_arglist -> .)
    FLOAT           reduce using rule 77 (func_arglist -> .)
    INT             reduce using rule 77 (func_arglist -> .)
    VOID            reduce using rule 77 (func_arglist -> .)
    UINT8_T         reduce using rule 77 (func_arglist -> .)
    UINT16_T        reduce using rule 77 (func_arglist -> .)
    LPAREN          reduce using rule 77 (func_arglist -> .)
    SIZEOF          reduce using rule 77 (func_arglist -> .)
    FLOAT_L         reduce using rule 77 (func_arglist -> .)
    INT_L           reduce using rule 77 (func_arglist -> .)
    CHAR_L          reduce using rule 77 (func_arglist -> .)
    STRING_L        reduce using rule 77 (func_arglist -> .)
    NONDECIMAL_L    reduce using rule 77 (func_arglist -> .)
    BITAND          reduce using rule 77 (func_arglist -> .)
    STRUCT          reduce using rule 77 (func_arglist -> .)

    func_arglist                   shift and go to state 169

state 137

    (81) func_def -> ID LPAREN func_arglist . RPAREN LBRACE node_list RBRACE
    (82) func_call -> ID LPAREN func_arglist . RPAREN
    (78) func_arglist -> func_arglist . func_arg
    (79) func_arglist -> func_arglist . func_arg COMMA
    (70) func_arg -> . name
    (71) func_arg -> . dtype name
    (72) func_arg -> . dtype
    (73) func_arg -> . type_cast name
    (74) func_arg -> . type_cast expression
    (75) func_arg -> . func_call
    (76) func_arg -> . type_cast func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (18) struct_type -> . STRUCT name

    RPAREN          shift and go to state 171
    ID              shift and go to state 72
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    LPAREN          shift and go to state 170
    SIZEOF          shift and go to state 42
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    STRUCT          shift and go to state 74

    func_arg                       shift and go to state 172
    name                           shift and go to state 173
    dtype                          shift and go to state 174
    type_cast                      shift and go to state 175
    func_call                      shift and go to state 176
    literal                        shift and go to state 50
    access                         shift and go to state 51
    struct_type                    shift and go to state 34

state 138

    (97) expression -> LPAREN expression RPAREN .

    SEMI            reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    ASTERISK        reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    PERCENT         reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    BITAND          reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    BITOR           reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    RBRACK          reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    ID              reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    CHAR            reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    DOUBLE          reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    INT             reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    VOID            reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    UINT8_T         reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    UINT16_T        reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    SIZEOF          reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    FLOAT_L         reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    INT_L           reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    CHAR_L          reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    STRING_L        reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    NONDECIMAL_L    reduce using rule 97 (expression -> LPAREN expression RPAREN .)
    STRUCT          reduce using rule 97 (expression -> LPAREN expression RPAREN .)


state 139

    (98) expression -> LPAREN name RPAREN .

    SEMI            reduce using rule 98 (expression -> LPAREN name RPAREN .)
    PLUS            reduce using rule 98 (expression -> LPAREN name RPAREN .)
    MINUS           reduce using rule 98 (expression -> LPAREN name RPAREN .)
    ASTERISK        reduce using rule 98 (expression -> LPAREN name RPAREN .)
    DIVIDE          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    LSHIFT          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    RSHIFT          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    PERCENT         reduce using rule 98 (expression -> LPAREN name RPAREN .)
    BITAND          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    BITOR           reduce using rule 98 (expression -> LPAREN name RPAREN .)
    EQ              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    NEQ             reduce using rule 98 (expression -> LPAREN name RPAREN .)
    LT              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    GT              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    LE              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    GE              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    AND             reduce using rule 98 (expression -> LPAREN name RPAREN .)
    OR              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    RPAREN          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    RBRACK          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    COMMA           reduce using rule 98 (expression -> LPAREN name RPAREN .)
    ID              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    CHAR            reduce using rule 98 (expression -> LPAREN name RPAREN .)
    DOUBLE          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    FLOAT           reduce using rule 98 (expression -> LPAREN name RPAREN .)
    INT             reduce using rule 98 (expression -> LPAREN name RPAREN .)
    VOID            reduce using rule 98 (expression -> LPAREN name RPAREN .)
    UINT8_T         reduce using rule 98 (expression -> LPAREN name RPAREN .)
    UINT16_T        reduce using rule 98 (expression -> LPAREN name RPAREN .)
    LPAREN          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    SIZEOF          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    FLOAT_L         reduce using rule 98 (expression -> LPAREN name RPAREN .)
    INT_L           reduce using rule 98 (expression -> LPAREN name RPAREN .)
    CHAR_L          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    STRING_L        reduce using rule 98 (expression -> LPAREN name RPAREN .)
    NONDECIMAL_L    reduce using rule 98 (expression -> LPAREN name RPAREN .)
    STRUCT          reduce using rule 98 (expression -> LPAREN name RPAREN .)


state 140

    (19) type_cast -> LPAREN dtype RPAREN .

    ID              reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    FLOAT_L         reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    INT_L           reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    CHAR_L          reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    STRING_L        reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    NONDECIMAL_L    reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    BITAND          reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    LPAREN          reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    error           reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    SIZEOF          reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    NEGATE          reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)
    MINUS           reduce using rule 19 (type_cast -> LPAREN dtype RPAREN .)


state 141

    (82) func_call -> ID LPAREN . func_arglist RPAREN
    (77) func_arglist -> .
    (78) func_arglist -> . func_arglist func_arg
    (79) func_arglist -> . func_arglist func_arg COMMA

    RPAREN          reduce using rule 77 (func_arglist -> .)
    ID              reduce using rule 77 (func_arglist -> .)
    CHAR            reduce using rule 77 (func_arglist -> .)
    DOUBLE          reduce using rule 77 (func_arglist -> .)
    FLOAT           reduce using rule 77 (func_arglist -> .)
    INT             reduce using rule 77 (func_arglist -> .)
    VOID            reduce using rule 77 (func_arglist -> .)
    UINT8_T         reduce using rule 77 (func_arglist -> .)
    UINT16_T        reduce using rule 77 (func_arglist -> .)
    LPAREN          reduce using rule 77 (func_arglist -> .)
    SIZEOF          reduce using rule 77 (func_arglist -> .)
    FLOAT_L         reduce using rule 77 (func_arglist -> .)
    INT_L           reduce using rule 77 (func_arglist -> .)
    CHAR_L          reduce using rule 77 (func_arglist -> .)
    STRING_L        reduce using rule 77 (func_arglist -> .)
    NONDECIMAL_L    reduce using rule 77 (func_arglist -> .)
    BITAND          reduce using rule 77 (func_arglist -> .)
    STRUCT          reduce using rule 77 (func_arglist -> .)

    func_arglist                   shift and go to state 177

state 142

    (67) control_expr -> control LPAREN conditional_expr . RPAREN LBRACE node_list RBRACE

    RPAREN          shift and go to state 178


state 143

    (60) conditional_expr -> name . conditional expression
    (63) conditional_expr -> name . conditional name
    (64) conditional_expr -> name .
    (118) expression -> name . INCREMENT
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name
    (113) operand -> name .
    (52) conditional -> . EQ
    (53) conditional -> . NEQ
    (54) conditional -> . LT
    (55) conditional -> . GT
    (56) conditional -> . LE
    (57) conditional -> . GE
    (58) conditional -> . AND
    (59) conditional -> . OR

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 64 (conditional_expr -> name .)
    SEMI            reduce using rule 64 (conditional_expr -> name .)
    INCREMENT       shift and go to state 100
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITAND          reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              shift and go to state 119
    NEQ             shift and go to state 120
    LT              shift and go to state 121
    GT              shift and go to state 122
    LE              shift and go to state 123
    GE              shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

  ! EQ              [ reduce using rule 113 (operand -> name .) ]
  ! NEQ             [ reduce using rule 113 (operand -> name .) ]
  ! LT              [ reduce using rule 113 (operand -> name .) ]
  ! GT              [ reduce using rule 113 (operand -> name .) ]
  ! LE              [ reduce using rule 113 (operand -> name .) ]
  ! GE              [ reduce using rule 113 (operand -> name .) ]
  ! AND             [ reduce using rule 113 (operand -> name .) ]
  ! OR              [ reduce using rule 113 (operand -> name .) ]

    conditional                    shift and go to state 179

state 144

    (61) conditional_expr -> expression . conditional name
    (62) conditional_expr -> expression . conditional expression
    (65) conditional_expr -> expression .
    (114) operand -> expression .
    (52) conditional -> . EQ
    (53) conditional -> . NEQ
    (54) conditional -> . LT
    (55) conditional -> . GT
    (56) conditional -> . LE
    (57) conditional -> . GE
    (58) conditional -> . AND
    (59) conditional -> . OR

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 65 (conditional_expr -> expression .)
    SEMI            reduce using rule 65 (conditional_expr -> expression .)
    PLUS            reduce using rule 114 (operand -> expression .)
    MINUS           reduce using rule 114 (operand -> expression .)
    ASTERISK        reduce using rule 114 (operand -> expression .)
    DIVIDE          reduce using rule 114 (operand -> expression .)
    LSHIFT          reduce using rule 114 (operand -> expression .)
    RSHIFT          reduce using rule 114 (operand -> expression .)
    PERCENT         reduce using rule 114 (operand -> expression .)
    BITAND          reduce using rule 114 (operand -> expression .)
    BITOR           reduce using rule 114 (operand -> expression .)
    EQ              shift and go to state 119
    NEQ             shift and go to state 120
    LT              shift and go to state 121
    GT              shift and go to state 122
    LE              shift and go to state 123
    GE              shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

  ! EQ              [ reduce using rule 114 (operand -> expression .) ]
  ! NEQ             [ reduce using rule 114 (operand -> expression .) ]
  ! LT              [ reduce using rule 114 (operand -> expression .) ]
  ! GT              [ reduce using rule 114 (operand -> expression .) ]
  ! LE              [ reduce using rule 114 (operand -> expression .) ]
  ! GE              [ reduce using rule 114 (operand -> expression .) ]
  ! AND             [ reduce using rule 114 (operand -> expression .) ]
  ! OR              [ reduce using rule 114 (operand -> expression .) ]

    conditional                    shift and go to state 180

state 145

    (68) control_expr -> control LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (45) include -> . INCLUDE
    (46) define -> . DEFINE
    (47) if -> . IFNDEF
    (48) if -> . ENDIF
    (80) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (81) func_def -> . ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (84) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (91) statement -> . init_var
    (92) statement -> . assign_var
    (93) statement -> . declare_var
    (94) statement -> . expression SEMI
    (95) statement -> . func_call SEMI
    (96) statement -> . return SEMI
    (67) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (68) control_expr -> . control LBRACE node_list RBRACE
    (69) control_expr -> . for_loop LBRACE node_list RBRACE
    (89) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (139) init_var -> . init_var_ls init_var_rs
    (142) assign_var -> . assign_var_ls assign_var_rs
    (125) declare_var -> . declare_var_ls SEMI
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (119) return -> . RETURN name
    (120) return -> . RETURN expression
    (49) control -> . WHILE
    (50) control -> . IF
    (51) control -> . ELSE
    (66) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT name
    (130) init_var_ls -> . declare_var_ls assign
    (131) init_var_ls -> . declare_var_ls vector_init assign
    (140) assign_var_ls -> . name assign
    (123) declare_var_ls -> . dtype ID
    (124) declare_var_ls -> . modifier dtype ID
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (20) modifier -> . CONST
    (21) modifier -> . EXTERN
    (22) modifier -> . INLINE
    (23) modifier -> . LONG
    (24) modifier -> . SHORT
    (25) modifier -> . SIGNED
    (26) modifier -> . UNSIGNED
    (27) modifier -> . VOLATILE
    (19) type_cast -> . LPAREN dtype RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    RBRACE          shift and go to state 181
    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    ID              shift and go to state 16
    STRUCT          shift and go to state 26
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    SIZEOF          shift and go to state 42
    RETURN          shift and go to state 43
    WHILE           shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    FOR             shift and go to state 47
    CONST           shift and go to state 52
    EXTERN          shift and go to state 53
    INLINE          shift and go to state 54
    LONG            shift and go to state 55
    SHORT           shift and go to state 56
    SIGNED          shift and go to state 57
    UNSIGNED        shift and go to state 58
    VOLATILE        shift and go to state 59
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    control                        shift and go to state 24
    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    dtype                          shift and go to state 15
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    return                         shift and go to state 23
    for_loop                       shift and go to state 25
    struct_type                    shift and go to state 34
    init_var_ls                    shift and go to state 35
    assign_var_ls                  shift and go to state 36
    declare_var_ls                 shift and go to state 37
    name                           shift and go to state 38
    operand                        shift and go to state 41
    modifier                       shift and go to state 48
    type_cast                      shift and go to state 49
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 146

    (69) control_expr -> for_loop LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (45) include -> . INCLUDE
    (46) define -> . DEFINE
    (47) if -> . IFNDEF
    (48) if -> . ENDIF
    (80) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (81) func_def -> . ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (84) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (91) statement -> . init_var
    (92) statement -> . assign_var
    (93) statement -> . declare_var
    (94) statement -> . expression SEMI
    (95) statement -> . func_call SEMI
    (96) statement -> . return SEMI
    (67) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (68) control_expr -> . control LBRACE node_list RBRACE
    (69) control_expr -> . for_loop LBRACE node_list RBRACE
    (89) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (139) init_var -> . init_var_ls init_var_rs
    (142) assign_var -> . assign_var_ls assign_var_rs
    (125) declare_var -> . declare_var_ls SEMI
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (119) return -> . RETURN name
    (120) return -> . RETURN expression
    (49) control -> . WHILE
    (50) control -> . IF
    (51) control -> . ELSE
    (66) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT name
    (130) init_var_ls -> . declare_var_ls assign
    (131) init_var_ls -> . declare_var_ls vector_init assign
    (140) assign_var_ls -> . name assign
    (123) declare_var_ls -> . dtype ID
    (124) declare_var_ls -> . modifier dtype ID
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (20) modifier -> . CONST
    (21) modifier -> . EXTERN
    (22) modifier -> . INLINE
    (23) modifier -> . LONG
    (24) modifier -> . SHORT
    (25) modifier -> . SIGNED
    (26) modifier -> . UNSIGNED
    (27) modifier -> . VOLATILE
    (19) type_cast -> . LPAREN dtype RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    RBRACE          shift and go to state 182
    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    ID              shift and go to state 16
    STRUCT          shift and go to state 26
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    SIZEOF          shift and go to state 42
    RETURN          shift and go to state 43
    WHILE           shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    FOR             shift and go to state 47
    CONST           shift and go to state 52
    EXTERN          shift and go to state 53
    INLINE          shift and go to state 54
    LONG            shift and go to state 55
    SHORT           shift and go to state 56
    SIGNED          shift and go to state 57
    UNSIGNED        shift and go to state 58
    VOLATILE        shift and go to state 59
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    for_loop                       shift and go to state 25
    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    dtype                          shift and go to state 15
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    return                         shift and go to state 23
    control                        shift and go to state 24
    struct_type                    shift and go to state 34
    init_var_ls                    shift and go to state 35
    assign_var_ls                  shift and go to state 36
    declare_var_ls                 shift and go to state 37
    name                           shift and go to state 38
    operand                        shift and go to state 41
    modifier                       shift and go to state 48
    type_cast                      shift and go to state 49
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 147

    (89) struct_def -> STRUCT ID LBRACE . node_list RBRACE SEMI
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    SIZEOF          reduce using rule 1 (node_list -> .)
    RETURN          reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)
    BITAND          reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 183

state 148

    (133) init_var_rs -> name SEMI .

    INCLUDE         reduce using rule 133 (init_var_rs -> name SEMI .)
    DEFINE          reduce using rule 133 (init_var_rs -> name SEMI .)
    IFNDEF          reduce using rule 133 (init_var_rs -> name SEMI .)
    ENDIF           reduce using rule 133 (init_var_rs -> name SEMI .)
    ID              reduce using rule 133 (init_var_rs -> name SEMI .)
    STRUCT          reduce using rule 133 (init_var_rs -> name SEMI .)
    CHAR            reduce using rule 133 (init_var_rs -> name SEMI .)
    DOUBLE          reduce using rule 133 (init_var_rs -> name SEMI .)
    FLOAT           reduce using rule 133 (init_var_rs -> name SEMI .)
    INT             reduce using rule 133 (init_var_rs -> name SEMI .)
    VOID            reduce using rule 133 (init_var_rs -> name SEMI .)
    UINT8_T         reduce using rule 133 (init_var_rs -> name SEMI .)
    UINT16_T        reduce using rule 133 (init_var_rs -> name SEMI .)
    LPAREN          reduce using rule 133 (init_var_rs -> name SEMI .)
    NEGATE          reduce using rule 133 (init_var_rs -> name SEMI .)
    MINUS           reduce using rule 133 (init_var_rs -> name SEMI .)
    SIZEOF          reduce using rule 133 (init_var_rs -> name SEMI .)
    RETURN          reduce using rule 133 (init_var_rs -> name SEMI .)
    WHILE           reduce using rule 133 (init_var_rs -> name SEMI .)
    IF              reduce using rule 133 (init_var_rs -> name SEMI .)
    ELSE            reduce using rule 133 (init_var_rs -> name SEMI .)
    FOR             reduce using rule 133 (init_var_rs -> name SEMI .)
    CONST           reduce using rule 133 (init_var_rs -> name SEMI .)
    EXTERN          reduce using rule 133 (init_var_rs -> name SEMI .)
    INLINE          reduce using rule 133 (init_var_rs -> name SEMI .)
    LONG            reduce using rule 133 (init_var_rs -> name SEMI .)
    SHORT           reduce using rule 133 (init_var_rs -> name SEMI .)
    SIGNED          reduce using rule 133 (init_var_rs -> name SEMI .)
    UNSIGNED        reduce using rule 133 (init_var_rs -> name SEMI .)
    VOLATILE        reduce using rule 133 (init_var_rs -> name SEMI .)
    FLOAT_L         reduce using rule 133 (init_var_rs -> name SEMI .)
    INT_L           reduce using rule 133 (init_var_rs -> name SEMI .)
    CHAR_L          reduce using rule 133 (init_var_rs -> name SEMI .)
    STRING_L        reduce using rule 133 (init_var_rs -> name SEMI .)
    NONDECIMAL_L    reduce using rule 133 (init_var_rs -> name SEMI .)
    BITAND          reduce using rule 133 (init_var_rs -> name SEMI .)
    $end            reduce using rule 133 (init_var_rs -> name SEMI .)
    RBRACE          reduce using rule 133 (init_var_rs -> name SEMI .)


state 149

    (134) init_var_rs -> func_call SEMI .

    INCLUDE         reduce using rule 134 (init_var_rs -> func_call SEMI .)
    DEFINE          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    IFNDEF          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    ENDIF           reduce using rule 134 (init_var_rs -> func_call SEMI .)
    ID              reduce using rule 134 (init_var_rs -> func_call SEMI .)
    STRUCT          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    CHAR            reduce using rule 134 (init_var_rs -> func_call SEMI .)
    DOUBLE          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    FLOAT           reduce using rule 134 (init_var_rs -> func_call SEMI .)
    INT             reduce using rule 134 (init_var_rs -> func_call SEMI .)
    VOID            reduce using rule 134 (init_var_rs -> func_call SEMI .)
    UINT8_T         reduce using rule 134 (init_var_rs -> func_call SEMI .)
    UINT16_T        reduce using rule 134 (init_var_rs -> func_call SEMI .)
    LPAREN          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    NEGATE          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    MINUS           reduce using rule 134 (init_var_rs -> func_call SEMI .)
    SIZEOF          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    RETURN          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    WHILE           reduce using rule 134 (init_var_rs -> func_call SEMI .)
    IF              reduce using rule 134 (init_var_rs -> func_call SEMI .)
    ELSE            reduce using rule 134 (init_var_rs -> func_call SEMI .)
    FOR             reduce using rule 134 (init_var_rs -> func_call SEMI .)
    CONST           reduce using rule 134 (init_var_rs -> func_call SEMI .)
    EXTERN          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    INLINE          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    LONG            reduce using rule 134 (init_var_rs -> func_call SEMI .)
    SHORT           reduce using rule 134 (init_var_rs -> func_call SEMI .)
    SIGNED          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    UNSIGNED        reduce using rule 134 (init_var_rs -> func_call SEMI .)
    VOLATILE        reduce using rule 134 (init_var_rs -> func_call SEMI .)
    FLOAT_L         reduce using rule 134 (init_var_rs -> func_call SEMI .)
    INT_L           reduce using rule 134 (init_var_rs -> func_call SEMI .)
    CHAR_L          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    STRING_L        reduce using rule 134 (init_var_rs -> func_call SEMI .)
    NONDECIMAL_L    reduce using rule 134 (init_var_rs -> func_call SEMI .)
    BITAND          reduce using rule 134 (init_var_rs -> func_call SEMI .)
    $end            reduce using rule 134 (init_var_rs -> func_call SEMI .)
    RBRACE          reduce using rule 134 (init_var_rs -> func_call SEMI .)


state 150

    (135) init_var_rs -> expression SEMI .

    INCLUDE         reduce using rule 135 (init_var_rs -> expression SEMI .)
    DEFINE          reduce using rule 135 (init_var_rs -> expression SEMI .)
    IFNDEF          reduce using rule 135 (init_var_rs -> expression SEMI .)
    ENDIF           reduce using rule 135 (init_var_rs -> expression SEMI .)
    ID              reduce using rule 135 (init_var_rs -> expression SEMI .)
    STRUCT          reduce using rule 135 (init_var_rs -> expression SEMI .)
    CHAR            reduce using rule 135 (init_var_rs -> expression SEMI .)
    DOUBLE          reduce using rule 135 (init_var_rs -> expression SEMI .)
    FLOAT           reduce using rule 135 (init_var_rs -> expression SEMI .)
    INT             reduce using rule 135 (init_var_rs -> expression SEMI .)
    VOID            reduce using rule 135 (init_var_rs -> expression SEMI .)
    UINT8_T         reduce using rule 135 (init_var_rs -> expression SEMI .)
    UINT16_T        reduce using rule 135 (init_var_rs -> expression SEMI .)
    LPAREN          reduce using rule 135 (init_var_rs -> expression SEMI .)
    NEGATE          reduce using rule 135 (init_var_rs -> expression SEMI .)
    MINUS           reduce using rule 135 (init_var_rs -> expression SEMI .)
    SIZEOF          reduce using rule 135 (init_var_rs -> expression SEMI .)
    RETURN          reduce using rule 135 (init_var_rs -> expression SEMI .)
    WHILE           reduce using rule 135 (init_var_rs -> expression SEMI .)
    IF              reduce using rule 135 (init_var_rs -> expression SEMI .)
    ELSE            reduce using rule 135 (init_var_rs -> expression SEMI .)
    FOR             reduce using rule 135 (init_var_rs -> expression SEMI .)
    CONST           reduce using rule 135 (init_var_rs -> expression SEMI .)
    EXTERN          reduce using rule 135 (init_var_rs -> expression SEMI .)
    INLINE          reduce using rule 135 (init_var_rs -> expression SEMI .)
    LONG            reduce using rule 135 (init_var_rs -> expression SEMI .)
    SHORT           reduce using rule 135 (init_var_rs -> expression SEMI .)
    SIGNED          reduce using rule 135 (init_var_rs -> expression SEMI .)
    UNSIGNED        reduce using rule 135 (init_var_rs -> expression SEMI .)
    VOLATILE        reduce using rule 135 (init_var_rs -> expression SEMI .)
    FLOAT_L         reduce using rule 135 (init_var_rs -> expression SEMI .)
    INT_L           reduce using rule 135 (init_var_rs -> expression SEMI .)
    CHAR_L          reduce using rule 135 (init_var_rs -> expression SEMI .)
    STRING_L        reduce using rule 135 (init_var_rs -> expression SEMI .)
    NONDECIMAL_L    reduce using rule 135 (init_var_rs -> expression SEMI .)
    BITAND          reduce using rule 135 (init_var_rs -> expression SEMI .)
    $end            reduce using rule 135 (init_var_rs -> expression SEMI .)
    RBRACE          reduce using rule 135 (init_var_rs -> expression SEMI .)


state 151

    (137) init_var_rs -> LPAREN name . RPAREN
    (98) expression -> LPAREN name . RPAREN
    (118) expression -> name . INCREMENT
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name
    (113) operand -> name .

    RPAREN          shift and go to state 184
    INCREMENT       shift and go to state 100
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITAND          reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              reduce using rule 113 (operand -> name .)
    NEQ             reduce using rule 113 (operand -> name .)
    LT              reduce using rule 113 (operand -> name .)
    GT              reduce using rule 113 (operand -> name .)
    LE              reduce using rule 113 (operand -> name .)
    GE              reduce using rule 113 (operand -> name .)
    AND             reduce using rule 113 (operand -> name .)
    OR              reduce using rule 113 (operand -> name .)


state 152

    (138) init_var_rs -> error SEMI .

    INCLUDE         reduce using rule 138 (init_var_rs -> error SEMI .)
    DEFINE          reduce using rule 138 (init_var_rs -> error SEMI .)
    IFNDEF          reduce using rule 138 (init_var_rs -> error SEMI .)
    ENDIF           reduce using rule 138 (init_var_rs -> error SEMI .)
    ID              reduce using rule 138 (init_var_rs -> error SEMI .)
    STRUCT          reduce using rule 138 (init_var_rs -> error SEMI .)
    CHAR            reduce using rule 138 (init_var_rs -> error SEMI .)
    DOUBLE          reduce using rule 138 (init_var_rs -> error SEMI .)
    FLOAT           reduce using rule 138 (init_var_rs -> error SEMI .)
    INT             reduce using rule 138 (init_var_rs -> error SEMI .)
    VOID            reduce using rule 138 (init_var_rs -> error SEMI .)
    UINT8_T         reduce using rule 138 (init_var_rs -> error SEMI .)
    UINT16_T        reduce using rule 138 (init_var_rs -> error SEMI .)
    LPAREN          reduce using rule 138 (init_var_rs -> error SEMI .)
    NEGATE          reduce using rule 138 (init_var_rs -> error SEMI .)
    MINUS           reduce using rule 138 (init_var_rs -> error SEMI .)
    SIZEOF          reduce using rule 138 (init_var_rs -> error SEMI .)
    RETURN          reduce using rule 138 (init_var_rs -> error SEMI .)
    WHILE           reduce using rule 138 (init_var_rs -> error SEMI .)
    IF              reduce using rule 138 (init_var_rs -> error SEMI .)
    ELSE            reduce using rule 138 (init_var_rs -> error SEMI .)
    FOR             reduce using rule 138 (init_var_rs -> error SEMI .)
    CONST           reduce using rule 138 (init_var_rs -> error SEMI .)
    EXTERN          reduce using rule 138 (init_var_rs -> error SEMI .)
    INLINE          reduce using rule 138 (init_var_rs -> error SEMI .)
    LONG            reduce using rule 138 (init_var_rs -> error SEMI .)
    SHORT           reduce using rule 138 (init_var_rs -> error SEMI .)
    SIGNED          reduce using rule 138 (init_var_rs -> error SEMI .)
    UNSIGNED        reduce using rule 138 (init_var_rs -> error SEMI .)
    VOLATILE        reduce using rule 138 (init_var_rs -> error SEMI .)
    FLOAT_L         reduce using rule 138 (init_var_rs -> error SEMI .)
    INT_L           reduce using rule 138 (init_var_rs -> error SEMI .)
    CHAR_L          reduce using rule 138 (init_var_rs -> error SEMI .)
    STRING_L        reduce using rule 138 (init_var_rs -> error SEMI .)
    NONDECIMAL_L    reduce using rule 138 (init_var_rs -> error SEMI .)
    BITAND          reduce using rule 138 (init_var_rs -> error SEMI .)
    $end            reduce using rule 138 (init_var_rs -> error SEMI .)
    RBRACE          reduce using rule 138 (init_var_rs -> error SEMI .)


state 153

    (132) typecast_init -> type_cast init_var_rs .

    INCLUDE         reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    DEFINE          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    IFNDEF          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    ENDIF           reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    ID              reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    STRUCT          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    CHAR            reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    DOUBLE          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    FLOAT           reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    INT             reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    VOID            reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    UINT8_T         reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    UINT16_T        reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    LPAREN          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    NEGATE          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    MINUS           reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    SIZEOF          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    RETURN          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    WHILE           reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    IF              reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    ELSE            reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    FOR             reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    CONST           reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    EXTERN          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    INLINE          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    LONG            reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    SHORT           reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    SIGNED          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    UNSIGNED        reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    VOLATILE        reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    FLOAT_L         reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    INT_L           reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    CHAR_L          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    STRING_L        reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    NONDECIMAL_L    reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    BITAND          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    $end            reduce using rule 132 (typecast_init -> type_cast init_var_rs .)
    RBRACE          reduce using rule 132 (typecast_init -> type_cast init_var_rs .)


state 154

    (115) operand -> type_cast name .
    (133) init_var_rs -> name . SEMI
    (118) expression -> name . INCREMENT
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name
    (113) operand -> name .

  ! reduce/reduce conflict for PLUS resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for MINUS resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for ASTERISK resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for LSHIFT resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for RSHIFT resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for PERCENT resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for BITAND resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for BITOR resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for EQ resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for NEQ resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for LT resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for GT resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for LE resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for GE resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for AND resolved using rule 113 (operand -> name .)
  ! reduce/reduce conflict for OR resolved using rule 113 (operand -> name .)
    SEMI            shift and go to state 148
    INCREMENT       shift and go to state 100
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITAND          reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              reduce using rule 113 (operand -> name .)
    NEQ             reduce using rule 113 (operand -> name .)
    LT              reduce using rule 113 (operand -> name .)
    GT              reduce using rule 113 (operand -> name .)
    LE              reduce using rule 113 (operand -> name .)
    GE              reduce using rule 113 (operand -> name .)
    AND             reduce using rule 113 (operand -> name .)
    OR              reduce using rule 113 (operand -> name .)

  ! PLUS            [ reduce using rule 115 (operand -> type_cast name .) ]
  ! MINUS           [ reduce using rule 115 (operand -> type_cast name .) ]
  ! ASTERISK        [ reduce using rule 115 (operand -> type_cast name .) ]
  ! DIVIDE          [ reduce using rule 115 (operand -> type_cast name .) ]
  ! LSHIFT          [ reduce using rule 115 (operand -> type_cast name .) ]
  ! RSHIFT          [ reduce using rule 115 (operand -> type_cast name .) ]
  ! PERCENT         [ reduce using rule 115 (operand -> type_cast name .) ]
  ! BITAND          [ reduce using rule 115 (operand -> type_cast name .) ]
  ! BITOR           [ reduce using rule 115 (operand -> type_cast name .) ]
  ! EQ              [ reduce using rule 115 (operand -> type_cast name .) ]
  ! NEQ             [ reduce using rule 115 (operand -> type_cast name .) ]
  ! LT              [ reduce using rule 115 (operand -> type_cast name .) ]
  ! GT              [ reduce using rule 115 (operand -> type_cast name .) ]
  ! LE              [ reduce using rule 115 (operand -> type_cast name .) ]
  ! GE              [ reduce using rule 115 (operand -> type_cast name .) ]
  ! AND             [ reduce using rule 115 (operand -> type_cast name .) ]
  ! OR              [ reduce using rule 115 (operand -> type_cast name .) ]


state 155

    (131) init_var_ls -> declare_var_ls vector_init assign .

    LPAREN          reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)
    error           reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)
    ID              reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)
    SIZEOF          reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)
    NEGATE          reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)
    MINUS           reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)
    FLOAT_L         reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)
    INT_L           reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)
    CHAR_L          reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)
    STRING_L        reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)
    NONDECIMAL_L    reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)
    BITAND          reduce using rule 131 (init_var_ls -> declare_var_ls vector_init assign .)


state 156

    (126) vector_init -> LBRACK RBRACK .

    SIMPLE_ASSIGN   reduce using rule 126 (vector_init -> LBRACK RBRACK .)
    COMPLEX_ASSIGN  reduce using rule 126 (vector_init -> LBRACK RBRACK .)


state 157

    (127) vector_init -> LBRACK name . RBRACK
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

    RBRACK          shift and go to state 185
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103


state 158

    (85) access -> name LBRACK name . RBRACK
    (118) expression -> name . INCREMENT
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name
    (113) operand -> name .

    RBRACK          shift and go to state 186
    INCREMENT       shift and go to state 100
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITAND          reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              reduce using rule 113 (operand -> name .)
    NEQ             reduce using rule 113 (operand -> name .)
    LT              reduce using rule 113 (operand -> name .)
    GT              reduce using rule 113 (operand -> name .)
    LE              reduce using rule 113 (operand -> name .)
    GE              reduce using rule 113 (operand -> name .)
    AND             reduce using rule 113 (operand -> name .)
    OR              reduce using rule 113 (operand -> name .)


state 159

    (86) access -> name LBRACK expression . RBRACK
    (114) operand -> expression .

    RBRACK          shift and go to state 187
    PLUS            reduce using rule 114 (operand -> expression .)
    MINUS           reduce using rule 114 (operand -> expression .)
    ASTERISK        reduce using rule 114 (operand -> expression .)
    DIVIDE          reduce using rule 114 (operand -> expression .)
    LSHIFT          reduce using rule 114 (operand -> expression .)
    RSHIFT          reduce using rule 114 (operand -> expression .)
    PERCENT         reduce using rule 114 (operand -> expression .)
    BITAND          reduce using rule 114 (operand -> expression .)
    BITOR           reduce using rule 114 (operand -> expression .)
    EQ              reduce using rule 114 (operand -> expression .)
    NEQ             reduce using rule 114 (operand -> expression .)
    LT              reduce using rule 114 (operand -> expression .)
    GT              reduce using rule 114 (operand -> expression .)
    LE              reduce using rule 114 (operand -> expression .)
    GE              reduce using rule 114 (operand -> expression .)
    AND             reduce using rule 114 (operand -> expression .)
    OR              reduce using rule 114 (operand -> expression .)


state 160

    (87) access -> name MEMBER name .
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

  ! shift/reduce conflict for LBRACK resolved as shift
  ! shift/reduce conflict for MEMBER resolved as shift
    INCREMENT       reduce using rule 87 (access -> name MEMBER name .)
    SIMPLE_ASSIGN   reduce using rule 87 (access -> name MEMBER name .)
    COMPLEX_ASSIGN  reduce using rule 87 (access -> name MEMBER name .)
    PLUS            reduce using rule 87 (access -> name MEMBER name .)
    MINUS           reduce using rule 87 (access -> name MEMBER name .)
    ASTERISK        reduce using rule 87 (access -> name MEMBER name .)
    DIVIDE          reduce using rule 87 (access -> name MEMBER name .)
    LSHIFT          reduce using rule 87 (access -> name MEMBER name .)
    RSHIFT          reduce using rule 87 (access -> name MEMBER name .)
    PERCENT         reduce using rule 87 (access -> name MEMBER name .)
    BITAND          reduce using rule 87 (access -> name MEMBER name .)
    BITOR           reduce using rule 87 (access -> name MEMBER name .)
    EQ              reduce using rule 87 (access -> name MEMBER name .)
    NEQ             reduce using rule 87 (access -> name MEMBER name .)
    LT              reduce using rule 87 (access -> name MEMBER name .)
    GT              reduce using rule 87 (access -> name MEMBER name .)
    LE              reduce using rule 87 (access -> name MEMBER name .)
    GE              reduce using rule 87 (access -> name MEMBER name .)
    AND             reduce using rule 87 (access -> name MEMBER name .)
    OR              reduce using rule 87 (access -> name MEMBER name .)
    RPAREN          reduce using rule 87 (access -> name MEMBER name .)
    ID              reduce using rule 87 (access -> name MEMBER name .)
    SEMI            reduce using rule 87 (access -> name MEMBER name .)
    RBRACK          reduce using rule 87 (access -> name MEMBER name .)
    COMMA           reduce using rule 87 (access -> name MEMBER name .)
    CHAR            reduce using rule 87 (access -> name MEMBER name .)
    DOUBLE          reduce using rule 87 (access -> name MEMBER name .)
    FLOAT           reduce using rule 87 (access -> name MEMBER name .)
    INT             reduce using rule 87 (access -> name MEMBER name .)
    VOID            reduce using rule 87 (access -> name MEMBER name .)
    UINT8_T         reduce using rule 87 (access -> name MEMBER name .)
    UINT16_T        reduce using rule 87 (access -> name MEMBER name .)
    LPAREN          reduce using rule 87 (access -> name MEMBER name .)
    SIZEOF          reduce using rule 87 (access -> name MEMBER name .)
    FLOAT_L         reduce using rule 87 (access -> name MEMBER name .)
    INT_L           reduce using rule 87 (access -> name MEMBER name .)
    CHAR_L          reduce using rule 87 (access -> name MEMBER name .)
    STRING_L        reduce using rule 87 (access -> name MEMBER name .)
    NONDECIMAL_L    reduce using rule 87 (access -> name MEMBER name .)
    STRUCT          reduce using rule 87 (access -> name MEMBER name .)
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103

  ! LBRACK          [ reduce using rule 87 (access -> name MEMBER name .) ]
  ! MEMBER          [ reduce using rule 87 (access -> name MEMBER name .) ]


state 161

    (117) expression -> operand binop operand .
    (117) expression -> operand . binop operand
    (103) binop -> . PLUS
    (104) binop -> . MINUS
    (105) binop -> . ASTERISK
    (106) binop -> . DIVIDE
    (107) binop -> . LSHIFT
    (108) binop -> . RSHIFT
    (109) binop -> . PERCENT
    (110) binop -> . BITAND
    (111) binop -> . BITOR
    (112) binop -> . conditional
    (52) conditional -> . EQ
    (53) conditional -> . NEQ
    (54) conditional -> . LT
    (55) conditional -> . GT
    (56) conditional -> . LE
    (57) conditional -> . GE
    (58) conditional -> . AND
    (59) conditional -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
  ! shift/reduce conflict for BITAND resolved as shift
  ! shift/reduce conflict for BITOR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI            reduce using rule 117 (expression -> operand binop operand .)
    RPAREN          reduce using rule 117 (expression -> operand binop operand .)
    RBRACK          reduce using rule 117 (expression -> operand binop operand .)
    COMMA           reduce using rule 117 (expression -> operand binop operand .)
    ID              reduce using rule 117 (expression -> operand binop operand .)
    CHAR            reduce using rule 117 (expression -> operand binop operand .)
    DOUBLE          reduce using rule 117 (expression -> operand binop operand .)
    FLOAT           reduce using rule 117 (expression -> operand binop operand .)
    INT             reduce using rule 117 (expression -> operand binop operand .)
    VOID            reduce using rule 117 (expression -> operand binop operand .)
    UINT8_T         reduce using rule 117 (expression -> operand binop operand .)
    UINT16_T        reduce using rule 117 (expression -> operand binop operand .)
    LPAREN          reduce using rule 117 (expression -> operand binop operand .)
    SIZEOF          reduce using rule 117 (expression -> operand binop operand .)
    FLOAT_L         reduce using rule 117 (expression -> operand binop operand .)
    INT_L           reduce using rule 117 (expression -> operand binop operand .)
    CHAR_L          reduce using rule 117 (expression -> operand binop operand .)
    STRING_L        reduce using rule 117 (expression -> operand binop operand .)
    NONDECIMAL_L    reduce using rule 117 (expression -> operand binop operand .)
    STRUCT          reduce using rule 117 (expression -> operand binop operand .)
    PLUS            shift and go to state 109
    MINUS           shift and go to state 110
    ASTERISK        shift and go to state 111
    DIVIDE          shift and go to state 112
    LSHIFT          shift and go to state 113
    RSHIFT          shift and go to state 114
    PERCENT         shift and go to state 115
    BITAND          shift and go to state 116
    BITOR           shift and go to state 117
    EQ              shift and go to state 119
    NEQ             shift and go to state 120
    LT              shift and go to state 121
    GT              shift and go to state 122
    LE              shift and go to state 123
    GE              shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

  ! PLUS            [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! MINUS           [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! ASTERISK        [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! DIVIDE          [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! LSHIFT          [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! RSHIFT          [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! PERCENT         [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! BITAND          [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! BITOR           [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! EQ              [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! NEQ             [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! LT              [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! GT              [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! LE              [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! GE              [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! AND             [ reduce using rule 117 (expression -> operand binop operand .) ]
  ! OR              [ reduce using rule 117 (expression -> operand binop operand .) ]

    binop                          shift and go to state 108
    conditional                    shift and go to state 118

state 162

    (113) operand -> name .
    (118) expression -> name . INCREMENT
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

    SEMI            reduce using rule 113 (operand -> name .)
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITAND          reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              reduce using rule 113 (operand -> name .)
    NEQ             reduce using rule 113 (operand -> name .)
    LT              reduce using rule 113 (operand -> name .)
    GT              reduce using rule 113 (operand -> name .)
    LE              reduce using rule 113 (operand -> name .)
    GE              reduce using rule 113 (operand -> name .)
    AND             reduce using rule 113 (operand -> name .)
    OR              reduce using rule 113 (operand -> name .)
    RPAREN          reduce using rule 113 (operand -> name .)
    RBRACK          reduce using rule 113 (operand -> name .)
    COMMA           reduce using rule 113 (operand -> name .)
    ID              reduce using rule 113 (operand -> name .)
    CHAR            reduce using rule 113 (operand -> name .)
    DOUBLE          reduce using rule 113 (operand -> name .)
    FLOAT           reduce using rule 113 (operand -> name .)
    INT             reduce using rule 113 (operand -> name .)
    VOID            reduce using rule 113 (operand -> name .)
    UINT8_T         reduce using rule 113 (operand -> name .)
    UINT16_T        reduce using rule 113 (operand -> name .)
    LPAREN          reduce using rule 113 (operand -> name .)
    SIZEOF          reduce using rule 113 (operand -> name .)
    FLOAT_L         reduce using rule 113 (operand -> name .)
    INT_L           reduce using rule 113 (operand -> name .)
    CHAR_L          reduce using rule 113 (operand -> name .)
    STRING_L        reduce using rule 113 (operand -> name .)
    NONDECIMAL_L    reduce using rule 113 (operand -> name .)
    STRUCT          reduce using rule 113 (operand -> name .)
    INCREMENT       shift and go to state 100
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103


state 163

    (114) operand -> expression .

    SEMI            reduce using rule 114 (operand -> expression .)
    PLUS            reduce using rule 114 (operand -> expression .)
    MINUS           reduce using rule 114 (operand -> expression .)
    ASTERISK        reduce using rule 114 (operand -> expression .)
    DIVIDE          reduce using rule 114 (operand -> expression .)
    LSHIFT          reduce using rule 114 (operand -> expression .)
    RSHIFT          reduce using rule 114 (operand -> expression .)
    PERCENT         reduce using rule 114 (operand -> expression .)
    BITAND          reduce using rule 114 (operand -> expression .)
    BITOR           reduce using rule 114 (operand -> expression .)
    EQ              reduce using rule 114 (operand -> expression .)
    NEQ             reduce using rule 114 (operand -> expression .)
    LT              reduce using rule 114 (operand -> expression .)
    GT              reduce using rule 114 (operand -> expression .)
    LE              reduce using rule 114 (operand -> expression .)
    GE              reduce using rule 114 (operand -> expression .)
    AND             reduce using rule 114 (operand -> expression .)
    OR              reduce using rule 114 (operand -> expression .)
    RPAREN          reduce using rule 114 (operand -> expression .)
    RBRACK          reduce using rule 114 (operand -> expression .)
    COMMA           reduce using rule 114 (operand -> expression .)
    ID              reduce using rule 114 (operand -> expression .)
    CHAR            reduce using rule 114 (operand -> expression .)
    DOUBLE          reduce using rule 114 (operand -> expression .)
    FLOAT           reduce using rule 114 (operand -> expression .)
    INT             reduce using rule 114 (operand -> expression .)
    VOID            reduce using rule 114 (operand -> expression .)
    UINT8_T         reduce using rule 114 (operand -> expression .)
    UINT16_T        reduce using rule 114 (operand -> expression .)
    LPAREN          reduce using rule 114 (operand -> expression .)
    SIZEOF          reduce using rule 114 (operand -> expression .)
    FLOAT_L         reduce using rule 114 (operand -> expression .)
    INT_L           reduce using rule 114 (operand -> expression .)
    CHAR_L          reduce using rule 114 (operand -> expression .)
    STRING_L        reduce using rule 114 (operand -> expression .)
    NONDECIMAL_L    reduce using rule 114 (operand -> expression .)
    STRUCT          reduce using rule 114 (operand -> expression .)


state 164

    (83) func_call -> SIZEOF LPAREN func_arglist . RPAREN
    (78) func_arglist -> func_arglist . func_arg
    (79) func_arglist -> func_arglist . func_arg COMMA
    (70) func_arg -> . name
    (71) func_arg -> . dtype name
    (72) func_arg -> . dtype
    (73) func_arg -> . type_cast name
    (74) func_arg -> . type_cast expression
    (75) func_arg -> . func_call
    (76) func_arg -> . type_cast func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (18) struct_type -> . STRUCT name

    RPAREN          shift and go to state 188
    ID              shift and go to state 72
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    LPAREN          shift and go to state 170
    SIZEOF          shift and go to state 42
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    STRUCT          shift and go to state 74

    func_arg                       shift and go to state 172
    name                           shift and go to state 173
    dtype                          shift and go to state 174
    type_cast                      shift and go to state 175
    func_call                      shift and go to state 176
    literal                        shift and go to state 50
    access                         shift and go to state 51
    struct_type                    shift and go to state 34

state 165

    (66) for_loop -> FOR LPAREN init_var . conditional_expr SEMI ID INCREMENT RPAREN
    (60) conditional_expr -> . name conditional expression
    (61) conditional_expr -> . expression conditional name
    (62) conditional_expr -> . expression conditional expression
    (63) conditional_expr -> . name conditional name
    (64) conditional_expr -> . name
    (65) conditional_expr -> . expression
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN

    ID              shift and go to state 90
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    SIZEOF          shift and go to state 42

    conditional_expr               shift and go to state 189
    name                           shift and go to state 143
    expression                     shift and go to state 144
    literal                        shift and go to state 50
    access                         shift and go to state 51
    operand                        shift and go to state 41
    type_cast                      shift and go to state 49
    func_call                      shift and go to state 73

state 166

    (130) init_var_ls -> declare_var_ls . assign
    (131) init_var_ls -> declare_var_ls . vector_init assign
    (16) assign -> . SIMPLE_ASSIGN
    (17) assign -> . COMPLEX_ASSIGN
    (126) vector_init -> . LBRACK RBRACK
    (127) vector_init -> . LBRACK name RBRACK

    SIMPLE_ASSIGN   shift and go to state 97
    COMPLEX_ASSIGN  shift and go to state 98
    LBRACK          shift and go to state 99

    assign                         shift and go to state 95
    vector_init                    shift and go to state 96

state 167

    (123) declare_var_ls -> dtype . ID
    (41) dtype -> dtype . ASTERISK

    ID              shift and go to state 190
    ASTERISK        shift and go to state 67


state 168

    (124) declare_var_ls -> modifier dtype ID .

    SEMI            reduce using rule 124 (declare_var_ls -> modifier dtype ID .)
    SIMPLE_ASSIGN   reduce using rule 124 (declare_var_ls -> modifier dtype ID .)
    COMPLEX_ASSIGN  reduce using rule 124 (declare_var_ls -> modifier dtype ID .)
    LBRACK          reduce using rule 124 (declare_var_ls -> modifier dtype ID .)


state 169

    (80) func_def -> dtype ID LPAREN func_arglist . RPAREN LBRACE node_list RBRACE
    (84) func_decl -> dtype ID LPAREN func_arglist . RPAREN SEMI
    (78) func_arglist -> func_arglist . func_arg
    (79) func_arglist -> func_arglist . func_arg COMMA
    (70) func_arg -> . name
    (71) func_arg -> . dtype name
    (72) func_arg -> . dtype
    (73) func_arg -> . type_cast name
    (74) func_arg -> . type_cast expression
    (75) func_arg -> . func_call
    (76) func_arg -> . type_cast func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (18) struct_type -> . STRUCT name

    RPAREN          shift and go to state 191
    ID              shift and go to state 72
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    LPAREN          shift and go to state 170
    SIZEOF          shift and go to state 42
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    STRUCT          shift and go to state 74

    dtype                          shift and go to state 174
    func_arg                       shift and go to state 172
    name                           shift and go to state 173
    type_cast                      shift and go to state 175
    func_call                      shift and go to state 176
    literal                        shift and go to state 50
    access                         shift and go to state 51
    struct_type                    shift and go to state 34

state 170

    (19) type_cast -> LPAREN . dtype RPAREN
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (18) struct_type -> . STRUCT name

    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    ID              shift and go to state 132
    STRUCT          shift and go to state 74

    dtype                          shift and go to state 71
    struct_type                    shift and go to state 34

state 171

    (81) func_def -> ID LPAREN func_arglist RPAREN . LBRACE node_list RBRACE
    (82) func_call -> ID LPAREN func_arglist RPAREN .

    LBRACE          shift and go to state 192
    SEMI            reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    PLUS            reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    MINUS           reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    ASTERISK        reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    DIVIDE          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    LSHIFT          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    RSHIFT          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    PERCENT         reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    BITAND          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    BITOR           reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    EQ              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    NEQ             reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    LT              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    GT              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    LE              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    GE              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    AND             reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    OR              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)


state 172

    (78) func_arglist -> func_arglist func_arg .
    (79) func_arglist -> func_arglist func_arg . COMMA

    RPAREN          reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    ID              reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    CHAR            reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    DOUBLE          reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    FLOAT           reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    INT             reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    VOID            reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    UINT8_T         reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    UINT16_T        reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    LPAREN          reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    SIZEOF          reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    FLOAT_L         reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    INT_L           reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    CHAR_L          reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    STRING_L        reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    NONDECIMAL_L    reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    BITAND          reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    STRUCT          reduce using rule 78 (func_arglist -> func_arglist func_arg .)
    COMMA           shift and go to state 193


state 173

    (70) func_arg -> name .
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

    COMMA           reduce using rule 70 (func_arg -> name .)
    RPAREN          reduce using rule 70 (func_arg -> name .)
    ID              reduce using rule 70 (func_arg -> name .)
    CHAR            reduce using rule 70 (func_arg -> name .)
    DOUBLE          reduce using rule 70 (func_arg -> name .)
    FLOAT           reduce using rule 70 (func_arg -> name .)
    INT             reduce using rule 70 (func_arg -> name .)
    VOID            reduce using rule 70 (func_arg -> name .)
    UINT8_T         reduce using rule 70 (func_arg -> name .)
    UINT16_T        reduce using rule 70 (func_arg -> name .)
    LPAREN          reduce using rule 70 (func_arg -> name .)
    SIZEOF          reduce using rule 70 (func_arg -> name .)
    FLOAT_L         reduce using rule 70 (func_arg -> name .)
    INT_L           reduce using rule 70 (func_arg -> name .)
    CHAR_L          reduce using rule 70 (func_arg -> name .)
    STRING_L        reduce using rule 70 (func_arg -> name .)
    NONDECIMAL_L    reduce using rule 70 (func_arg -> name .)
    BITAND          reduce using rule 70 (func_arg -> name .)
    STRUCT          reduce using rule 70 (func_arg -> name .)
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103


state 174

    (71) func_arg -> dtype . name
    (72) func_arg -> dtype .
    (41) dtype -> dtype . ASTERISK
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT_L resolved as shift
  ! shift/reduce conflict for INT_L resolved as shift
  ! shift/reduce conflict for CHAR_L resolved as shift
  ! shift/reduce conflict for STRING_L resolved as shift
  ! shift/reduce conflict for NONDECIMAL_L resolved as shift
  ! shift/reduce conflict for BITAND resolved as shift
    COMMA           reduce using rule 72 (func_arg -> dtype .)
    RPAREN          reduce using rule 72 (func_arg -> dtype .)
    CHAR            reduce using rule 72 (func_arg -> dtype .)
    DOUBLE          reduce using rule 72 (func_arg -> dtype .)
    FLOAT           reduce using rule 72 (func_arg -> dtype .)
    INT             reduce using rule 72 (func_arg -> dtype .)
    VOID            reduce using rule 72 (func_arg -> dtype .)
    UINT8_T         reduce using rule 72 (func_arg -> dtype .)
    UINT16_T        reduce using rule 72 (func_arg -> dtype .)
    LPAREN          reduce using rule 72 (func_arg -> dtype .)
    SIZEOF          reduce using rule 72 (func_arg -> dtype .)
    STRUCT          reduce using rule 72 (func_arg -> dtype .)
    ASTERISK        shift and go to state 67
    ID              shift and go to state 134
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

  ! ID              [ reduce using rule 72 (func_arg -> dtype .) ]
  ! FLOAT_L         [ reduce using rule 72 (func_arg -> dtype .) ]
  ! INT_L           [ reduce using rule 72 (func_arg -> dtype .) ]
  ! CHAR_L          [ reduce using rule 72 (func_arg -> dtype .) ]
  ! STRING_L        [ reduce using rule 72 (func_arg -> dtype .) ]
  ! NONDECIMAL_L    [ reduce using rule 72 (func_arg -> dtype .) ]
  ! BITAND          [ reduce using rule 72 (func_arg -> dtype .) ]

    name                           shift and go to state 194
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 175

    (73) func_arg -> type_cast . name
    (74) func_arg -> type_cast . expression
    (76) func_arg -> type_cast . func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (19) type_cast -> . LPAREN dtype RPAREN

    ID              shift and go to state 90
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    SIZEOF          shift and go to state 42
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    type_cast                      shift and go to state 49
    name                           shift and go to state 195
    expression                     shift and go to state 196
    func_call                      shift and go to state 197
    literal                        shift and go to state 50
    access                         shift and go to state 51
    operand                        shift and go to state 41

state 176

    (75) func_arg -> func_call .

    COMMA           reduce using rule 75 (func_arg -> func_call .)
    RPAREN          reduce using rule 75 (func_arg -> func_call .)
    ID              reduce using rule 75 (func_arg -> func_call .)
    CHAR            reduce using rule 75 (func_arg -> func_call .)
    DOUBLE          reduce using rule 75 (func_arg -> func_call .)
    FLOAT           reduce using rule 75 (func_arg -> func_call .)
    INT             reduce using rule 75 (func_arg -> func_call .)
    VOID            reduce using rule 75 (func_arg -> func_call .)
    UINT8_T         reduce using rule 75 (func_arg -> func_call .)
    UINT16_T        reduce using rule 75 (func_arg -> func_call .)
    LPAREN          reduce using rule 75 (func_arg -> func_call .)
    SIZEOF          reduce using rule 75 (func_arg -> func_call .)
    FLOAT_L         reduce using rule 75 (func_arg -> func_call .)
    INT_L           reduce using rule 75 (func_arg -> func_call .)
    CHAR_L          reduce using rule 75 (func_arg -> func_call .)
    STRING_L        reduce using rule 75 (func_arg -> func_call .)
    NONDECIMAL_L    reduce using rule 75 (func_arg -> func_call .)
    BITAND          reduce using rule 75 (func_arg -> func_call .)
    STRUCT          reduce using rule 75 (func_arg -> func_call .)


state 177

    (82) func_call -> ID LPAREN func_arglist . RPAREN
    (78) func_arglist -> func_arglist . func_arg
    (79) func_arglist -> func_arglist . func_arg COMMA
    (70) func_arg -> . name
    (71) func_arg -> . dtype name
    (72) func_arg -> . dtype
    (73) func_arg -> . type_cast name
    (74) func_arg -> . type_cast expression
    (75) func_arg -> . func_call
    (76) func_arg -> . type_cast func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (18) struct_type -> . STRUCT name

    RPAREN          shift and go to state 198
    ID              shift and go to state 72
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    LPAREN          shift and go to state 170
    SIZEOF          shift and go to state 42
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    STRUCT          shift and go to state 74

    func_arg                       shift and go to state 172
    name                           shift and go to state 173
    dtype                          shift and go to state 174
    type_cast                      shift and go to state 175
    func_call                      shift and go to state 176
    literal                        shift and go to state 50
    access                         shift and go to state 51
    struct_type                    shift and go to state 34

state 178

    (67) control_expr -> control LPAREN conditional_expr RPAREN . LBRACE node_list RBRACE

    LBRACE          shift and go to state 199


state 179

    (60) conditional_expr -> name conditional . expression
    (63) conditional_expr -> name conditional . name
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN

    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    ID              shift and go to state 90
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    SIZEOF          shift and go to state 42

    name                           shift and go to state 200
    expression                     shift and go to state 201
    operand                        shift and go to state 41
    literal                        shift and go to state 50
    access                         shift and go to state 51
    type_cast                      shift and go to state 49
    func_call                      shift and go to state 73

state 180

    (61) conditional_expr -> expression conditional . name
    (62) conditional_expr -> expression conditional . expression
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (19) type_cast -> . LPAREN dtype RPAREN
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN

    ID              shift and go to state 90
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65
    SIZEOF          shift and go to state 42

    expression                     shift and go to state 202
    name                           shift and go to state 203
    literal                        shift and go to state 50
    access                         shift and go to state 51
    operand                        shift and go to state 41
    type_cast                      shift and go to state 49
    func_call                      shift and go to state 73

state 181

    (68) control_expr -> control LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    DEFINE          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    IFNDEF          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    ENDIF           reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    ID              reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    STRUCT          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    CHAR            reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    INT             reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    VOID            reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    LPAREN          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    NEGATE          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    MINUS           reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    SIZEOF          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    RETURN          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    WHILE           reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    IF              reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    ELSE            reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    FOR             reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    CONST           reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    INLINE          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    LONG            reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    SHORT           reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    FLOAT_L         reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    INT_L           reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    CHAR_L          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    STRING_L        reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    NONDECIMAL_L    reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    BITAND          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    $end            reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 68 (control_expr -> control LBRACE node_list RBRACE .)


state 182

    (69) control_expr -> for_loop LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    DEFINE          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    IFNDEF          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    ENDIF           reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    ID              reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    STRUCT          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    CHAR            reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    INT             reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    VOID            reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    LPAREN          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    NEGATE          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    MINUS           reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    SIZEOF          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    RETURN          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    WHILE           reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    IF              reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    ELSE            reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    FOR             reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    CONST           reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    INLINE          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    LONG            reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    SHORT           reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    FLOAT_L         reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    INT_L           reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    CHAR_L          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    STRING_L        reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    NONDECIMAL_L    reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    BITAND          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    $end            reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 69 (control_expr -> for_loop LBRACE node_list RBRACE .)


state 183

    (89) struct_def -> STRUCT ID LBRACE node_list . RBRACE SEMI
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (45) include -> . INCLUDE
    (46) define -> . DEFINE
    (47) if -> . IFNDEF
    (48) if -> . ENDIF
    (80) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (81) func_def -> . ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (84) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (91) statement -> . init_var
    (92) statement -> . assign_var
    (93) statement -> . declare_var
    (94) statement -> . expression SEMI
    (95) statement -> . func_call SEMI
    (96) statement -> . return SEMI
    (67) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (68) control_expr -> . control LBRACE node_list RBRACE
    (69) control_expr -> . for_loop LBRACE node_list RBRACE
    (89) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (139) init_var -> . init_var_ls init_var_rs
    (142) assign_var -> . assign_var_ls assign_var_rs
    (125) declare_var -> . declare_var_ls SEMI
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (119) return -> . RETURN name
    (120) return -> . RETURN expression
    (49) control -> . WHILE
    (50) control -> . IF
    (51) control -> . ELSE
    (66) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT name
    (130) init_var_ls -> . declare_var_ls assign
    (131) init_var_ls -> . declare_var_ls vector_init assign
    (140) assign_var_ls -> . name assign
    (123) declare_var_ls -> . dtype ID
    (124) declare_var_ls -> . modifier dtype ID
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (20) modifier -> . CONST
    (21) modifier -> . EXTERN
    (22) modifier -> . INLINE
    (23) modifier -> . LONG
    (24) modifier -> . SHORT
    (25) modifier -> . SIGNED
    (26) modifier -> . UNSIGNED
    (27) modifier -> . VOLATILE
    (19) type_cast -> . LPAREN dtype RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    RBRACE          shift and go to state 204
    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    ID              shift and go to state 16
    STRUCT          shift and go to state 26
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    SIZEOF          shift and go to state 42
    RETURN          shift and go to state 43
    WHILE           shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    FOR             shift and go to state 47
    CONST           shift and go to state 52
    EXTERN          shift and go to state 53
    INLINE          shift and go to state 54
    LONG            shift and go to state 55
    SHORT           shift and go to state 56
    SIGNED          shift and go to state 57
    UNSIGNED        shift and go to state 58
    VOLATILE        shift and go to state 59
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    dtype                          shift and go to state 15
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    return                         shift and go to state 23
    control                        shift and go to state 24
    for_loop                       shift and go to state 25
    struct_type                    shift and go to state 34
    init_var_ls                    shift and go to state 35
    assign_var_ls                  shift and go to state 36
    declare_var_ls                 shift and go to state 37
    name                           shift and go to state 38
    operand                        shift and go to state 41
    modifier                       shift and go to state 48
    type_cast                      shift and go to state 49
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 184

    (137) init_var_rs -> LPAREN name RPAREN .
    (98) expression -> LPAREN name RPAREN .

  ! reduce/reduce conflict for MINUS resolved using rule 98 (expression -> LPAREN name RPAREN .)
  ! reduce/reduce conflict for BITAND resolved using rule 98 (expression -> LPAREN name RPAREN .)
    INCLUDE         reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    DEFINE          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    IFNDEF          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    ENDIF           reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    ID              reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    STRUCT          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    CHAR            reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    DOUBLE          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    FLOAT           reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    INT             reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    VOID            reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    UINT8_T         reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    UINT16_T        reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    LPAREN          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    NEGATE          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    SIZEOF          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    RETURN          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    WHILE           reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    IF              reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    ELSE            reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    FOR             reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    CONST           reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    EXTERN          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    INLINE          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    LONG            reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    SHORT           reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    SIGNED          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    UNSIGNED        reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    VOLATILE        reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    FLOAT_L         reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    INT_L           reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    CHAR_L          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    STRING_L        reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    NONDECIMAL_L    reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    $end            reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    RBRACE          reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .)
    SEMI            reduce using rule 98 (expression -> LPAREN name RPAREN .)
    PLUS            reduce using rule 98 (expression -> LPAREN name RPAREN .)
    MINUS           reduce using rule 98 (expression -> LPAREN name RPAREN .)
    ASTERISK        reduce using rule 98 (expression -> LPAREN name RPAREN .)
    DIVIDE          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    LSHIFT          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    RSHIFT          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    PERCENT         reduce using rule 98 (expression -> LPAREN name RPAREN .)
    BITAND          reduce using rule 98 (expression -> LPAREN name RPAREN .)
    BITOR           reduce using rule 98 (expression -> LPAREN name RPAREN .)
    EQ              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    NEQ             reduce using rule 98 (expression -> LPAREN name RPAREN .)
    LT              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    GT              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    LE              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    GE              reduce using rule 98 (expression -> LPAREN name RPAREN .)
    AND             reduce using rule 98 (expression -> LPAREN name RPAREN .)
    OR              reduce using rule 98 (expression -> LPAREN name RPAREN .)

  ! MINUS           [ reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .) ]
  ! BITAND          [ reduce using rule 137 (init_var_rs -> LPAREN name RPAREN .) ]


state 185

    (127) vector_init -> LBRACK name RBRACK .

    SIMPLE_ASSIGN   reduce using rule 127 (vector_init -> LBRACK name RBRACK .)
    COMPLEX_ASSIGN  reduce using rule 127 (vector_init -> LBRACK name RBRACK .)


state 186

    (85) access -> name LBRACK name RBRACK .

    INCREMENT       reduce using rule 85 (access -> name LBRACK name RBRACK .)
    LBRACK          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    MEMBER          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    SIMPLE_ASSIGN   reduce using rule 85 (access -> name LBRACK name RBRACK .)
    COMPLEX_ASSIGN  reduce using rule 85 (access -> name LBRACK name RBRACK .)
    PLUS            reduce using rule 85 (access -> name LBRACK name RBRACK .)
    MINUS           reduce using rule 85 (access -> name LBRACK name RBRACK .)
    ASTERISK        reduce using rule 85 (access -> name LBRACK name RBRACK .)
    DIVIDE          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    LSHIFT          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    RSHIFT          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    PERCENT         reduce using rule 85 (access -> name LBRACK name RBRACK .)
    BITAND          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    BITOR           reduce using rule 85 (access -> name LBRACK name RBRACK .)
    EQ              reduce using rule 85 (access -> name LBRACK name RBRACK .)
    NEQ             reduce using rule 85 (access -> name LBRACK name RBRACK .)
    LT              reduce using rule 85 (access -> name LBRACK name RBRACK .)
    GT              reduce using rule 85 (access -> name LBRACK name RBRACK .)
    LE              reduce using rule 85 (access -> name LBRACK name RBRACK .)
    GE              reduce using rule 85 (access -> name LBRACK name RBRACK .)
    AND             reduce using rule 85 (access -> name LBRACK name RBRACK .)
    OR              reduce using rule 85 (access -> name LBRACK name RBRACK .)
    RPAREN          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    ID              reduce using rule 85 (access -> name LBRACK name RBRACK .)
    SEMI            reduce using rule 85 (access -> name LBRACK name RBRACK .)
    RBRACK          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    COMMA           reduce using rule 85 (access -> name LBRACK name RBRACK .)
    CHAR            reduce using rule 85 (access -> name LBRACK name RBRACK .)
    DOUBLE          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    FLOAT           reduce using rule 85 (access -> name LBRACK name RBRACK .)
    INT             reduce using rule 85 (access -> name LBRACK name RBRACK .)
    VOID            reduce using rule 85 (access -> name LBRACK name RBRACK .)
    UINT8_T         reduce using rule 85 (access -> name LBRACK name RBRACK .)
    UINT16_T        reduce using rule 85 (access -> name LBRACK name RBRACK .)
    LPAREN          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    SIZEOF          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    FLOAT_L         reduce using rule 85 (access -> name LBRACK name RBRACK .)
    INT_L           reduce using rule 85 (access -> name LBRACK name RBRACK .)
    CHAR_L          reduce using rule 85 (access -> name LBRACK name RBRACK .)
    STRING_L        reduce using rule 85 (access -> name LBRACK name RBRACK .)
    NONDECIMAL_L    reduce using rule 85 (access -> name LBRACK name RBRACK .)
    STRUCT          reduce using rule 85 (access -> name LBRACK name RBRACK .)


state 187

    (86) access -> name LBRACK expression RBRACK .

    INCREMENT       reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    LBRACK          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    MEMBER          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    SIMPLE_ASSIGN   reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    COMPLEX_ASSIGN  reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    PLUS            reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    MINUS           reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    ASTERISK        reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    DIVIDE          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    LSHIFT          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    RSHIFT          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    PERCENT         reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    BITAND          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    BITOR           reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    EQ              reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    NEQ             reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    LT              reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    GT              reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    LE              reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    GE              reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    AND             reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    OR              reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    RPAREN          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    ID              reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    SEMI            reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    RBRACK          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    COMMA           reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    CHAR            reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    DOUBLE          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    FLOAT           reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    INT             reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    VOID            reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    UINT8_T         reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    UINT16_T        reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    LPAREN          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    SIZEOF          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    FLOAT_L         reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    INT_L           reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    CHAR_L          reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    STRING_L        reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    NONDECIMAL_L    reduce using rule 86 (access -> name LBRACK expression RBRACK .)
    STRUCT          reduce using rule 86 (access -> name LBRACK expression RBRACK .)


state 188

    (83) func_call -> SIZEOF LPAREN func_arglist RPAREN .

    SEMI            reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    PLUS            reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    MINUS           reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    ASTERISK        reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    DIVIDE          reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    LSHIFT          reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    RSHIFT          reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    PERCENT         reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    BITAND          reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    BITOR           reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    EQ              reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    NEQ             reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    LT              reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    GT              reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    LE              reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    GE              reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    AND             reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    OR              reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    RPAREN          reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    RBRACK          reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    COMMA           reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    ID              reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    CHAR            reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    DOUBLE          reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    FLOAT           reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    INT             reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    VOID            reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    UINT8_T         reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    UINT16_T        reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    LPAREN          reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    SIZEOF          reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    FLOAT_L         reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    INT_L           reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    CHAR_L          reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    STRING_L        reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    NONDECIMAL_L    reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)
    STRUCT          reduce using rule 83 (func_call -> SIZEOF LPAREN func_arglist RPAREN .)


state 189

    (66) for_loop -> FOR LPAREN init_var conditional_expr . SEMI ID INCREMENT RPAREN

    SEMI            shift and go to state 205


state 190

    (123) declare_var_ls -> dtype ID .

    SIMPLE_ASSIGN   reduce using rule 123 (declare_var_ls -> dtype ID .)
    COMPLEX_ASSIGN  reduce using rule 123 (declare_var_ls -> dtype ID .)
    LBRACK          reduce using rule 123 (declare_var_ls -> dtype ID .)


state 191

    (80) func_def -> dtype ID LPAREN func_arglist RPAREN . LBRACE node_list RBRACE
    (84) func_decl -> dtype ID LPAREN func_arglist RPAREN . SEMI

    LBRACE          shift and go to state 206
    SEMI            shift and go to state 207


state 192

    (81) func_def -> ID LPAREN func_arglist RPAREN LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    SIZEOF          reduce using rule 1 (node_list -> .)
    RETURN          reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)
    BITAND          reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 208

state 193

    (79) func_arglist -> func_arglist func_arg COMMA .

    RPAREN          reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    ID              reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    CHAR            reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    DOUBLE          reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    FLOAT           reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    INT             reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    VOID            reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    UINT8_T         reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    UINT16_T        reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    LPAREN          reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    SIZEOF          reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    FLOAT_L         reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    INT_L           reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    CHAR_L          reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    STRING_L        reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    NONDECIMAL_L    reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    BITAND          reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)
    STRUCT          reduce using rule 79 (func_arglist -> func_arglist func_arg COMMA .)


state 194

    (71) func_arg -> dtype name .
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

    COMMA           reduce using rule 71 (func_arg -> dtype name .)
    RPAREN          reduce using rule 71 (func_arg -> dtype name .)
    ID              reduce using rule 71 (func_arg -> dtype name .)
    CHAR            reduce using rule 71 (func_arg -> dtype name .)
    DOUBLE          reduce using rule 71 (func_arg -> dtype name .)
    FLOAT           reduce using rule 71 (func_arg -> dtype name .)
    INT             reduce using rule 71 (func_arg -> dtype name .)
    VOID            reduce using rule 71 (func_arg -> dtype name .)
    UINT8_T         reduce using rule 71 (func_arg -> dtype name .)
    UINT16_T        reduce using rule 71 (func_arg -> dtype name .)
    LPAREN          reduce using rule 71 (func_arg -> dtype name .)
    SIZEOF          reduce using rule 71 (func_arg -> dtype name .)
    FLOAT_L         reduce using rule 71 (func_arg -> dtype name .)
    INT_L           reduce using rule 71 (func_arg -> dtype name .)
    CHAR_L          reduce using rule 71 (func_arg -> dtype name .)
    STRING_L        reduce using rule 71 (func_arg -> dtype name .)
    NONDECIMAL_L    reduce using rule 71 (func_arg -> dtype name .)
    BITAND          reduce using rule 71 (func_arg -> dtype name .)
    STRUCT          reduce using rule 71 (func_arg -> dtype name .)
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103


state 195

    (73) func_arg -> type_cast name .
    (118) expression -> name . INCREMENT
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name
    (113) operand -> name .

  ! reduce/reduce conflict for BITAND resolved using rule 73 (func_arg -> type_cast name .)
    COMMA           reduce using rule 73 (func_arg -> type_cast name .)
    RPAREN          reduce using rule 73 (func_arg -> type_cast name .)
    ID              reduce using rule 73 (func_arg -> type_cast name .)
    CHAR            reduce using rule 73 (func_arg -> type_cast name .)
    DOUBLE          reduce using rule 73 (func_arg -> type_cast name .)
    FLOAT           reduce using rule 73 (func_arg -> type_cast name .)
    INT             reduce using rule 73 (func_arg -> type_cast name .)
    VOID            reduce using rule 73 (func_arg -> type_cast name .)
    UINT8_T         reduce using rule 73 (func_arg -> type_cast name .)
    UINT16_T        reduce using rule 73 (func_arg -> type_cast name .)
    LPAREN          reduce using rule 73 (func_arg -> type_cast name .)
    SIZEOF          reduce using rule 73 (func_arg -> type_cast name .)
    FLOAT_L         reduce using rule 73 (func_arg -> type_cast name .)
    INT_L           reduce using rule 73 (func_arg -> type_cast name .)
    CHAR_L          reduce using rule 73 (func_arg -> type_cast name .)
    STRING_L        reduce using rule 73 (func_arg -> type_cast name .)
    NONDECIMAL_L    reduce using rule 73 (func_arg -> type_cast name .)
    BITAND          reduce using rule 73 (func_arg -> type_cast name .)
    STRUCT          reduce using rule 73 (func_arg -> type_cast name .)
    INCREMENT       shift and go to state 100
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              reduce using rule 113 (operand -> name .)
    NEQ             reduce using rule 113 (operand -> name .)
    LT              reduce using rule 113 (operand -> name .)
    GT              reduce using rule 113 (operand -> name .)
    LE              reduce using rule 113 (operand -> name .)
    GE              reduce using rule 113 (operand -> name .)
    AND             reduce using rule 113 (operand -> name .)
    OR              reduce using rule 113 (operand -> name .)

  ! BITAND          [ reduce using rule 113 (operand -> name .) ]


state 196

    (74) func_arg -> type_cast expression .
    (114) operand -> expression .

  ! reduce/reduce conflict for BITAND resolved using rule 74 (func_arg -> type_cast expression .)
    COMMA           reduce using rule 74 (func_arg -> type_cast expression .)
    RPAREN          reduce using rule 74 (func_arg -> type_cast expression .)
    ID              reduce using rule 74 (func_arg -> type_cast expression .)
    CHAR            reduce using rule 74 (func_arg -> type_cast expression .)
    DOUBLE          reduce using rule 74 (func_arg -> type_cast expression .)
    FLOAT           reduce using rule 74 (func_arg -> type_cast expression .)
    INT             reduce using rule 74 (func_arg -> type_cast expression .)
    VOID            reduce using rule 74 (func_arg -> type_cast expression .)
    UINT8_T         reduce using rule 74 (func_arg -> type_cast expression .)
    UINT16_T        reduce using rule 74 (func_arg -> type_cast expression .)
    LPAREN          reduce using rule 74 (func_arg -> type_cast expression .)
    SIZEOF          reduce using rule 74 (func_arg -> type_cast expression .)
    FLOAT_L         reduce using rule 74 (func_arg -> type_cast expression .)
    INT_L           reduce using rule 74 (func_arg -> type_cast expression .)
    CHAR_L          reduce using rule 74 (func_arg -> type_cast expression .)
    STRING_L        reduce using rule 74 (func_arg -> type_cast expression .)
    NONDECIMAL_L    reduce using rule 74 (func_arg -> type_cast expression .)
    BITAND          reduce using rule 74 (func_arg -> type_cast expression .)
    STRUCT          reduce using rule 74 (func_arg -> type_cast expression .)
    PLUS            reduce using rule 114 (operand -> expression .)
    MINUS           reduce using rule 114 (operand -> expression .)
    ASTERISK        reduce using rule 114 (operand -> expression .)
    DIVIDE          reduce using rule 114 (operand -> expression .)
    LSHIFT          reduce using rule 114 (operand -> expression .)
    RSHIFT          reduce using rule 114 (operand -> expression .)
    PERCENT         reduce using rule 114 (operand -> expression .)
    BITOR           reduce using rule 114 (operand -> expression .)
    EQ              reduce using rule 114 (operand -> expression .)
    NEQ             reduce using rule 114 (operand -> expression .)
    LT              reduce using rule 114 (operand -> expression .)
    GT              reduce using rule 114 (operand -> expression .)
    LE              reduce using rule 114 (operand -> expression .)
    GE              reduce using rule 114 (operand -> expression .)
    AND             reduce using rule 114 (operand -> expression .)
    OR              reduce using rule 114 (operand -> expression .)

  ! BITAND          [ reduce using rule 114 (operand -> expression .) ]


state 197

    (76) func_arg -> type_cast func_call .
    (116) operand -> func_call .

  ! reduce/reduce conflict for BITAND resolved using rule 76 (func_arg -> type_cast func_call .)
    COMMA           reduce using rule 76 (func_arg -> type_cast func_call .)
    RPAREN          reduce using rule 76 (func_arg -> type_cast func_call .)
    ID              reduce using rule 76 (func_arg -> type_cast func_call .)
    CHAR            reduce using rule 76 (func_arg -> type_cast func_call .)
    DOUBLE          reduce using rule 76 (func_arg -> type_cast func_call .)
    FLOAT           reduce using rule 76 (func_arg -> type_cast func_call .)
    INT             reduce using rule 76 (func_arg -> type_cast func_call .)
    VOID            reduce using rule 76 (func_arg -> type_cast func_call .)
    UINT8_T         reduce using rule 76 (func_arg -> type_cast func_call .)
    UINT16_T        reduce using rule 76 (func_arg -> type_cast func_call .)
    LPAREN          reduce using rule 76 (func_arg -> type_cast func_call .)
    SIZEOF          reduce using rule 76 (func_arg -> type_cast func_call .)
    FLOAT_L         reduce using rule 76 (func_arg -> type_cast func_call .)
    INT_L           reduce using rule 76 (func_arg -> type_cast func_call .)
    CHAR_L          reduce using rule 76 (func_arg -> type_cast func_call .)
    STRING_L        reduce using rule 76 (func_arg -> type_cast func_call .)
    NONDECIMAL_L    reduce using rule 76 (func_arg -> type_cast func_call .)
    BITAND          reduce using rule 76 (func_arg -> type_cast func_call .)
    STRUCT          reduce using rule 76 (func_arg -> type_cast func_call .)
    PLUS            reduce using rule 116 (operand -> func_call .)
    MINUS           reduce using rule 116 (operand -> func_call .)
    ASTERISK        reduce using rule 116 (operand -> func_call .)
    DIVIDE          reduce using rule 116 (operand -> func_call .)
    LSHIFT          reduce using rule 116 (operand -> func_call .)
    RSHIFT          reduce using rule 116 (operand -> func_call .)
    PERCENT         reduce using rule 116 (operand -> func_call .)
    BITOR           reduce using rule 116 (operand -> func_call .)
    EQ              reduce using rule 116 (operand -> func_call .)
    NEQ             reduce using rule 116 (operand -> func_call .)
    LT              reduce using rule 116 (operand -> func_call .)
    GT              reduce using rule 116 (operand -> func_call .)
    LE              reduce using rule 116 (operand -> func_call .)
    GE              reduce using rule 116 (operand -> func_call .)
    AND             reduce using rule 116 (operand -> func_call .)
    OR              reduce using rule 116 (operand -> func_call .)

  ! BITAND          [ reduce using rule 116 (operand -> func_call .) ]


state 198

    (82) func_call -> ID LPAREN func_arglist RPAREN .

    PLUS            reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    MINUS           reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    ASTERISK        reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    DIVIDE          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    LSHIFT          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    RSHIFT          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    PERCENT         reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    BITAND          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    BITOR           reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    EQ              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    NEQ             reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    LT              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    GT              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    LE              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    GE              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    AND             reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    OR              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    SEMI            reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    RPAREN          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    RBRACK          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    COMMA           reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    ID              reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    CHAR            reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    DOUBLE          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    FLOAT           reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    INT             reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    VOID            reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    UINT8_T         reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    UINT16_T        reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    LPAREN          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    SIZEOF          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    FLOAT_L         reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    INT_L           reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    CHAR_L          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    STRING_L        reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    NONDECIMAL_L    reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)
    STRUCT          reduce using rule 82 (func_call -> ID LPAREN func_arglist RPAREN .)


state 199

    (67) control_expr -> control LPAREN conditional_expr RPAREN LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    SIZEOF          reduce using rule 1 (node_list -> .)
    RETURN          reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)
    BITAND          reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 209

state 200

    (63) conditional_expr -> name conditional name .
    (118) expression -> name . INCREMENT
    (113) operand -> name .
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name

    RPAREN          reduce using rule 63 (conditional_expr -> name conditional name .)
    SEMI            reduce using rule 63 (conditional_expr -> name conditional name .)
    INCREMENT       shift and go to state 100
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITAND          reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              reduce using rule 113 (operand -> name .)
    NEQ             reduce using rule 113 (operand -> name .)
    LT              reduce using rule 113 (operand -> name .)
    GT              reduce using rule 113 (operand -> name .)
    LE              reduce using rule 113 (operand -> name .)
    GE              reduce using rule 113 (operand -> name .)
    AND             reduce using rule 113 (operand -> name .)
    OR              reduce using rule 113 (operand -> name .)
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103


state 201

    (60) conditional_expr -> name conditional expression .
    (114) operand -> expression .

    RPAREN          reduce using rule 60 (conditional_expr -> name conditional expression .)
    SEMI            reduce using rule 60 (conditional_expr -> name conditional expression .)
    PLUS            reduce using rule 114 (operand -> expression .)
    MINUS           reduce using rule 114 (operand -> expression .)
    ASTERISK        reduce using rule 114 (operand -> expression .)
    DIVIDE          reduce using rule 114 (operand -> expression .)
    LSHIFT          reduce using rule 114 (operand -> expression .)
    RSHIFT          reduce using rule 114 (operand -> expression .)
    PERCENT         reduce using rule 114 (operand -> expression .)
    BITAND          reduce using rule 114 (operand -> expression .)
    BITOR           reduce using rule 114 (operand -> expression .)
    EQ              reduce using rule 114 (operand -> expression .)
    NEQ             reduce using rule 114 (operand -> expression .)
    LT              reduce using rule 114 (operand -> expression .)
    GT              reduce using rule 114 (operand -> expression .)
    LE              reduce using rule 114 (operand -> expression .)
    GE              reduce using rule 114 (operand -> expression .)
    AND             reduce using rule 114 (operand -> expression .)
    OR              reduce using rule 114 (operand -> expression .)


state 202

    (62) conditional_expr -> expression conditional expression .
    (114) operand -> expression .

    RPAREN          reduce using rule 62 (conditional_expr -> expression conditional expression .)
    SEMI            reduce using rule 62 (conditional_expr -> expression conditional expression .)
    PLUS            reduce using rule 114 (operand -> expression .)
    MINUS           reduce using rule 114 (operand -> expression .)
    ASTERISK        reduce using rule 114 (operand -> expression .)
    DIVIDE          reduce using rule 114 (operand -> expression .)
    LSHIFT          reduce using rule 114 (operand -> expression .)
    RSHIFT          reduce using rule 114 (operand -> expression .)
    PERCENT         reduce using rule 114 (operand -> expression .)
    BITAND          reduce using rule 114 (operand -> expression .)
    BITOR           reduce using rule 114 (operand -> expression .)
    EQ              reduce using rule 114 (operand -> expression .)
    NEQ             reduce using rule 114 (operand -> expression .)
    LT              reduce using rule 114 (operand -> expression .)
    GT              reduce using rule 114 (operand -> expression .)
    LE              reduce using rule 114 (operand -> expression .)
    GE              reduce using rule 114 (operand -> expression .)
    AND             reduce using rule 114 (operand -> expression .)
    OR              reduce using rule 114 (operand -> expression .)


state 203

    (61) conditional_expr -> expression conditional name .
    (118) expression -> name . INCREMENT
    (85) access -> name . LBRACK name RBRACK
    (86) access -> name . LBRACK expression RBRACK
    (87) access -> name . MEMBER name
    (113) operand -> name .

    RPAREN          reduce using rule 61 (conditional_expr -> expression conditional name .)
    SEMI            reduce using rule 61 (conditional_expr -> expression conditional name .)
    INCREMENT       shift and go to state 100
    LBRACK          shift and go to state 102
    MEMBER          shift and go to state 103
    PLUS            reduce using rule 113 (operand -> name .)
    MINUS           reduce using rule 113 (operand -> name .)
    ASTERISK        reduce using rule 113 (operand -> name .)
    DIVIDE          reduce using rule 113 (operand -> name .)
    LSHIFT          reduce using rule 113 (operand -> name .)
    RSHIFT          reduce using rule 113 (operand -> name .)
    PERCENT         reduce using rule 113 (operand -> name .)
    BITAND          reduce using rule 113 (operand -> name .)
    BITOR           reduce using rule 113 (operand -> name .)
    EQ              reduce using rule 113 (operand -> name .)
    NEQ             reduce using rule 113 (operand -> name .)
    LT              reduce using rule 113 (operand -> name .)
    GT              reduce using rule 113 (operand -> name .)
    LE              reduce using rule 113 (operand -> name .)
    GE              reduce using rule 113 (operand -> name .)
    AND             reduce using rule 113 (operand -> name .)
    OR              reduce using rule 113 (operand -> name .)


state 204

    (89) struct_def -> STRUCT ID LBRACE node_list RBRACE . SEMI

    SEMI            shift and go to state 210


state 205

    (66) for_loop -> FOR LPAREN init_var conditional_expr SEMI . ID INCREMENT RPAREN

    ID              shift and go to state 211


state 206

    (80) func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    DEFINE          reduce using rule 1 (node_list -> .)
    IFNDEF          reduce using rule 1 (node_list -> .)
    ENDIF           reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    STRUCT          reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    LPAREN          reduce using rule 1 (node_list -> .)
    NEGATE          reduce using rule 1 (node_list -> .)
    MINUS           reduce using rule 1 (node_list -> .)
    SIZEOF          reduce using rule 1 (node_list -> .)
    RETURN          reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    FLOAT_L         reduce using rule 1 (node_list -> .)
    INT_L           reduce using rule 1 (node_list -> .)
    CHAR_L          reduce using rule 1 (node_list -> .)
    STRING_L        reduce using rule 1 (node_list -> .)
    NONDECIMAL_L    reduce using rule 1 (node_list -> .)
    BITAND          reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 212

state 207

    (84) func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .

    INCLUDE         reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    DEFINE          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    IFNDEF          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    ENDIF           reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    ID              reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    STRUCT          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    CHAR            reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    DOUBLE          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    FLOAT           reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    INT             reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    VOID            reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    UINT8_T         reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    UINT16_T        reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    LPAREN          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    NEGATE          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    MINUS           reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    SIZEOF          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    RETURN          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    WHILE           reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    IF              reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    ELSE            reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    FOR             reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    CONST           reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    EXTERN          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    INLINE          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    LONG            reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    SHORT           reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    SIGNED          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    UNSIGNED        reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    VOLATILE        reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    FLOAT_L         reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    INT_L           reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    CHAR_L          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    STRING_L        reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    NONDECIMAL_L    reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    BITAND          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    $end            reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)
    RBRACE          reduce using rule 84 (func_decl -> dtype ID LPAREN func_arglist RPAREN SEMI .)


state 208

    (81) func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (45) include -> . INCLUDE
    (46) define -> . DEFINE
    (47) if -> . IFNDEF
    (48) if -> . ENDIF
    (80) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (81) func_def -> . ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (84) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (91) statement -> . init_var
    (92) statement -> . assign_var
    (93) statement -> . declare_var
    (94) statement -> . expression SEMI
    (95) statement -> . func_call SEMI
    (96) statement -> . return SEMI
    (67) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (68) control_expr -> . control LBRACE node_list RBRACE
    (69) control_expr -> . for_loop LBRACE node_list RBRACE
    (89) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (139) init_var -> . init_var_ls init_var_rs
    (142) assign_var -> . assign_var_ls assign_var_rs
    (125) declare_var -> . declare_var_ls SEMI
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (119) return -> . RETURN name
    (120) return -> . RETURN expression
    (49) control -> . WHILE
    (50) control -> . IF
    (51) control -> . ELSE
    (66) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT name
    (130) init_var_ls -> . declare_var_ls assign
    (131) init_var_ls -> . declare_var_ls vector_init assign
    (140) assign_var_ls -> . name assign
    (123) declare_var_ls -> . dtype ID
    (124) declare_var_ls -> . modifier dtype ID
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (20) modifier -> . CONST
    (21) modifier -> . EXTERN
    (22) modifier -> . INLINE
    (23) modifier -> . LONG
    (24) modifier -> . SHORT
    (25) modifier -> . SIGNED
    (26) modifier -> . UNSIGNED
    (27) modifier -> . VOLATILE
    (19) type_cast -> . LPAREN dtype RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    RBRACE          shift and go to state 213
    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    ID              shift and go to state 16
    STRUCT          shift and go to state 26
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    SIZEOF          shift and go to state 42
    RETURN          shift and go to state 43
    WHILE           shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    FOR             shift and go to state 47
    CONST           shift and go to state 52
    EXTERN          shift and go to state 53
    INLINE          shift and go to state 54
    LONG            shift and go to state 55
    SHORT           shift and go to state 56
    SIGNED          shift and go to state 57
    UNSIGNED        shift and go to state 58
    VOLATILE        shift and go to state 59
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    dtype                          shift and go to state 15
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    return                         shift and go to state 23
    control                        shift and go to state 24
    for_loop                       shift and go to state 25
    struct_type                    shift and go to state 34
    init_var_ls                    shift and go to state 35
    assign_var_ls                  shift and go to state 36
    declare_var_ls                 shift and go to state 37
    name                           shift and go to state 38
    operand                        shift and go to state 41
    modifier                       shift and go to state 48
    type_cast                      shift and go to state 49
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 209

    (67) control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (45) include -> . INCLUDE
    (46) define -> . DEFINE
    (47) if -> . IFNDEF
    (48) if -> . ENDIF
    (80) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (81) func_def -> . ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (84) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (91) statement -> . init_var
    (92) statement -> . assign_var
    (93) statement -> . declare_var
    (94) statement -> . expression SEMI
    (95) statement -> . func_call SEMI
    (96) statement -> . return SEMI
    (67) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (68) control_expr -> . control LBRACE node_list RBRACE
    (69) control_expr -> . for_loop LBRACE node_list RBRACE
    (89) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (139) init_var -> . init_var_ls init_var_rs
    (142) assign_var -> . assign_var_ls assign_var_rs
    (125) declare_var -> . declare_var_ls SEMI
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (119) return -> . RETURN name
    (120) return -> . RETURN expression
    (49) control -> . WHILE
    (50) control -> . IF
    (51) control -> . ELSE
    (66) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT name
    (130) init_var_ls -> . declare_var_ls assign
    (131) init_var_ls -> . declare_var_ls vector_init assign
    (140) assign_var_ls -> . name assign
    (123) declare_var_ls -> . dtype ID
    (124) declare_var_ls -> . modifier dtype ID
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (20) modifier -> . CONST
    (21) modifier -> . EXTERN
    (22) modifier -> . INLINE
    (23) modifier -> . LONG
    (24) modifier -> . SHORT
    (25) modifier -> . SIGNED
    (26) modifier -> . UNSIGNED
    (27) modifier -> . VOLATILE
    (19) type_cast -> . LPAREN dtype RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    RBRACE          shift and go to state 214
    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    ID              shift and go to state 16
    STRUCT          shift and go to state 26
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    SIZEOF          shift and go to state 42
    RETURN          shift and go to state 43
    WHILE           shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    FOR             shift and go to state 47
    CONST           shift and go to state 52
    EXTERN          shift and go to state 53
    INLINE          shift and go to state 54
    LONG            shift and go to state 55
    SHORT           shift and go to state 56
    SIGNED          shift and go to state 57
    UNSIGNED        shift and go to state 58
    VOLATILE        shift and go to state 59
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    control                        shift and go to state 24
    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    dtype                          shift and go to state 15
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    return                         shift and go to state 23
    for_loop                       shift and go to state 25
    struct_type                    shift and go to state 34
    init_var_ls                    shift and go to state 35
    assign_var_ls                  shift and go to state 36
    declare_var_ls                 shift and go to state 37
    name                           shift and go to state 38
    operand                        shift and go to state 41
    modifier                       shift and go to state 48
    type_cast                      shift and go to state 49
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 210

    (89) struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .

    INCLUDE         reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    DEFINE          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    IFNDEF          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    ENDIF           reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    ID              reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    STRUCT          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    CHAR            reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    DOUBLE          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    FLOAT           reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    INT             reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    VOID            reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    UINT8_T         reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    UINT16_T        reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    LPAREN          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    NEGATE          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    MINUS           reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    SIZEOF          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    RETURN          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    WHILE           reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    IF              reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    ELSE            reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    FOR             reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    CONST           reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    EXTERN          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    INLINE          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    LONG            reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    SHORT           reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    SIGNED          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    UNSIGNED        reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    VOLATILE        reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    FLOAT_L         reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    INT_L           reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    CHAR_L          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    STRING_L        reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    NONDECIMAL_L    reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    BITAND          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    $end            reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)
    RBRACE          reduce using rule 89 (struct_def -> STRUCT ID LBRACE node_list RBRACE SEMI .)


state 211

    (66) for_loop -> FOR LPAREN init_var conditional_expr SEMI ID . INCREMENT RPAREN

    INCREMENT       shift and go to state 215


state 212

    (80) func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . define
    (5) node -> . if
    (6) node -> . func_def
    (7) node -> . func_decl
    (8) node -> . statement
    (9) node -> . control_expr
    (10) node -> . struct_def
    (45) include -> . INCLUDE
    (46) define -> . DEFINE
    (47) if -> . IFNDEF
    (48) if -> . ENDIF
    (80) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (81) func_def -> . ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (84) func_decl -> . dtype ID LPAREN func_arglist RPAREN SEMI
    (91) statement -> . init_var
    (92) statement -> . assign_var
    (93) statement -> . declare_var
    (94) statement -> . expression SEMI
    (95) statement -> . func_call SEMI
    (96) statement -> . return SEMI
    (67) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (68) control_expr -> . control LBRACE node_list RBRACE
    (69) control_expr -> . for_loop LBRACE node_list RBRACE
    (89) struct_def -> . STRUCT ID LBRACE node_list RBRACE SEMI
    (32) dtype -> . CHAR
    (33) dtype -> . DOUBLE
    (34) dtype -> . FLOAT
    (35) dtype -> . INT
    (36) dtype -> . VOID
    (37) dtype -> . UINT8_T
    (38) dtype -> . UINT16_T
    (39) dtype -> . struct_type
    (40) dtype -> . ID
    (41) dtype -> . dtype ASTERISK
    (139) init_var -> . init_var_ls init_var_rs
    (142) assign_var -> . assign_var_ls assign_var_rs
    (125) declare_var -> . declare_var_ls SEMI
    (97) expression -> . LPAREN expression RPAREN
    (98) expression -> . LPAREN name RPAREN
    (99) expression -> . NEGATE expression
    (100) expression -> . MINUS expression
    (101) expression -> . NEGATE name
    (102) expression -> . MINUS name
    (117) expression -> . operand binop operand
    (118) expression -> . name INCREMENT
    (82) func_call -> . ID LPAREN func_arglist RPAREN
    (83) func_call -> . SIZEOF LPAREN func_arglist RPAREN
    (119) return -> . RETURN name
    (120) return -> . RETURN expression
    (49) control -> . WHILE
    (50) control -> . IF
    (51) control -> . ELSE
    (66) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (18) struct_type -> . STRUCT name
    (130) init_var_ls -> . declare_var_ls assign
    (131) init_var_ls -> . declare_var_ls vector_init assign
    (140) assign_var_ls -> . name assign
    (123) declare_var_ls -> . dtype ID
    (124) declare_var_ls -> . modifier dtype ID
    (113) operand -> . name
    (114) operand -> . expression
    (115) operand -> . type_cast name
    (116) operand -> . func_call
    (42) name -> . ID
    (43) name -> . literal
    (44) name -> . access
    (20) modifier -> . CONST
    (21) modifier -> . EXTERN
    (22) modifier -> . INLINE
    (23) modifier -> . LONG
    (24) modifier -> . SHORT
    (25) modifier -> . SIGNED
    (26) modifier -> . UNSIGNED
    (27) modifier -> . VOLATILE
    (19) type_cast -> . LPAREN dtype RPAREN
    (11) literal -> . FLOAT_L
    (12) literal -> . INT_L
    (13) literal -> . CHAR_L
    (14) literal -> . STRING_L
    (15) literal -> . NONDECIMAL_L
    (85) access -> . name LBRACK name RBRACK
    (86) access -> . name LBRACK expression RBRACK
    (87) access -> . name MEMBER name
    (88) access -> . BITAND name

    RBRACE          shift and go to state 216
    INCLUDE         shift and go to state 11
    DEFINE          shift and go to state 12
    IFNDEF          shift and go to state 13
    ENDIF           shift and go to state 14
    ID              shift and go to state 16
    STRUCT          shift and go to state 26
    CHAR            shift and go to state 27
    DOUBLE          shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    VOID            shift and go to state 31
    UINT8_T         shift and go to state 32
    UINT16_T        shift and go to state 33
    LPAREN          shift and go to state 17
    NEGATE          shift and go to state 39
    MINUS           shift and go to state 40
    SIZEOF          shift and go to state 42
    RETURN          shift and go to state 43
    WHILE           shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    FOR             shift and go to state 47
    CONST           shift and go to state 52
    EXTERN          shift and go to state 53
    INLINE          shift and go to state 54
    LONG            shift and go to state 55
    SHORT           shift and go to state 56
    SIGNED          shift and go to state 57
    UNSIGNED        shift and go to state 58
    VOLATILE        shift and go to state 59
    FLOAT_L         shift and go to state 60
    INT_L           shift and go to state 61
    CHAR_L          shift and go to state 62
    STRING_L        shift and go to state 63
    NONDECIMAL_L    shift and go to state 64
    BITAND          shift and go to state 65

    dtype                          shift and go to state 15
    node                           shift and go to state 2
    include                        shift and go to state 3
    define                         shift and go to state 4
    if                             shift and go to state 5
    func_def                       shift and go to state 6
    func_decl                      shift and go to state 7
    statement                      shift and go to state 8
    control_expr                   shift and go to state 9
    struct_def                     shift and go to state 10
    init_var                       shift and go to state 18
    assign_var                     shift and go to state 19
    declare_var                    shift and go to state 20
    expression                     shift and go to state 21
    func_call                      shift and go to state 22
    return                         shift and go to state 23
    control                        shift and go to state 24
    for_loop                       shift and go to state 25
    struct_type                    shift and go to state 34
    init_var_ls                    shift and go to state 35
    assign_var_ls                  shift and go to state 36
    declare_var_ls                 shift and go to state 37
    name                           shift and go to state 38
    operand                        shift and go to state 41
    modifier                       shift and go to state 48
    type_cast                      shift and go to state 49
    literal                        shift and go to state 50
    access                         shift and go to state 51

state 213

    (81) func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    DEFINE          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    IFNDEF          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    ENDIF           reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    ID              reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    STRUCT          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    CHAR            reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    INT             reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    VOID            reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    LPAREN          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    NEGATE          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    MINUS           reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    SIZEOF          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    RETURN          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    WHILE           reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    IF              reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    ELSE            reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    FOR             reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    CONST           reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    INLINE          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    LONG            reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    SHORT           reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    FLOAT_L         reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    INT_L           reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    CHAR_L          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    STRING_L        reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    NONDECIMAL_L    reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    BITAND          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    $end            reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 81 (func_def -> ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)


state 214

    (67) control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    DEFINE          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    IFNDEF          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    ENDIF           reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    ID              reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    STRUCT          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    CHAR            reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    INT             reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    VOID            reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    LPAREN          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    NEGATE          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    MINUS           reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    SIZEOF          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    RETURN          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    WHILE           reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    IF              reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    ELSE            reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    FOR             reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    CONST           reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    INLINE          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    LONG            reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    SHORT           reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    FLOAT_L         reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    INT_L           reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    CHAR_L          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    STRING_L        reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    NONDECIMAL_L    reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    BITAND          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    $end            reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 67 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)


state 215

    (66) for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT . RPAREN

    RPAREN          shift and go to state 217


state 216

    (80) func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    DEFINE          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    IFNDEF          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    ENDIF           reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    ID              reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    STRUCT          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    CHAR            reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    INT             reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    VOID            reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    LPAREN          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    NEGATE          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    MINUS           reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    SIZEOF          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    RETURN          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    WHILE           reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    IF              reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    ELSE            reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    FOR             reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    CONST           reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    INLINE          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    LONG            reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    SHORT           reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    FLOAT_L         reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    INT_L           reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    CHAR_L          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    STRING_L        reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    NONDECIMAL_L    reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    BITAND          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    $end            reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 80 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)


state 217

    (66) for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN .

    LBRACE          reduce using rule 66 (for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 72 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 90 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 135 resolved as shift
WARNING: shift/reduce conflict for MEMBER in state 135 resolved as shift
WARNING: shift/reduce conflict for EQ in state 143 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 143 resolved as shift
WARNING: shift/reduce conflict for LT in state 143 resolved as shift
WARNING: shift/reduce conflict for GT in state 143 resolved as shift
WARNING: shift/reduce conflict for LE in state 143 resolved as shift
WARNING: shift/reduce conflict for GE in state 143 resolved as shift
WARNING: shift/reduce conflict for AND in state 143 resolved as shift
WARNING: shift/reduce conflict for OR in state 143 resolved as shift
WARNING: shift/reduce conflict for EQ in state 144 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 144 resolved as shift
WARNING: shift/reduce conflict for LT in state 144 resolved as shift
WARNING: shift/reduce conflict for GT in state 144 resolved as shift
WARNING: shift/reduce conflict for LE in state 144 resolved as shift
WARNING: shift/reduce conflict for GE in state 144 resolved as shift
WARNING: shift/reduce conflict for AND in state 144 resolved as shift
WARNING: shift/reduce conflict for OR in state 144 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 160 resolved as shift
WARNING: shift/reduce conflict for MEMBER in state 160 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 161 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 161 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 161 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 161 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 161 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 161 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 161 resolved as shift
WARNING: shift/reduce conflict for BITAND in state 161 resolved as shift
WARNING: shift/reduce conflict for BITOR in state 161 resolved as shift
WARNING: shift/reduce conflict for EQ in state 161 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 161 resolved as shift
WARNING: shift/reduce conflict for LT in state 161 resolved as shift
WARNING: shift/reduce conflict for GT in state 161 resolved as shift
WARNING: shift/reduce conflict for LE in state 161 resolved as shift
WARNING: shift/reduce conflict for GE in state 161 resolved as shift
WARNING: shift/reduce conflict for AND in state 161 resolved as shift
WARNING: shift/reduce conflict for OR in state 161 resolved as shift
WARNING: shift/reduce conflict for ID in state 174 resolved as shift
WARNING: shift/reduce conflict for FLOAT_L in state 174 resolved as shift
WARNING: shift/reduce conflict for INT_L in state 174 resolved as shift
WARNING: shift/reduce conflict for CHAR_L in state 174 resolved as shift
WARNING: shift/reduce conflict for STRING_L in state 174 resolved as shift
WARNING: shift/reduce conflict for NONDECIMAL_L in state 174 resolved as shift
WARNING: shift/reduce conflict for BITAND in state 174 resolved as shift
WARNING: reduce/reduce conflict in state 16 resolved using rule (dtype -> ID)
WARNING: rejected rule (name -> ID) in state 16
WARNING: reduce/reduce conflict in state 72 resolved using rule (dtype -> ID)
WARNING: rejected rule (name -> ID) in state 72
WARNING: reduce/reduce conflict in state 104 resolved using rule (expression -> NEGATE expression)
WARNING: rejected rule (operand -> expression) in state 104
WARNING: reduce/reduce conflict in state 105 resolved using rule (expression -> NEGATE name)
WARNING: rejected rule (operand -> name) in state 105
WARNING: reduce/reduce conflict in state 106 resolved using rule (expression -> MINUS expression)
WARNING: rejected rule (operand -> expression) in state 106
WARNING: reduce/reduce conflict in state 107 resolved using rule (expression -> MINUS name)
WARNING: rejected rule (operand -> name) in state 107
WARNING: reduce/reduce conflict in state 154 resolved using rule (operand -> name)
WARNING: rejected rule (operand -> type_cast name) in state 154
WARNING: reduce/reduce conflict in state 184 resolved using rule (expression -> LPAREN name RPAREN)
WARNING: rejected rule (init_var_rs -> LPAREN name RPAREN) in state 184
WARNING: reduce/reduce conflict in state 195 resolved using rule (func_arg -> type_cast name)
WARNING: rejected rule (operand -> name) in state 195
WARNING: reduce/reduce conflict in state 196 resolved using rule (func_arg -> type_cast expression)
WARNING: rejected rule (operand -> expression) in state 196
WARNING: reduce/reduce conflict in state 197 resolved using rule (func_arg -> type_cast func_call)
WARNING: rejected rule (operand -> func_call) in state 197
