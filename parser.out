Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AUTO
    BITAND
    BITOR
    BREAK
    CASE
    COMMENT
    CONTINUE
    DEFAULT
    DEFINE
    DO
    ENDIF
    ENUM
    GOTO
    IFNDEF
    LBRACK
    LCOMMENT
    MEMBER
    NUMBER
    RBRACK
    REGISTER
    RESTRICT
    RETURN
    SIZEOF
    STATIC
    STRUCT
    SWITCH
    TYPEDEF
    UNION
    _ALIGNAS
    _ALIGNOF
    _ATOMIC
    _BOOL
    _COMPLEX
    _GENERIC
    _IMAGERY
    _NORETURN
    _STATIC_ASSERT
    _THREAD_LOCAL

Grammar

Rule 0     S' -> node_list
Rule 1     node_list -> <empty>
Rule 2     node_list -> node_list node
Rule 3     node -> include
Rule 4     node -> func_def
Rule 5     node -> func_call
Rule 6     node -> statement
Rule 7     node -> control_expr
Rule 8     literal -> FLOAT
Rule 9     literal -> INT
Rule 10    literal -> CHAR
Rule 11    literal -> STRING
Rule 12    literal -> NONDECIMAL
Rule 13    assign -> SIMPLE_ASSIGN
Rule 14    assign -> COMPLEX_ASSIGN
Rule 15    dtype -> CHAR
Rule 16    dtype -> DOUBLE
Rule 17    dtype -> FLOAT
Rule 18    dtype -> INT
Rule 19    dtype -> VOID
Rule 20    dtype -> UINT8_T
Rule 21    dtype -> UINT16_T
Rule 22    dtype -> dtype ASTERISK
Rule 23    modifier -> CONST
Rule 24    modifier -> EXTERN
Rule 25    modifier -> INLINE
Rule 26    modifier -> LONG
Rule 27    modifier -> SHORT
Rule 28    modifier -> SIGNED
Rule 29    modifier -> UNSIGNED
Rule 30    modifier -> VOLATILE
Rule 31    include -> INCLUDE
Rule 32    control -> WHILE
Rule 33    control -> IF
Rule 34    control -> ELSE
Rule 35    conditional -> EQ
Rule 36    conditional -> NEQ
Rule 37    conditional -> LT
Rule 38    conditional -> GT
Rule 39    conditional -> LE
Rule 40    conditional -> GE
Rule 41    conditional -> AND
Rule 42    conditional -> OR
Rule 43    conditional_expr -> ID conditional expression
Rule 44    conditional_expr -> expression conditional ID
Rule 45    conditional_expr -> expression conditional expression
Rule 46    conditional_expr -> ID conditional ID
Rule 47    for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
Rule 48    control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
Rule 49    control_expr -> control LBRACE node_list RBRACE
Rule 50    control_expr -> for_loop LBRACE node_list RBRACE
Rule 51    func_arg -> ID
Rule 52    func_arg -> expression
Rule 53    func_arg -> dtype ID
Rule 54    func_arg -> dtype
Rule 55    func_arglist -> <empty>
Rule 56    func_arglist -> func_arglist func_arg
Rule 57    func_arglist -> func_arglist func_arg COMMA
Rule 58    func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
Rule 59    func_call -> ID LPAREN func_arglist RPAREN SEMI
Rule 60    statement -> init_var
Rule 61    statement -> assign_var
Rule 62    statement -> declare_var
Rule 63    statement -> increment
Rule 64    expression -> literal
Rule 65    expression -> LPAREN expression RPAREN
Rule 66    expression -> NEGATE expression
Rule 67    expression -> MINUS expression
Rule 68    binop -> PLUS
Rule 69    binop -> MINUS
Rule 70    binop -> ASTERISK
Rule 71    binop -> DIVIDE
Rule 72    binop -> LSHIFT
Rule 73    binop -> RSHIFT
Rule 74    binop -> PERCENT
Rule 75    expression -> expression binop ID
Rule 76    expression -> ID binop expression
Rule 77    increment -> ID INCREMENT SEMI
Rule 78    declare_var -> dtype ID SEMI
Rule 79    declare_var -> modifier dtype ID SEMI
Rule 80    init_var_ls -> modifier dtype ID assign
Rule 81    init_var_ls -> dtype ID assign
Rule 82    init_var_rs -> literal SEMI
Rule 83    init_var_rs -> ID SEMI
Rule 84    init_var_rs -> LPAREN dtype RPAREN literal SEMI
Rule 85    init_var_rs -> LPAREN dtype RPAREN ID SEMI
Rule 86    init_var_rs -> func_call
Rule 87    init_var -> init_var_ls init_var_rs
Rule 88    assign_var -> ID assign expression SEMI

Terminals, with rules where they appear

AND                  : 41
ASTERISK             : 22 70
AUTO                 : 
BITAND               : 
BITOR                : 
BREAK                : 
CASE                 : 
CHAR                 : 10 15
COMMA                : 57
COMMENT              : 
COMPLEX_ASSIGN       : 14
CONST                : 23
CONTINUE             : 
DEFAULT              : 
DEFINE               : 
DIVIDE               : 71
DO                   : 
DOUBLE               : 16
ELSE                 : 34
ENDIF                : 
ENUM                 : 
EQ                   : 35
EXTERN               : 24
FLOAT                : 8 17
FOR                  : 47
GE                   : 40
GOTO                 : 
GT                   : 38
ID                   : 43 44 46 46 47 51 53 58 59 75 76 77 78 79 80 81 83 85 88
IF                   : 33
IFNDEF               : 
INCLUDE              : 31
INCREMENT            : 47 77
INLINE               : 25
INT                  : 9 18
LBRACE               : 48 49 50 58
LBRACK               : 
LCOMMENT             : 
LE                   : 39
LONG                 : 26
LPAREN               : 47 48 58 59 65 84 85
LSHIFT               : 72
LT                   : 37
MEMBER               : 
MINUS                : 67 69
NEGATE               : 66
NEQ                  : 36
NONDECIMAL           : 12
NUMBER               : 
OR                   : 42
PERCENT              : 74
PLUS                 : 68
RBRACE               : 48 49 50 58
RBRACK               : 
REGISTER             : 
RESTRICT             : 
RETURN               : 
RPAREN               : 47 48 58 59 65 84 85
RSHIFT               : 73
SEMI                 : 47 59 77 78 79 82 83 84 85 88
SHORT                : 27
SIGNED               : 28
SIMPLE_ASSIGN        : 13
SIZEOF               : 
STATIC               : 
STRING               : 11
STRUCT               : 
SWITCH               : 
TYPEDEF              : 
UINT16_T             : 21
UINT8_T              : 20
UNION                : 
UNSIGNED             : 29
VOID                 : 19
VOLATILE             : 30
WHILE                : 32
_ALIGNAS             : 
_ALIGNOF             : 
_ATOMIC              : 
_BOOL                : 
_COMPLEX             : 
_GENERIC             : 
_IMAGERY             : 
_NORETURN            : 
_STATIC_ASSERT       : 
_THREAD_LOCAL        : 
error                : 

Nonterminals, with rules where they appear

assign               : 80 81 88
assign_var           : 61
binop                : 75 76
conditional          : 43 44 45 46
conditional_expr     : 47 48
control              : 48 49
control_expr         : 7
declare_var          : 62
dtype                : 22 53 54 58 78 79 80 81 84 85
expression           : 43 44 45 45 52 65 66 67 75 76 88
for_loop             : 50
func_arg             : 56 57
func_arglist         : 56 57 58 59
func_call            : 5 86
func_def             : 4
include              : 3
increment            : 63
init_var             : 47 60
init_var_ls          : 87
init_var_rs          : 87
literal              : 64 82 84
modifier             : 79 80
node                 : 2
node_list            : 2 48 49 50 58 0
statement            : 6

Parsing method: LALR

state 0

    (0) S' -> . node_list
    (1) node_list -> .
    (2) node_list -> . node_list node

    INCLUDE         reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)
    $end            reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 1

state 1

    (0) S' -> node_list .
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . func_def
    (5) node -> . func_call
    (6) node -> . statement
    (7) node -> . control_expr
    (31) include -> . INCLUDE
    (58) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (59) func_call -> . ID LPAREN func_arglist RPAREN SEMI
    (60) statement -> . init_var
    (61) statement -> . assign_var
    (62) statement -> . declare_var
    (63) statement -> . increment
    (48) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (49) control_expr -> . control LBRACE node_list RBRACE
    (50) control_expr -> . for_loop LBRACE node_list RBRACE
    (15) dtype -> . CHAR
    (16) dtype -> . DOUBLE
    (17) dtype -> . FLOAT
    (18) dtype -> . INT
    (19) dtype -> . VOID
    (20) dtype -> . UINT8_T
    (21) dtype -> . UINT16_T
    (22) dtype -> . dtype ASTERISK
    (87) init_var -> . init_var_ls init_var_rs
    (88) assign_var -> . ID assign expression SEMI
    (78) declare_var -> . dtype ID SEMI
    (79) declare_var -> . modifier dtype ID SEMI
    (77) increment -> . ID INCREMENT SEMI
    (32) control -> . WHILE
    (33) control -> . IF
    (34) control -> . ELSE
    (47) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (80) init_var_ls -> . modifier dtype ID assign
    (81) init_var_ls -> . dtype ID assign
    (23) modifier -> . CONST
    (24) modifier -> . EXTERN
    (25) modifier -> . INLINE
    (26) modifier -> . LONG
    (27) modifier -> . SHORT
    (28) modifier -> . SIGNED
    (29) modifier -> . UNSIGNED
    (30) modifier -> . VOLATILE

    INCLUDE         shift and go to state 8
    ID              shift and go to state 10
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    VOID            shift and go to state 21
    UINT8_T         shift and go to state 22
    UINT16_T        shift and go to state 23
    WHILE           shift and go to state 26
    IF              shift and go to state 27
    ELSE            shift and go to state 28
    FOR             shift and go to state 29
    CONST           shift and go to state 30
    EXTERN          shift and go to state 31
    INLINE          shift and go to state 32
    LONG            shift and go to state 33
    SHORT           shift and go to state 34
    SIGNED          shift and go to state 35
    UNSIGNED        shift and go to state 36
    VOLATILE        shift and go to state 37

    node                           shift and go to state 2
    include                        shift and go to state 3
    func_def                       shift and go to state 4
    func_call                      shift and go to state 5
    statement                      shift and go to state 6
    control_expr                   shift and go to state 7
    dtype                          shift and go to state 9
    init_var                       shift and go to state 11
    assign_var                     shift and go to state 12
    declare_var                    shift and go to state 13
    increment                      shift and go to state 14
    control                        shift and go to state 15
    for_loop                       shift and go to state 16
    init_var_ls                    shift and go to state 24
    modifier                       shift and go to state 25

state 2

    (2) node_list -> node_list node .

    INCLUDE         reduce using rule 2 (node_list -> node_list node .)
    ID              reduce using rule 2 (node_list -> node_list node .)
    CHAR            reduce using rule 2 (node_list -> node_list node .)
    DOUBLE          reduce using rule 2 (node_list -> node_list node .)
    FLOAT           reduce using rule 2 (node_list -> node_list node .)
    INT             reduce using rule 2 (node_list -> node_list node .)
    VOID            reduce using rule 2 (node_list -> node_list node .)
    UINT8_T         reduce using rule 2 (node_list -> node_list node .)
    UINT16_T        reduce using rule 2 (node_list -> node_list node .)
    WHILE           reduce using rule 2 (node_list -> node_list node .)
    IF              reduce using rule 2 (node_list -> node_list node .)
    ELSE            reduce using rule 2 (node_list -> node_list node .)
    FOR             reduce using rule 2 (node_list -> node_list node .)
    CONST           reduce using rule 2 (node_list -> node_list node .)
    EXTERN          reduce using rule 2 (node_list -> node_list node .)
    INLINE          reduce using rule 2 (node_list -> node_list node .)
    LONG            reduce using rule 2 (node_list -> node_list node .)
    SHORT           reduce using rule 2 (node_list -> node_list node .)
    SIGNED          reduce using rule 2 (node_list -> node_list node .)
    UNSIGNED        reduce using rule 2 (node_list -> node_list node .)
    VOLATILE        reduce using rule 2 (node_list -> node_list node .)
    $end            reduce using rule 2 (node_list -> node_list node .)
    RBRACE          reduce using rule 2 (node_list -> node_list node .)


state 3

    (3) node -> include .

    INCLUDE         reduce using rule 3 (node -> include .)
    ID              reduce using rule 3 (node -> include .)
    CHAR            reduce using rule 3 (node -> include .)
    DOUBLE          reduce using rule 3 (node -> include .)
    FLOAT           reduce using rule 3 (node -> include .)
    INT             reduce using rule 3 (node -> include .)
    VOID            reduce using rule 3 (node -> include .)
    UINT8_T         reduce using rule 3 (node -> include .)
    UINT16_T        reduce using rule 3 (node -> include .)
    WHILE           reduce using rule 3 (node -> include .)
    IF              reduce using rule 3 (node -> include .)
    ELSE            reduce using rule 3 (node -> include .)
    FOR             reduce using rule 3 (node -> include .)
    CONST           reduce using rule 3 (node -> include .)
    EXTERN          reduce using rule 3 (node -> include .)
    INLINE          reduce using rule 3 (node -> include .)
    LONG            reduce using rule 3 (node -> include .)
    SHORT           reduce using rule 3 (node -> include .)
    SIGNED          reduce using rule 3 (node -> include .)
    UNSIGNED        reduce using rule 3 (node -> include .)
    VOLATILE        reduce using rule 3 (node -> include .)
    $end            reduce using rule 3 (node -> include .)
    RBRACE          reduce using rule 3 (node -> include .)


state 4

    (4) node -> func_def .

    INCLUDE         reduce using rule 4 (node -> func_def .)
    ID              reduce using rule 4 (node -> func_def .)
    CHAR            reduce using rule 4 (node -> func_def .)
    DOUBLE          reduce using rule 4 (node -> func_def .)
    FLOAT           reduce using rule 4 (node -> func_def .)
    INT             reduce using rule 4 (node -> func_def .)
    VOID            reduce using rule 4 (node -> func_def .)
    UINT8_T         reduce using rule 4 (node -> func_def .)
    UINT16_T        reduce using rule 4 (node -> func_def .)
    WHILE           reduce using rule 4 (node -> func_def .)
    IF              reduce using rule 4 (node -> func_def .)
    ELSE            reduce using rule 4 (node -> func_def .)
    FOR             reduce using rule 4 (node -> func_def .)
    CONST           reduce using rule 4 (node -> func_def .)
    EXTERN          reduce using rule 4 (node -> func_def .)
    INLINE          reduce using rule 4 (node -> func_def .)
    LONG            reduce using rule 4 (node -> func_def .)
    SHORT           reduce using rule 4 (node -> func_def .)
    SIGNED          reduce using rule 4 (node -> func_def .)
    UNSIGNED        reduce using rule 4 (node -> func_def .)
    VOLATILE        reduce using rule 4 (node -> func_def .)
    $end            reduce using rule 4 (node -> func_def .)
    RBRACE          reduce using rule 4 (node -> func_def .)


state 5

    (5) node -> func_call .

    INCLUDE         reduce using rule 5 (node -> func_call .)
    ID              reduce using rule 5 (node -> func_call .)
    CHAR            reduce using rule 5 (node -> func_call .)
    DOUBLE          reduce using rule 5 (node -> func_call .)
    FLOAT           reduce using rule 5 (node -> func_call .)
    INT             reduce using rule 5 (node -> func_call .)
    VOID            reduce using rule 5 (node -> func_call .)
    UINT8_T         reduce using rule 5 (node -> func_call .)
    UINT16_T        reduce using rule 5 (node -> func_call .)
    WHILE           reduce using rule 5 (node -> func_call .)
    IF              reduce using rule 5 (node -> func_call .)
    ELSE            reduce using rule 5 (node -> func_call .)
    FOR             reduce using rule 5 (node -> func_call .)
    CONST           reduce using rule 5 (node -> func_call .)
    EXTERN          reduce using rule 5 (node -> func_call .)
    INLINE          reduce using rule 5 (node -> func_call .)
    LONG            reduce using rule 5 (node -> func_call .)
    SHORT           reduce using rule 5 (node -> func_call .)
    SIGNED          reduce using rule 5 (node -> func_call .)
    UNSIGNED        reduce using rule 5 (node -> func_call .)
    VOLATILE        reduce using rule 5 (node -> func_call .)
    $end            reduce using rule 5 (node -> func_call .)
    RBRACE          reduce using rule 5 (node -> func_call .)


state 6

    (6) node -> statement .

    INCLUDE         reduce using rule 6 (node -> statement .)
    ID              reduce using rule 6 (node -> statement .)
    CHAR            reduce using rule 6 (node -> statement .)
    DOUBLE          reduce using rule 6 (node -> statement .)
    FLOAT           reduce using rule 6 (node -> statement .)
    INT             reduce using rule 6 (node -> statement .)
    VOID            reduce using rule 6 (node -> statement .)
    UINT8_T         reduce using rule 6 (node -> statement .)
    UINT16_T        reduce using rule 6 (node -> statement .)
    WHILE           reduce using rule 6 (node -> statement .)
    IF              reduce using rule 6 (node -> statement .)
    ELSE            reduce using rule 6 (node -> statement .)
    FOR             reduce using rule 6 (node -> statement .)
    CONST           reduce using rule 6 (node -> statement .)
    EXTERN          reduce using rule 6 (node -> statement .)
    INLINE          reduce using rule 6 (node -> statement .)
    LONG            reduce using rule 6 (node -> statement .)
    SHORT           reduce using rule 6 (node -> statement .)
    SIGNED          reduce using rule 6 (node -> statement .)
    UNSIGNED        reduce using rule 6 (node -> statement .)
    VOLATILE        reduce using rule 6 (node -> statement .)
    $end            reduce using rule 6 (node -> statement .)
    RBRACE          reduce using rule 6 (node -> statement .)


state 7

    (7) node -> control_expr .

    INCLUDE         reduce using rule 7 (node -> control_expr .)
    ID              reduce using rule 7 (node -> control_expr .)
    CHAR            reduce using rule 7 (node -> control_expr .)
    DOUBLE          reduce using rule 7 (node -> control_expr .)
    FLOAT           reduce using rule 7 (node -> control_expr .)
    INT             reduce using rule 7 (node -> control_expr .)
    VOID            reduce using rule 7 (node -> control_expr .)
    UINT8_T         reduce using rule 7 (node -> control_expr .)
    UINT16_T        reduce using rule 7 (node -> control_expr .)
    WHILE           reduce using rule 7 (node -> control_expr .)
    IF              reduce using rule 7 (node -> control_expr .)
    ELSE            reduce using rule 7 (node -> control_expr .)
    FOR             reduce using rule 7 (node -> control_expr .)
    CONST           reduce using rule 7 (node -> control_expr .)
    EXTERN          reduce using rule 7 (node -> control_expr .)
    INLINE          reduce using rule 7 (node -> control_expr .)
    LONG            reduce using rule 7 (node -> control_expr .)
    SHORT           reduce using rule 7 (node -> control_expr .)
    SIGNED          reduce using rule 7 (node -> control_expr .)
    UNSIGNED        reduce using rule 7 (node -> control_expr .)
    VOLATILE        reduce using rule 7 (node -> control_expr .)
    $end            reduce using rule 7 (node -> control_expr .)
    RBRACE          reduce using rule 7 (node -> control_expr .)


state 8

    (31) include -> INCLUDE .

    INCLUDE         reduce using rule 31 (include -> INCLUDE .)
    ID              reduce using rule 31 (include -> INCLUDE .)
    CHAR            reduce using rule 31 (include -> INCLUDE .)
    DOUBLE          reduce using rule 31 (include -> INCLUDE .)
    FLOAT           reduce using rule 31 (include -> INCLUDE .)
    INT             reduce using rule 31 (include -> INCLUDE .)
    VOID            reduce using rule 31 (include -> INCLUDE .)
    UINT8_T         reduce using rule 31 (include -> INCLUDE .)
    UINT16_T        reduce using rule 31 (include -> INCLUDE .)
    WHILE           reduce using rule 31 (include -> INCLUDE .)
    IF              reduce using rule 31 (include -> INCLUDE .)
    ELSE            reduce using rule 31 (include -> INCLUDE .)
    FOR             reduce using rule 31 (include -> INCLUDE .)
    CONST           reduce using rule 31 (include -> INCLUDE .)
    EXTERN          reduce using rule 31 (include -> INCLUDE .)
    INLINE          reduce using rule 31 (include -> INCLUDE .)
    LONG            reduce using rule 31 (include -> INCLUDE .)
    SHORT           reduce using rule 31 (include -> INCLUDE .)
    SIGNED          reduce using rule 31 (include -> INCLUDE .)
    UNSIGNED        reduce using rule 31 (include -> INCLUDE .)
    VOLATILE        reduce using rule 31 (include -> INCLUDE .)
    $end            reduce using rule 31 (include -> INCLUDE .)
    RBRACE          reduce using rule 31 (include -> INCLUDE .)


state 9

    (58) func_def -> dtype . ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (22) dtype -> dtype . ASTERISK
    (78) declare_var -> dtype . ID SEMI
    (81) init_var_ls -> dtype . ID assign

    ID              shift and go to state 38
    ASTERISK        shift and go to state 39


state 10

    (59) func_call -> ID . LPAREN func_arglist RPAREN SEMI
    (88) assign_var -> ID . assign expression SEMI
    (77) increment -> ID . INCREMENT SEMI
    (13) assign -> . SIMPLE_ASSIGN
    (14) assign -> . COMPLEX_ASSIGN

    LPAREN          shift and go to state 40
    INCREMENT       shift and go to state 42
    SIMPLE_ASSIGN   shift and go to state 43
    COMPLEX_ASSIGN  shift and go to state 44

    assign                         shift and go to state 41

state 11

    (60) statement -> init_var .

    INCLUDE         reduce using rule 60 (statement -> init_var .)
    ID              reduce using rule 60 (statement -> init_var .)
    CHAR            reduce using rule 60 (statement -> init_var .)
    DOUBLE          reduce using rule 60 (statement -> init_var .)
    FLOAT           reduce using rule 60 (statement -> init_var .)
    INT             reduce using rule 60 (statement -> init_var .)
    VOID            reduce using rule 60 (statement -> init_var .)
    UINT8_T         reduce using rule 60 (statement -> init_var .)
    UINT16_T        reduce using rule 60 (statement -> init_var .)
    WHILE           reduce using rule 60 (statement -> init_var .)
    IF              reduce using rule 60 (statement -> init_var .)
    ELSE            reduce using rule 60 (statement -> init_var .)
    FOR             reduce using rule 60 (statement -> init_var .)
    CONST           reduce using rule 60 (statement -> init_var .)
    EXTERN          reduce using rule 60 (statement -> init_var .)
    INLINE          reduce using rule 60 (statement -> init_var .)
    LONG            reduce using rule 60 (statement -> init_var .)
    SHORT           reduce using rule 60 (statement -> init_var .)
    SIGNED          reduce using rule 60 (statement -> init_var .)
    UNSIGNED        reduce using rule 60 (statement -> init_var .)
    VOLATILE        reduce using rule 60 (statement -> init_var .)
    $end            reduce using rule 60 (statement -> init_var .)
    RBRACE          reduce using rule 60 (statement -> init_var .)


state 12

    (61) statement -> assign_var .

    INCLUDE         reduce using rule 61 (statement -> assign_var .)
    ID              reduce using rule 61 (statement -> assign_var .)
    CHAR            reduce using rule 61 (statement -> assign_var .)
    DOUBLE          reduce using rule 61 (statement -> assign_var .)
    FLOAT           reduce using rule 61 (statement -> assign_var .)
    INT             reduce using rule 61 (statement -> assign_var .)
    VOID            reduce using rule 61 (statement -> assign_var .)
    UINT8_T         reduce using rule 61 (statement -> assign_var .)
    UINT16_T        reduce using rule 61 (statement -> assign_var .)
    WHILE           reduce using rule 61 (statement -> assign_var .)
    IF              reduce using rule 61 (statement -> assign_var .)
    ELSE            reduce using rule 61 (statement -> assign_var .)
    FOR             reduce using rule 61 (statement -> assign_var .)
    CONST           reduce using rule 61 (statement -> assign_var .)
    EXTERN          reduce using rule 61 (statement -> assign_var .)
    INLINE          reduce using rule 61 (statement -> assign_var .)
    LONG            reduce using rule 61 (statement -> assign_var .)
    SHORT           reduce using rule 61 (statement -> assign_var .)
    SIGNED          reduce using rule 61 (statement -> assign_var .)
    UNSIGNED        reduce using rule 61 (statement -> assign_var .)
    VOLATILE        reduce using rule 61 (statement -> assign_var .)
    $end            reduce using rule 61 (statement -> assign_var .)
    RBRACE          reduce using rule 61 (statement -> assign_var .)


state 13

    (62) statement -> declare_var .

    INCLUDE         reduce using rule 62 (statement -> declare_var .)
    ID              reduce using rule 62 (statement -> declare_var .)
    CHAR            reduce using rule 62 (statement -> declare_var .)
    DOUBLE          reduce using rule 62 (statement -> declare_var .)
    FLOAT           reduce using rule 62 (statement -> declare_var .)
    INT             reduce using rule 62 (statement -> declare_var .)
    VOID            reduce using rule 62 (statement -> declare_var .)
    UINT8_T         reduce using rule 62 (statement -> declare_var .)
    UINT16_T        reduce using rule 62 (statement -> declare_var .)
    WHILE           reduce using rule 62 (statement -> declare_var .)
    IF              reduce using rule 62 (statement -> declare_var .)
    ELSE            reduce using rule 62 (statement -> declare_var .)
    FOR             reduce using rule 62 (statement -> declare_var .)
    CONST           reduce using rule 62 (statement -> declare_var .)
    EXTERN          reduce using rule 62 (statement -> declare_var .)
    INLINE          reduce using rule 62 (statement -> declare_var .)
    LONG            reduce using rule 62 (statement -> declare_var .)
    SHORT           reduce using rule 62 (statement -> declare_var .)
    SIGNED          reduce using rule 62 (statement -> declare_var .)
    UNSIGNED        reduce using rule 62 (statement -> declare_var .)
    VOLATILE        reduce using rule 62 (statement -> declare_var .)
    $end            reduce using rule 62 (statement -> declare_var .)
    RBRACE          reduce using rule 62 (statement -> declare_var .)


state 14

    (63) statement -> increment .

    INCLUDE         reduce using rule 63 (statement -> increment .)
    ID              reduce using rule 63 (statement -> increment .)
    CHAR            reduce using rule 63 (statement -> increment .)
    DOUBLE          reduce using rule 63 (statement -> increment .)
    FLOAT           reduce using rule 63 (statement -> increment .)
    INT             reduce using rule 63 (statement -> increment .)
    VOID            reduce using rule 63 (statement -> increment .)
    UINT8_T         reduce using rule 63 (statement -> increment .)
    UINT16_T        reduce using rule 63 (statement -> increment .)
    WHILE           reduce using rule 63 (statement -> increment .)
    IF              reduce using rule 63 (statement -> increment .)
    ELSE            reduce using rule 63 (statement -> increment .)
    FOR             reduce using rule 63 (statement -> increment .)
    CONST           reduce using rule 63 (statement -> increment .)
    EXTERN          reduce using rule 63 (statement -> increment .)
    INLINE          reduce using rule 63 (statement -> increment .)
    LONG            reduce using rule 63 (statement -> increment .)
    SHORT           reduce using rule 63 (statement -> increment .)
    SIGNED          reduce using rule 63 (statement -> increment .)
    UNSIGNED        reduce using rule 63 (statement -> increment .)
    VOLATILE        reduce using rule 63 (statement -> increment .)
    $end            reduce using rule 63 (statement -> increment .)
    RBRACE          reduce using rule 63 (statement -> increment .)


state 15

    (48) control_expr -> control . LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (49) control_expr -> control . LBRACE node_list RBRACE

    LPAREN          shift and go to state 45
    LBRACE          shift and go to state 46


state 16

    (50) control_expr -> for_loop . LBRACE node_list RBRACE

    LBRACE          shift and go to state 47


state 17

    (15) dtype -> CHAR .

    ID              reduce using rule 15 (dtype -> CHAR .)
    ASTERISK        reduce using rule 15 (dtype -> CHAR .)
    RPAREN          reduce using rule 15 (dtype -> CHAR .)


state 18

    (16) dtype -> DOUBLE .

    ID              reduce using rule 16 (dtype -> DOUBLE .)
    ASTERISK        reduce using rule 16 (dtype -> DOUBLE .)
    RPAREN          reduce using rule 16 (dtype -> DOUBLE .)
    COMMA           reduce using rule 16 (dtype -> DOUBLE .)
    LPAREN          reduce using rule 16 (dtype -> DOUBLE .)
    NEGATE          reduce using rule 16 (dtype -> DOUBLE .)
    MINUS           reduce using rule 16 (dtype -> DOUBLE .)
    CHAR            reduce using rule 16 (dtype -> DOUBLE .)
    DOUBLE          reduce using rule 16 (dtype -> DOUBLE .)
    FLOAT           reduce using rule 16 (dtype -> DOUBLE .)
    INT             reduce using rule 16 (dtype -> DOUBLE .)
    VOID            reduce using rule 16 (dtype -> DOUBLE .)
    UINT8_T         reduce using rule 16 (dtype -> DOUBLE .)
    UINT16_T        reduce using rule 16 (dtype -> DOUBLE .)
    STRING          reduce using rule 16 (dtype -> DOUBLE .)
    NONDECIMAL      reduce using rule 16 (dtype -> DOUBLE .)


state 19

    (17) dtype -> FLOAT .

    ID              reduce using rule 17 (dtype -> FLOAT .)
    ASTERISK        reduce using rule 17 (dtype -> FLOAT .)
    RPAREN          reduce using rule 17 (dtype -> FLOAT .)


state 20

    (18) dtype -> INT .

    ID              reduce using rule 18 (dtype -> INT .)
    ASTERISK        reduce using rule 18 (dtype -> INT .)
    RPAREN          reduce using rule 18 (dtype -> INT .)


state 21

    (19) dtype -> VOID .

    ID              reduce using rule 19 (dtype -> VOID .)
    ASTERISK        reduce using rule 19 (dtype -> VOID .)
    RPAREN          reduce using rule 19 (dtype -> VOID .)
    COMMA           reduce using rule 19 (dtype -> VOID .)
    LPAREN          reduce using rule 19 (dtype -> VOID .)
    NEGATE          reduce using rule 19 (dtype -> VOID .)
    MINUS           reduce using rule 19 (dtype -> VOID .)
    CHAR            reduce using rule 19 (dtype -> VOID .)
    DOUBLE          reduce using rule 19 (dtype -> VOID .)
    FLOAT           reduce using rule 19 (dtype -> VOID .)
    INT             reduce using rule 19 (dtype -> VOID .)
    VOID            reduce using rule 19 (dtype -> VOID .)
    UINT8_T         reduce using rule 19 (dtype -> VOID .)
    UINT16_T        reduce using rule 19 (dtype -> VOID .)
    STRING          reduce using rule 19 (dtype -> VOID .)
    NONDECIMAL      reduce using rule 19 (dtype -> VOID .)


state 22

    (20) dtype -> UINT8_T .

    ID              reduce using rule 20 (dtype -> UINT8_T .)
    ASTERISK        reduce using rule 20 (dtype -> UINT8_T .)
    RPAREN          reduce using rule 20 (dtype -> UINT8_T .)
    COMMA           reduce using rule 20 (dtype -> UINT8_T .)
    LPAREN          reduce using rule 20 (dtype -> UINT8_T .)
    NEGATE          reduce using rule 20 (dtype -> UINT8_T .)
    MINUS           reduce using rule 20 (dtype -> UINT8_T .)
    CHAR            reduce using rule 20 (dtype -> UINT8_T .)
    DOUBLE          reduce using rule 20 (dtype -> UINT8_T .)
    FLOAT           reduce using rule 20 (dtype -> UINT8_T .)
    INT             reduce using rule 20 (dtype -> UINT8_T .)
    VOID            reduce using rule 20 (dtype -> UINT8_T .)
    UINT8_T         reduce using rule 20 (dtype -> UINT8_T .)
    UINT16_T        reduce using rule 20 (dtype -> UINT8_T .)
    STRING          reduce using rule 20 (dtype -> UINT8_T .)
    NONDECIMAL      reduce using rule 20 (dtype -> UINT8_T .)


state 23

    (21) dtype -> UINT16_T .

    ID              reduce using rule 21 (dtype -> UINT16_T .)
    ASTERISK        reduce using rule 21 (dtype -> UINT16_T .)
    RPAREN          reduce using rule 21 (dtype -> UINT16_T .)
    COMMA           reduce using rule 21 (dtype -> UINT16_T .)
    LPAREN          reduce using rule 21 (dtype -> UINT16_T .)
    NEGATE          reduce using rule 21 (dtype -> UINT16_T .)
    MINUS           reduce using rule 21 (dtype -> UINT16_T .)
    CHAR            reduce using rule 21 (dtype -> UINT16_T .)
    DOUBLE          reduce using rule 21 (dtype -> UINT16_T .)
    FLOAT           reduce using rule 21 (dtype -> UINT16_T .)
    INT             reduce using rule 21 (dtype -> UINT16_T .)
    VOID            reduce using rule 21 (dtype -> UINT16_T .)
    UINT8_T         reduce using rule 21 (dtype -> UINT16_T .)
    UINT16_T        reduce using rule 21 (dtype -> UINT16_T .)
    STRING          reduce using rule 21 (dtype -> UINT16_T .)
    NONDECIMAL      reduce using rule 21 (dtype -> UINT16_T .)


state 24

    (87) init_var -> init_var_ls . init_var_rs
    (82) init_var_rs -> . literal SEMI
    (83) init_var_rs -> . ID SEMI
    (84) init_var_rs -> . LPAREN dtype RPAREN literal SEMI
    (85) init_var_rs -> . LPAREN dtype RPAREN ID SEMI
    (86) init_var_rs -> . func_call
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL
    (59) func_call -> . ID LPAREN func_arglist RPAREN SEMI

    ID              shift and go to state 50
    LPAREN          shift and go to state 51
    FLOAT           shift and go to state 53
    INT             shift and go to state 54
    CHAR            shift and go to state 55
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    init_var_rs                    shift and go to state 48
    literal                        shift and go to state 49
    func_call                      shift and go to state 52

state 25

    (79) declare_var -> modifier . dtype ID SEMI
    (80) init_var_ls -> modifier . dtype ID assign
    (15) dtype -> . CHAR
    (16) dtype -> . DOUBLE
    (17) dtype -> . FLOAT
    (18) dtype -> . INT
    (19) dtype -> . VOID
    (20) dtype -> . UINT8_T
    (21) dtype -> . UINT16_T
    (22) dtype -> . dtype ASTERISK

    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    VOID            shift and go to state 21
    UINT8_T         shift and go to state 22
    UINT16_T        shift and go to state 23

    dtype                          shift and go to state 58

state 26

    (32) control -> WHILE .

    LPAREN          reduce using rule 32 (control -> WHILE .)
    LBRACE          reduce using rule 32 (control -> WHILE .)


state 27

    (33) control -> IF .

    LPAREN          reduce using rule 33 (control -> IF .)
    LBRACE          reduce using rule 33 (control -> IF .)


state 28

    (34) control -> ELSE .

    LPAREN          reduce using rule 34 (control -> ELSE .)
    LBRACE          reduce using rule 34 (control -> ELSE .)


state 29

    (47) for_loop -> FOR . LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN

    LPAREN          shift and go to state 59


state 30

    (23) modifier -> CONST .

    CHAR            reduce using rule 23 (modifier -> CONST .)
    DOUBLE          reduce using rule 23 (modifier -> CONST .)
    FLOAT           reduce using rule 23 (modifier -> CONST .)
    INT             reduce using rule 23 (modifier -> CONST .)
    VOID            reduce using rule 23 (modifier -> CONST .)
    UINT8_T         reduce using rule 23 (modifier -> CONST .)
    UINT16_T        reduce using rule 23 (modifier -> CONST .)


state 31

    (24) modifier -> EXTERN .

    CHAR            reduce using rule 24 (modifier -> EXTERN .)
    DOUBLE          reduce using rule 24 (modifier -> EXTERN .)
    FLOAT           reduce using rule 24 (modifier -> EXTERN .)
    INT             reduce using rule 24 (modifier -> EXTERN .)
    VOID            reduce using rule 24 (modifier -> EXTERN .)
    UINT8_T         reduce using rule 24 (modifier -> EXTERN .)
    UINT16_T        reduce using rule 24 (modifier -> EXTERN .)


state 32

    (25) modifier -> INLINE .

    CHAR            reduce using rule 25 (modifier -> INLINE .)
    DOUBLE          reduce using rule 25 (modifier -> INLINE .)
    FLOAT           reduce using rule 25 (modifier -> INLINE .)
    INT             reduce using rule 25 (modifier -> INLINE .)
    VOID            reduce using rule 25 (modifier -> INLINE .)
    UINT8_T         reduce using rule 25 (modifier -> INLINE .)
    UINT16_T        reduce using rule 25 (modifier -> INLINE .)


state 33

    (26) modifier -> LONG .

    CHAR            reduce using rule 26 (modifier -> LONG .)
    DOUBLE          reduce using rule 26 (modifier -> LONG .)
    FLOAT           reduce using rule 26 (modifier -> LONG .)
    INT             reduce using rule 26 (modifier -> LONG .)
    VOID            reduce using rule 26 (modifier -> LONG .)
    UINT8_T         reduce using rule 26 (modifier -> LONG .)
    UINT16_T        reduce using rule 26 (modifier -> LONG .)


state 34

    (27) modifier -> SHORT .

    CHAR            reduce using rule 27 (modifier -> SHORT .)
    DOUBLE          reduce using rule 27 (modifier -> SHORT .)
    FLOAT           reduce using rule 27 (modifier -> SHORT .)
    INT             reduce using rule 27 (modifier -> SHORT .)
    VOID            reduce using rule 27 (modifier -> SHORT .)
    UINT8_T         reduce using rule 27 (modifier -> SHORT .)
    UINT16_T        reduce using rule 27 (modifier -> SHORT .)


state 35

    (28) modifier -> SIGNED .

    CHAR            reduce using rule 28 (modifier -> SIGNED .)
    DOUBLE          reduce using rule 28 (modifier -> SIGNED .)
    FLOAT           reduce using rule 28 (modifier -> SIGNED .)
    INT             reduce using rule 28 (modifier -> SIGNED .)
    VOID            reduce using rule 28 (modifier -> SIGNED .)
    UINT8_T         reduce using rule 28 (modifier -> SIGNED .)
    UINT16_T        reduce using rule 28 (modifier -> SIGNED .)


state 36

    (29) modifier -> UNSIGNED .

    CHAR            reduce using rule 29 (modifier -> UNSIGNED .)
    DOUBLE          reduce using rule 29 (modifier -> UNSIGNED .)
    FLOAT           reduce using rule 29 (modifier -> UNSIGNED .)
    INT             reduce using rule 29 (modifier -> UNSIGNED .)
    VOID            reduce using rule 29 (modifier -> UNSIGNED .)
    UINT8_T         reduce using rule 29 (modifier -> UNSIGNED .)
    UINT16_T        reduce using rule 29 (modifier -> UNSIGNED .)


state 37

    (30) modifier -> VOLATILE .

    CHAR            reduce using rule 30 (modifier -> VOLATILE .)
    DOUBLE          reduce using rule 30 (modifier -> VOLATILE .)
    FLOAT           reduce using rule 30 (modifier -> VOLATILE .)
    INT             reduce using rule 30 (modifier -> VOLATILE .)
    VOID            reduce using rule 30 (modifier -> VOLATILE .)
    UINT8_T         reduce using rule 30 (modifier -> VOLATILE .)
    UINT16_T        reduce using rule 30 (modifier -> VOLATILE .)


state 38

    (58) func_def -> dtype ID . LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (78) declare_var -> dtype ID . SEMI
    (81) init_var_ls -> dtype ID . assign
    (13) assign -> . SIMPLE_ASSIGN
    (14) assign -> . COMPLEX_ASSIGN

    LPAREN          shift and go to state 60
    SEMI            shift and go to state 61
    SIMPLE_ASSIGN   shift and go to state 43
    COMPLEX_ASSIGN  shift and go to state 44

    assign                         shift and go to state 62

state 39

    (22) dtype -> dtype ASTERISK .

    ID              reduce using rule 22 (dtype -> dtype ASTERISK .)
    ASTERISK        reduce using rule 22 (dtype -> dtype ASTERISK .)
    RPAREN          reduce using rule 22 (dtype -> dtype ASTERISK .)
    COMMA           reduce using rule 22 (dtype -> dtype ASTERISK .)
    LPAREN          reduce using rule 22 (dtype -> dtype ASTERISK .)
    NEGATE          reduce using rule 22 (dtype -> dtype ASTERISK .)
    MINUS           reduce using rule 22 (dtype -> dtype ASTERISK .)
    CHAR            reduce using rule 22 (dtype -> dtype ASTERISK .)
    DOUBLE          reduce using rule 22 (dtype -> dtype ASTERISK .)
    FLOAT           reduce using rule 22 (dtype -> dtype ASTERISK .)
    INT             reduce using rule 22 (dtype -> dtype ASTERISK .)
    VOID            reduce using rule 22 (dtype -> dtype ASTERISK .)
    UINT8_T         reduce using rule 22 (dtype -> dtype ASTERISK .)
    UINT16_T        reduce using rule 22 (dtype -> dtype ASTERISK .)
    STRING          reduce using rule 22 (dtype -> dtype ASTERISK .)
    NONDECIMAL      reduce using rule 22 (dtype -> dtype ASTERISK .)


state 40

    (59) func_call -> ID LPAREN . func_arglist RPAREN SEMI
    (55) func_arglist -> .
    (56) func_arglist -> . func_arglist func_arg
    (57) func_arglist -> . func_arglist func_arg COMMA

    RPAREN          reduce using rule 55 (func_arglist -> .)
    ID              reduce using rule 55 (func_arglist -> .)
    LPAREN          reduce using rule 55 (func_arglist -> .)
    NEGATE          reduce using rule 55 (func_arglist -> .)
    MINUS           reduce using rule 55 (func_arglist -> .)
    CHAR            reduce using rule 55 (func_arglist -> .)
    DOUBLE          reduce using rule 55 (func_arglist -> .)
    FLOAT           reduce using rule 55 (func_arglist -> .)
    INT             reduce using rule 55 (func_arglist -> .)
    VOID            reduce using rule 55 (func_arglist -> .)
    UINT8_T         reduce using rule 55 (func_arglist -> .)
    UINT16_T        reduce using rule 55 (func_arglist -> .)
    STRING          reduce using rule 55 (func_arglist -> .)
    NONDECIMAL      reduce using rule 55 (func_arglist -> .)

    func_arglist                   shift and go to state 63

state 41

    (88) assign_var -> ID assign . expression SEMI
    (64) expression -> . literal
    (65) expression -> . LPAREN expression RPAREN
    (66) expression -> . NEGATE expression
    (67) expression -> . MINUS expression
    (75) expression -> . expression binop ID
    (76) expression -> . ID binop expression
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    LPAREN          shift and go to state 67
    NEGATE          shift and go to state 68
    MINUS           shift and go to state 69
    ID              shift and go to state 64
    FLOAT           shift and go to state 53
    INT             shift and go to state 54
    CHAR            shift and go to state 55
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    expression                     shift and go to state 65
    literal                        shift and go to state 66

state 42

    (77) increment -> ID INCREMENT . SEMI

    SEMI            shift and go to state 70


state 43

    (13) assign -> SIMPLE_ASSIGN .

    LPAREN          reduce using rule 13 (assign -> SIMPLE_ASSIGN .)
    NEGATE          reduce using rule 13 (assign -> SIMPLE_ASSIGN .)
    MINUS           reduce using rule 13 (assign -> SIMPLE_ASSIGN .)
    ID              reduce using rule 13 (assign -> SIMPLE_ASSIGN .)
    FLOAT           reduce using rule 13 (assign -> SIMPLE_ASSIGN .)
    INT             reduce using rule 13 (assign -> SIMPLE_ASSIGN .)
    CHAR            reduce using rule 13 (assign -> SIMPLE_ASSIGN .)
    STRING          reduce using rule 13 (assign -> SIMPLE_ASSIGN .)
    NONDECIMAL      reduce using rule 13 (assign -> SIMPLE_ASSIGN .)


state 44

    (14) assign -> COMPLEX_ASSIGN .

    LPAREN          reduce using rule 14 (assign -> COMPLEX_ASSIGN .)
    NEGATE          reduce using rule 14 (assign -> COMPLEX_ASSIGN .)
    MINUS           reduce using rule 14 (assign -> COMPLEX_ASSIGN .)
    ID              reduce using rule 14 (assign -> COMPLEX_ASSIGN .)
    FLOAT           reduce using rule 14 (assign -> COMPLEX_ASSIGN .)
    INT             reduce using rule 14 (assign -> COMPLEX_ASSIGN .)
    CHAR            reduce using rule 14 (assign -> COMPLEX_ASSIGN .)
    STRING          reduce using rule 14 (assign -> COMPLEX_ASSIGN .)
    NONDECIMAL      reduce using rule 14 (assign -> COMPLEX_ASSIGN .)


state 45

    (48) control_expr -> control LPAREN . conditional_expr RPAREN LBRACE node_list RBRACE
    (43) conditional_expr -> . ID conditional expression
    (44) conditional_expr -> . expression conditional ID
    (45) conditional_expr -> . expression conditional expression
    (46) conditional_expr -> . ID conditional ID
    (64) expression -> . literal
    (65) expression -> . LPAREN expression RPAREN
    (66) expression -> . NEGATE expression
    (67) expression -> . MINUS expression
    (75) expression -> . expression binop ID
    (76) expression -> . ID binop expression
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    ID              shift and go to state 72
    LPAREN          shift and go to state 67
    NEGATE          shift and go to state 68
    MINUS           shift and go to state 69
    FLOAT           shift and go to state 53
    INT             shift and go to state 54
    CHAR            shift and go to state 55
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    conditional_expr               shift and go to state 71
    expression                     shift and go to state 73
    literal                        shift and go to state 66

state 46

    (49) control_expr -> control LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 74

state 47

    (50) control_expr -> for_loop LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 75

state 48

    (87) init_var -> init_var_ls init_var_rs .

    INCLUDE         reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    ID              reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    CHAR            reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    DOUBLE          reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    FLOAT           reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    INT             reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    VOID            reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    UINT8_T         reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    UINT16_T        reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    WHILE           reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    IF              reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    ELSE            reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    FOR             reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    CONST           reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    EXTERN          reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    INLINE          reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    LONG            reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    SHORT           reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    SIGNED          reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    UNSIGNED        reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    VOLATILE        reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    $end            reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    LPAREN          reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    NEGATE          reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    MINUS           reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    STRING          reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    NONDECIMAL      reduce using rule 87 (init_var -> init_var_ls init_var_rs .)
    RBRACE          reduce using rule 87 (init_var -> init_var_ls init_var_rs .)


state 49

    (82) init_var_rs -> literal . SEMI

    SEMI            shift and go to state 76


state 50

    (83) init_var_rs -> ID . SEMI
    (59) func_call -> ID . LPAREN func_arglist RPAREN SEMI

    SEMI            shift and go to state 77
    LPAREN          shift and go to state 40


state 51

    (84) init_var_rs -> LPAREN . dtype RPAREN literal SEMI
    (85) init_var_rs -> LPAREN . dtype RPAREN ID SEMI
    (15) dtype -> . CHAR
    (16) dtype -> . DOUBLE
    (17) dtype -> . FLOAT
    (18) dtype -> . INT
    (19) dtype -> . VOID
    (20) dtype -> . UINT8_T
    (21) dtype -> . UINT16_T
    (22) dtype -> . dtype ASTERISK

    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    VOID            shift and go to state 21
    UINT8_T         shift and go to state 22
    UINT16_T        shift and go to state 23

    dtype                          shift and go to state 78

state 52

    (86) init_var_rs -> func_call .

    INCLUDE         reduce using rule 86 (init_var_rs -> func_call .)
    ID              reduce using rule 86 (init_var_rs -> func_call .)
    CHAR            reduce using rule 86 (init_var_rs -> func_call .)
    DOUBLE          reduce using rule 86 (init_var_rs -> func_call .)
    FLOAT           reduce using rule 86 (init_var_rs -> func_call .)
    INT             reduce using rule 86 (init_var_rs -> func_call .)
    VOID            reduce using rule 86 (init_var_rs -> func_call .)
    UINT8_T         reduce using rule 86 (init_var_rs -> func_call .)
    UINT16_T        reduce using rule 86 (init_var_rs -> func_call .)
    WHILE           reduce using rule 86 (init_var_rs -> func_call .)
    IF              reduce using rule 86 (init_var_rs -> func_call .)
    ELSE            reduce using rule 86 (init_var_rs -> func_call .)
    FOR             reduce using rule 86 (init_var_rs -> func_call .)
    CONST           reduce using rule 86 (init_var_rs -> func_call .)
    EXTERN          reduce using rule 86 (init_var_rs -> func_call .)
    INLINE          reduce using rule 86 (init_var_rs -> func_call .)
    LONG            reduce using rule 86 (init_var_rs -> func_call .)
    SHORT           reduce using rule 86 (init_var_rs -> func_call .)
    SIGNED          reduce using rule 86 (init_var_rs -> func_call .)
    UNSIGNED        reduce using rule 86 (init_var_rs -> func_call .)
    VOLATILE        reduce using rule 86 (init_var_rs -> func_call .)
    $end            reduce using rule 86 (init_var_rs -> func_call .)
    LPAREN          reduce using rule 86 (init_var_rs -> func_call .)
    NEGATE          reduce using rule 86 (init_var_rs -> func_call .)
    MINUS           reduce using rule 86 (init_var_rs -> func_call .)
    STRING          reduce using rule 86 (init_var_rs -> func_call .)
    NONDECIMAL      reduce using rule 86 (init_var_rs -> func_call .)
    RBRACE          reduce using rule 86 (init_var_rs -> func_call .)


state 53

    (8) literal -> FLOAT .

    SEMI            reduce using rule 8 (literal -> FLOAT .)
    PLUS            reduce using rule 8 (literal -> FLOAT .)
    MINUS           reduce using rule 8 (literal -> FLOAT .)
    ASTERISK        reduce using rule 8 (literal -> FLOAT .)
    DIVIDE          reduce using rule 8 (literal -> FLOAT .)
    LSHIFT          reduce using rule 8 (literal -> FLOAT .)
    RSHIFT          reduce using rule 8 (literal -> FLOAT .)
    PERCENT         reduce using rule 8 (literal -> FLOAT .)
    EQ              reduce using rule 8 (literal -> FLOAT .)
    NEQ             reduce using rule 8 (literal -> FLOAT .)
    LT              reduce using rule 8 (literal -> FLOAT .)
    GT              reduce using rule 8 (literal -> FLOAT .)
    LE              reduce using rule 8 (literal -> FLOAT .)
    GE              reduce using rule 8 (literal -> FLOAT .)
    AND             reduce using rule 8 (literal -> FLOAT .)
    OR              reduce using rule 8 (literal -> FLOAT .)
    RPAREN          reduce using rule 8 (literal -> FLOAT .)
    COMMA           reduce using rule 8 (literal -> FLOAT .)
    ID              reduce using rule 8 (literal -> FLOAT .)
    LPAREN          reduce using rule 8 (literal -> FLOAT .)
    NEGATE          reduce using rule 8 (literal -> FLOAT .)
    CHAR            reduce using rule 8 (literal -> FLOAT .)
    DOUBLE          reduce using rule 8 (literal -> FLOAT .)
    FLOAT           reduce using rule 8 (literal -> FLOAT .)
    INT             reduce using rule 8 (literal -> FLOAT .)
    VOID            reduce using rule 8 (literal -> FLOAT .)
    UINT8_T         reduce using rule 8 (literal -> FLOAT .)
    UINT16_T        reduce using rule 8 (literal -> FLOAT .)
    STRING          reduce using rule 8 (literal -> FLOAT .)
    NONDECIMAL      reduce using rule 8 (literal -> FLOAT .)


state 54

    (9) literal -> INT .

    SEMI            reduce using rule 9 (literal -> INT .)
    PLUS            reduce using rule 9 (literal -> INT .)
    MINUS           reduce using rule 9 (literal -> INT .)
    ASTERISK        reduce using rule 9 (literal -> INT .)
    DIVIDE          reduce using rule 9 (literal -> INT .)
    LSHIFT          reduce using rule 9 (literal -> INT .)
    RSHIFT          reduce using rule 9 (literal -> INT .)
    PERCENT         reduce using rule 9 (literal -> INT .)
    EQ              reduce using rule 9 (literal -> INT .)
    NEQ             reduce using rule 9 (literal -> INT .)
    LT              reduce using rule 9 (literal -> INT .)
    GT              reduce using rule 9 (literal -> INT .)
    LE              reduce using rule 9 (literal -> INT .)
    GE              reduce using rule 9 (literal -> INT .)
    AND             reduce using rule 9 (literal -> INT .)
    OR              reduce using rule 9 (literal -> INT .)
    RPAREN          reduce using rule 9 (literal -> INT .)
    COMMA           reduce using rule 9 (literal -> INT .)
    ID              reduce using rule 9 (literal -> INT .)
    LPAREN          reduce using rule 9 (literal -> INT .)
    NEGATE          reduce using rule 9 (literal -> INT .)
    CHAR            reduce using rule 9 (literal -> INT .)
    DOUBLE          reduce using rule 9 (literal -> INT .)
    FLOAT           reduce using rule 9 (literal -> INT .)
    INT             reduce using rule 9 (literal -> INT .)
    VOID            reduce using rule 9 (literal -> INT .)
    UINT8_T         reduce using rule 9 (literal -> INT .)
    UINT16_T        reduce using rule 9 (literal -> INT .)
    STRING          reduce using rule 9 (literal -> INT .)
    NONDECIMAL      reduce using rule 9 (literal -> INT .)


state 55

    (10) literal -> CHAR .

    SEMI            reduce using rule 10 (literal -> CHAR .)
    PLUS            reduce using rule 10 (literal -> CHAR .)
    MINUS           reduce using rule 10 (literal -> CHAR .)
    ASTERISK        reduce using rule 10 (literal -> CHAR .)
    DIVIDE          reduce using rule 10 (literal -> CHAR .)
    LSHIFT          reduce using rule 10 (literal -> CHAR .)
    RSHIFT          reduce using rule 10 (literal -> CHAR .)
    PERCENT         reduce using rule 10 (literal -> CHAR .)
    EQ              reduce using rule 10 (literal -> CHAR .)
    NEQ             reduce using rule 10 (literal -> CHAR .)
    LT              reduce using rule 10 (literal -> CHAR .)
    GT              reduce using rule 10 (literal -> CHAR .)
    LE              reduce using rule 10 (literal -> CHAR .)
    GE              reduce using rule 10 (literal -> CHAR .)
    AND             reduce using rule 10 (literal -> CHAR .)
    OR              reduce using rule 10 (literal -> CHAR .)
    RPAREN          reduce using rule 10 (literal -> CHAR .)
    COMMA           reduce using rule 10 (literal -> CHAR .)
    ID              reduce using rule 10 (literal -> CHAR .)
    LPAREN          reduce using rule 10 (literal -> CHAR .)
    NEGATE          reduce using rule 10 (literal -> CHAR .)
    CHAR            reduce using rule 10 (literal -> CHAR .)
    DOUBLE          reduce using rule 10 (literal -> CHAR .)
    FLOAT           reduce using rule 10 (literal -> CHAR .)
    INT             reduce using rule 10 (literal -> CHAR .)
    VOID            reduce using rule 10 (literal -> CHAR .)
    UINT8_T         reduce using rule 10 (literal -> CHAR .)
    UINT16_T        reduce using rule 10 (literal -> CHAR .)
    STRING          reduce using rule 10 (literal -> CHAR .)
    NONDECIMAL      reduce using rule 10 (literal -> CHAR .)


state 56

    (11) literal -> STRING .

    SEMI            reduce using rule 11 (literal -> STRING .)
    PLUS            reduce using rule 11 (literal -> STRING .)
    MINUS           reduce using rule 11 (literal -> STRING .)
    ASTERISK        reduce using rule 11 (literal -> STRING .)
    DIVIDE          reduce using rule 11 (literal -> STRING .)
    LSHIFT          reduce using rule 11 (literal -> STRING .)
    RSHIFT          reduce using rule 11 (literal -> STRING .)
    PERCENT         reduce using rule 11 (literal -> STRING .)
    EQ              reduce using rule 11 (literal -> STRING .)
    NEQ             reduce using rule 11 (literal -> STRING .)
    LT              reduce using rule 11 (literal -> STRING .)
    GT              reduce using rule 11 (literal -> STRING .)
    LE              reduce using rule 11 (literal -> STRING .)
    GE              reduce using rule 11 (literal -> STRING .)
    AND             reduce using rule 11 (literal -> STRING .)
    OR              reduce using rule 11 (literal -> STRING .)
    COMMA           reduce using rule 11 (literal -> STRING .)
    RPAREN          reduce using rule 11 (literal -> STRING .)
    ID              reduce using rule 11 (literal -> STRING .)
    LPAREN          reduce using rule 11 (literal -> STRING .)
    NEGATE          reduce using rule 11 (literal -> STRING .)
    CHAR            reduce using rule 11 (literal -> STRING .)
    DOUBLE          reduce using rule 11 (literal -> STRING .)
    FLOAT           reduce using rule 11 (literal -> STRING .)
    INT             reduce using rule 11 (literal -> STRING .)
    VOID            reduce using rule 11 (literal -> STRING .)
    UINT8_T         reduce using rule 11 (literal -> STRING .)
    UINT16_T        reduce using rule 11 (literal -> STRING .)
    STRING          reduce using rule 11 (literal -> STRING .)
    NONDECIMAL      reduce using rule 11 (literal -> STRING .)


state 57

    (12) literal -> NONDECIMAL .

    SEMI            reduce using rule 12 (literal -> NONDECIMAL .)
    PLUS            reduce using rule 12 (literal -> NONDECIMAL .)
    MINUS           reduce using rule 12 (literal -> NONDECIMAL .)
    ASTERISK        reduce using rule 12 (literal -> NONDECIMAL .)
    DIVIDE          reduce using rule 12 (literal -> NONDECIMAL .)
    LSHIFT          reduce using rule 12 (literal -> NONDECIMAL .)
    RSHIFT          reduce using rule 12 (literal -> NONDECIMAL .)
    PERCENT         reduce using rule 12 (literal -> NONDECIMAL .)
    EQ              reduce using rule 12 (literal -> NONDECIMAL .)
    NEQ             reduce using rule 12 (literal -> NONDECIMAL .)
    LT              reduce using rule 12 (literal -> NONDECIMAL .)
    GT              reduce using rule 12 (literal -> NONDECIMAL .)
    LE              reduce using rule 12 (literal -> NONDECIMAL .)
    GE              reduce using rule 12 (literal -> NONDECIMAL .)
    AND             reduce using rule 12 (literal -> NONDECIMAL .)
    OR              reduce using rule 12 (literal -> NONDECIMAL .)
    COMMA           reduce using rule 12 (literal -> NONDECIMAL .)
    RPAREN          reduce using rule 12 (literal -> NONDECIMAL .)
    ID              reduce using rule 12 (literal -> NONDECIMAL .)
    LPAREN          reduce using rule 12 (literal -> NONDECIMAL .)
    NEGATE          reduce using rule 12 (literal -> NONDECIMAL .)
    CHAR            reduce using rule 12 (literal -> NONDECIMAL .)
    DOUBLE          reduce using rule 12 (literal -> NONDECIMAL .)
    FLOAT           reduce using rule 12 (literal -> NONDECIMAL .)
    INT             reduce using rule 12 (literal -> NONDECIMAL .)
    VOID            reduce using rule 12 (literal -> NONDECIMAL .)
    UINT8_T         reduce using rule 12 (literal -> NONDECIMAL .)
    UINT16_T        reduce using rule 12 (literal -> NONDECIMAL .)
    STRING          reduce using rule 12 (literal -> NONDECIMAL .)
    NONDECIMAL      reduce using rule 12 (literal -> NONDECIMAL .)


state 58

    (79) declare_var -> modifier dtype . ID SEMI
    (80) init_var_ls -> modifier dtype . ID assign
    (22) dtype -> dtype . ASTERISK

    ID              shift and go to state 79
    ASTERISK        shift and go to state 39


state 59

    (47) for_loop -> FOR LPAREN . init_var conditional_expr SEMI ID INCREMENT RPAREN
    (87) init_var -> . init_var_ls init_var_rs
    (80) init_var_ls -> . modifier dtype ID assign
    (81) init_var_ls -> . dtype ID assign
    (23) modifier -> . CONST
    (24) modifier -> . EXTERN
    (25) modifier -> . INLINE
    (26) modifier -> . LONG
    (27) modifier -> . SHORT
    (28) modifier -> . SIGNED
    (29) modifier -> . UNSIGNED
    (30) modifier -> . VOLATILE
    (15) dtype -> . CHAR
    (16) dtype -> . DOUBLE
    (17) dtype -> . FLOAT
    (18) dtype -> . INT
    (19) dtype -> . VOID
    (20) dtype -> . UINT8_T
    (21) dtype -> . UINT16_T
    (22) dtype -> . dtype ASTERISK

    CONST           shift and go to state 30
    EXTERN          shift and go to state 31
    INLINE          shift and go to state 32
    LONG            shift and go to state 33
    SHORT           shift and go to state 34
    SIGNED          shift and go to state 35
    UNSIGNED        shift and go to state 36
    VOLATILE        shift and go to state 37
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    VOID            shift and go to state 21
    UINT8_T         shift and go to state 22
    UINT16_T        shift and go to state 23

    init_var                       shift and go to state 80
    init_var_ls                    shift and go to state 24
    modifier                       shift and go to state 81
    dtype                          shift and go to state 82

state 60

    (58) func_def -> dtype ID LPAREN . func_arglist RPAREN LBRACE node_list RBRACE
    (55) func_arglist -> .
    (56) func_arglist -> . func_arglist func_arg
    (57) func_arglist -> . func_arglist func_arg COMMA

    RPAREN          reduce using rule 55 (func_arglist -> .)
    ID              reduce using rule 55 (func_arglist -> .)
    LPAREN          reduce using rule 55 (func_arglist -> .)
    NEGATE          reduce using rule 55 (func_arglist -> .)
    MINUS           reduce using rule 55 (func_arglist -> .)
    CHAR            reduce using rule 55 (func_arglist -> .)
    DOUBLE          reduce using rule 55 (func_arglist -> .)
    FLOAT           reduce using rule 55 (func_arglist -> .)
    INT             reduce using rule 55 (func_arglist -> .)
    VOID            reduce using rule 55 (func_arglist -> .)
    UINT8_T         reduce using rule 55 (func_arglist -> .)
    UINT16_T        reduce using rule 55 (func_arglist -> .)
    STRING          reduce using rule 55 (func_arglist -> .)
    NONDECIMAL      reduce using rule 55 (func_arglist -> .)

    func_arglist                   shift and go to state 83

state 61

    (78) declare_var -> dtype ID SEMI .

    INCLUDE         reduce using rule 78 (declare_var -> dtype ID SEMI .)
    ID              reduce using rule 78 (declare_var -> dtype ID SEMI .)
    CHAR            reduce using rule 78 (declare_var -> dtype ID SEMI .)
    DOUBLE          reduce using rule 78 (declare_var -> dtype ID SEMI .)
    FLOAT           reduce using rule 78 (declare_var -> dtype ID SEMI .)
    INT             reduce using rule 78 (declare_var -> dtype ID SEMI .)
    VOID            reduce using rule 78 (declare_var -> dtype ID SEMI .)
    UINT8_T         reduce using rule 78 (declare_var -> dtype ID SEMI .)
    UINT16_T        reduce using rule 78 (declare_var -> dtype ID SEMI .)
    WHILE           reduce using rule 78 (declare_var -> dtype ID SEMI .)
    IF              reduce using rule 78 (declare_var -> dtype ID SEMI .)
    ELSE            reduce using rule 78 (declare_var -> dtype ID SEMI .)
    FOR             reduce using rule 78 (declare_var -> dtype ID SEMI .)
    CONST           reduce using rule 78 (declare_var -> dtype ID SEMI .)
    EXTERN          reduce using rule 78 (declare_var -> dtype ID SEMI .)
    INLINE          reduce using rule 78 (declare_var -> dtype ID SEMI .)
    LONG            reduce using rule 78 (declare_var -> dtype ID SEMI .)
    SHORT           reduce using rule 78 (declare_var -> dtype ID SEMI .)
    SIGNED          reduce using rule 78 (declare_var -> dtype ID SEMI .)
    UNSIGNED        reduce using rule 78 (declare_var -> dtype ID SEMI .)
    VOLATILE        reduce using rule 78 (declare_var -> dtype ID SEMI .)
    $end            reduce using rule 78 (declare_var -> dtype ID SEMI .)
    RBRACE          reduce using rule 78 (declare_var -> dtype ID SEMI .)


state 62

    (81) init_var_ls -> dtype ID assign .

    ID              reduce using rule 81 (init_var_ls -> dtype ID assign .)
    LPAREN          reduce using rule 81 (init_var_ls -> dtype ID assign .)
    FLOAT           reduce using rule 81 (init_var_ls -> dtype ID assign .)
    INT             reduce using rule 81 (init_var_ls -> dtype ID assign .)
    CHAR            reduce using rule 81 (init_var_ls -> dtype ID assign .)
    STRING          reduce using rule 81 (init_var_ls -> dtype ID assign .)
    NONDECIMAL      reduce using rule 81 (init_var_ls -> dtype ID assign .)


state 63

    (59) func_call -> ID LPAREN func_arglist . RPAREN SEMI
    (56) func_arglist -> func_arglist . func_arg
    (57) func_arglist -> func_arglist . func_arg COMMA
    (51) func_arg -> . ID
    (52) func_arg -> . expression
    (53) func_arg -> . dtype ID
    (54) func_arg -> . dtype
    (64) expression -> . literal
    (65) expression -> . LPAREN expression RPAREN
    (66) expression -> . NEGATE expression
    (67) expression -> . MINUS expression
    (75) expression -> . expression binop ID
    (76) expression -> . ID binop expression
    (15) dtype -> . CHAR
    (16) dtype -> . DOUBLE
    (17) dtype -> . FLOAT
    (18) dtype -> . INT
    (19) dtype -> . VOID
    (20) dtype -> . UINT8_T
    (21) dtype -> . UINT16_T
    (22) dtype -> . dtype ASTERISK
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    RPAREN          shift and go to state 85
    ID              shift and go to state 84
    LPAREN          shift and go to state 67
    NEGATE          shift and go to state 68
    MINUS           shift and go to state 69
    CHAR            shift and go to state 89
    DOUBLE          shift and go to state 18
    FLOAT           shift and go to state 90
    INT             shift and go to state 91
    VOID            shift and go to state 21
    UINT8_T         shift and go to state 22
    UINT16_T        shift and go to state 23
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    func_arg                       shift and go to state 86
    expression                     shift and go to state 87
    dtype                          shift and go to state 88
    literal                        shift and go to state 66

state 64

    (76) expression -> ID . binop expression
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

    binop                          shift and go to state 92

state 65

    (88) assign_var -> ID assign expression . SEMI
    (75) expression -> expression . binop ID
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

    SEMI            shift and go to state 100
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

    binop                          shift and go to state 101

state 66

    (64) expression -> literal .

    SEMI            reduce using rule 64 (expression -> literal .)
    PLUS            reduce using rule 64 (expression -> literal .)
    MINUS           reduce using rule 64 (expression -> literal .)
    ASTERISK        reduce using rule 64 (expression -> literal .)
    DIVIDE          reduce using rule 64 (expression -> literal .)
    LSHIFT          reduce using rule 64 (expression -> literal .)
    RSHIFT          reduce using rule 64 (expression -> literal .)
    PERCENT         reduce using rule 64 (expression -> literal .)
    EQ              reduce using rule 64 (expression -> literal .)
    NEQ             reduce using rule 64 (expression -> literal .)
    LT              reduce using rule 64 (expression -> literal .)
    GT              reduce using rule 64 (expression -> literal .)
    LE              reduce using rule 64 (expression -> literal .)
    GE              reduce using rule 64 (expression -> literal .)
    AND             reduce using rule 64 (expression -> literal .)
    OR              reduce using rule 64 (expression -> literal .)
    COMMA           reduce using rule 64 (expression -> literal .)
    RPAREN          reduce using rule 64 (expression -> literal .)
    ID              reduce using rule 64 (expression -> literal .)
    LPAREN          reduce using rule 64 (expression -> literal .)
    NEGATE          reduce using rule 64 (expression -> literal .)
    CHAR            reduce using rule 64 (expression -> literal .)
    DOUBLE          reduce using rule 64 (expression -> literal .)
    FLOAT           reduce using rule 64 (expression -> literal .)
    INT             reduce using rule 64 (expression -> literal .)
    VOID            reduce using rule 64 (expression -> literal .)
    UINT8_T         reduce using rule 64 (expression -> literal .)
    UINT16_T        reduce using rule 64 (expression -> literal .)
    STRING          reduce using rule 64 (expression -> literal .)
    NONDECIMAL      reduce using rule 64 (expression -> literal .)


state 67

    (65) expression -> LPAREN . expression RPAREN
    (64) expression -> . literal
    (65) expression -> . LPAREN expression RPAREN
    (66) expression -> . NEGATE expression
    (67) expression -> . MINUS expression
    (75) expression -> . expression binop ID
    (76) expression -> . ID binop expression
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    LPAREN          shift and go to state 67
    NEGATE          shift and go to state 68
    MINUS           shift and go to state 69
    ID              shift and go to state 64
    FLOAT           shift and go to state 53
    INT             shift and go to state 54
    CHAR            shift and go to state 55
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    expression                     shift and go to state 102
    literal                        shift and go to state 66

state 68

    (66) expression -> NEGATE . expression
    (64) expression -> . literal
    (65) expression -> . LPAREN expression RPAREN
    (66) expression -> . NEGATE expression
    (67) expression -> . MINUS expression
    (75) expression -> . expression binop ID
    (76) expression -> . ID binop expression
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    LPAREN          shift and go to state 67
    NEGATE          shift and go to state 68
    MINUS           shift and go to state 69
    ID              shift and go to state 64
    FLOAT           shift and go to state 53
    INT             shift and go to state 54
    CHAR            shift and go to state 55
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    expression                     shift and go to state 103
    literal                        shift and go to state 66

state 69

    (67) expression -> MINUS . expression
    (64) expression -> . literal
    (65) expression -> . LPAREN expression RPAREN
    (66) expression -> . NEGATE expression
    (67) expression -> . MINUS expression
    (75) expression -> . expression binop ID
    (76) expression -> . ID binop expression
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    LPAREN          shift and go to state 67
    NEGATE          shift and go to state 68
    MINUS           shift and go to state 69
    ID              shift and go to state 64
    FLOAT           shift and go to state 53
    INT             shift and go to state 54
    CHAR            shift and go to state 55
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    expression                     shift and go to state 104
    literal                        shift and go to state 66

state 70

    (77) increment -> ID INCREMENT SEMI .

    INCLUDE         reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    ID              reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    CHAR            reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    DOUBLE          reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    FLOAT           reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    INT             reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    VOID            reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    UINT8_T         reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    UINT16_T        reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    WHILE           reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    IF              reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    ELSE            reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    FOR             reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    CONST           reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    EXTERN          reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    INLINE          reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    LONG            reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    SHORT           reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    SIGNED          reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    UNSIGNED        reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    VOLATILE        reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    $end            reduce using rule 77 (increment -> ID INCREMENT SEMI .)
    RBRACE          reduce using rule 77 (increment -> ID INCREMENT SEMI .)


state 71

    (48) control_expr -> control LPAREN conditional_expr . RPAREN LBRACE node_list RBRACE

    RPAREN          shift and go to state 105


state 72

    (43) conditional_expr -> ID . conditional expression
    (46) conditional_expr -> ID . conditional ID
    (76) expression -> ID . binop expression
    (35) conditional -> . EQ
    (36) conditional -> . NEQ
    (37) conditional -> . LT
    (38) conditional -> . GT
    (39) conditional -> . LE
    (40) conditional -> . GE
    (41) conditional -> . AND
    (42) conditional -> . OR
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LE              shift and go to state 111
    GE              shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

    conditional                    shift and go to state 106
    binop                          shift and go to state 92

state 73

    (44) conditional_expr -> expression . conditional ID
    (45) conditional_expr -> expression . conditional expression
    (75) expression -> expression . binop ID
    (35) conditional -> . EQ
    (36) conditional -> . NEQ
    (37) conditional -> . LT
    (38) conditional -> . GT
    (39) conditional -> . LE
    (40) conditional -> . GE
    (41) conditional -> . AND
    (42) conditional -> . OR
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LE              shift and go to state 111
    GE              shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

    conditional                    shift and go to state 115
    binop                          shift and go to state 101

state 74

    (49) control_expr -> control LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . func_def
    (5) node -> . func_call
    (6) node -> . statement
    (7) node -> . control_expr
    (31) include -> . INCLUDE
    (58) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (59) func_call -> . ID LPAREN func_arglist RPAREN SEMI
    (60) statement -> . init_var
    (61) statement -> . assign_var
    (62) statement -> . declare_var
    (63) statement -> . increment
    (48) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (49) control_expr -> . control LBRACE node_list RBRACE
    (50) control_expr -> . for_loop LBRACE node_list RBRACE
    (15) dtype -> . CHAR
    (16) dtype -> . DOUBLE
    (17) dtype -> . FLOAT
    (18) dtype -> . INT
    (19) dtype -> . VOID
    (20) dtype -> . UINT8_T
    (21) dtype -> . UINT16_T
    (22) dtype -> . dtype ASTERISK
    (87) init_var -> . init_var_ls init_var_rs
    (88) assign_var -> . ID assign expression SEMI
    (78) declare_var -> . dtype ID SEMI
    (79) declare_var -> . modifier dtype ID SEMI
    (77) increment -> . ID INCREMENT SEMI
    (32) control -> . WHILE
    (33) control -> . IF
    (34) control -> . ELSE
    (47) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (80) init_var_ls -> . modifier dtype ID assign
    (81) init_var_ls -> . dtype ID assign
    (23) modifier -> . CONST
    (24) modifier -> . EXTERN
    (25) modifier -> . INLINE
    (26) modifier -> . LONG
    (27) modifier -> . SHORT
    (28) modifier -> . SIGNED
    (29) modifier -> . UNSIGNED
    (30) modifier -> . VOLATILE

    RBRACE          shift and go to state 116
    INCLUDE         shift and go to state 8
    ID              shift and go to state 10
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    VOID            shift and go to state 21
    UINT8_T         shift and go to state 22
    UINT16_T        shift and go to state 23
    WHILE           shift and go to state 26
    IF              shift and go to state 27
    ELSE            shift and go to state 28
    FOR             shift and go to state 29
    CONST           shift and go to state 30
    EXTERN          shift and go to state 31
    INLINE          shift and go to state 32
    LONG            shift and go to state 33
    SHORT           shift and go to state 34
    SIGNED          shift and go to state 35
    UNSIGNED        shift and go to state 36
    VOLATILE        shift and go to state 37

    control                        shift and go to state 15
    node                           shift and go to state 2
    include                        shift and go to state 3
    func_def                       shift and go to state 4
    func_call                      shift and go to state 5
    statement                      shift and go to state 6
    control_expr                   shift and go to state 7
    dtype                          shift and go to state 9
    init_var                       shift and go to state 11
    assign_var                     shift and go to state 12
    declare_var                    shift and go to state 13
    increment                      shift and go to state 14
    for_loop                       shift and go to state 16
    init_var_ls                    shift and go to state 24
    modifier                       shift and go to state 25

state 75

    (50) control_expr -> for_loop LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . func_def
    (5) node -> . func_call
    (6) node -> . statement
    (7) node -> . control_expr
    (31) include -> . INCLUDE
    (58) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (59) func_call -> . ID LPAREN func_arglist RPAREN SEMI
    (60) statement -> . init_var
    (61) statement -> . assign_var
    (62) statement -> . declare_var
    (63) statement -> . increment
    (48) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (49) control_expr -> . control LBRACE node_list RBRACE
    (50) control_expr -> . for_loop LBRACE node_list RBRACE
    (15) dtype -> . CHAR
    (16) dtype -> . DOUBLE
    (17) dtype -> . FLOAT
    (18) dtype -> . INT
    (19) dtype -> . VOID
    (20) dtype -> . UINT8_T
    (21) dtype -> . UINT16_T
    (22) dtype -> . dtype ASTERISK
    (87) init_var -> . init_var_ls init_var_rs
    (88) assign_var -> . ID assign expression SEMI
    (78) declare_var -> . dtype ID SEMI
    (79) declare_var -> . modifier dtype ID SEMI
    (77) increment -> . ID INCREMENT SEMI
    (32) control -> . WHILE
    (33) control -> . IF
    (34) control -> . ELSE
    (47) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (80) init_var_ls -> . modifier dtype ID assign
    (81) init_var_ls -> . dtype ID assign
    (23) modifier -> . CONST
    (24) modifier -> . EXTERN
    (25) modifier -> . INLINE
    (26) modifier -> . LONG
    (27) modifier -> . SHORT
    (28) modifier -> . SIGNED
    (29) modifier -> . UNSIGNED
    (30) modifier -> . VOLATILE

    RBRACE          shift and go to state 117
    INCLUDE         shift and go to state 8
    ID              shift and go to state 10
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    VOID            shift and go to state 21
    UINT8_T         shift and go to state 22
    UINT16_T        shift and go to state 23
    WHILE           shift and go to state 26
    IF              shift and go to state 27
    ELSE            shift and go to state 28
    FOR             shift and go to state 29
    CONST           shift and go to state 30
    EXTERN          shift and go to state 31
    INLINE          shift and go to state 32
    LONG            shift and go to state 33
    SHORT           shift and go to state 34
    SIGNED          shift and go to state 35
    UNSIGNED        shift and go to state 36
    VOLATILE        shift and go to state 37

    for_loop                       shift and go to state 16
    node                           shift and go to state 2
    include                        shift and go to state 3
    func_def                       shift and go to state 4
    func_call                      shift and go to state 5
    statement                      shift and go to state 6
    control_expr                   shift and go to state 7
    dtype                          shift and go to state 9
    init_var                       shift and go to state 11
    assign_var                     shift and go to state 12
    declare_var                    shift and go to state 13
    increment                      shift and go to state 14
    control                        shift and go to state 15
    init_var_ls                    shift and go to state 24
    modifier                       shift and go to state 25

state 76

    (82) init_var_rs -> literal SEMI .

    INCLUDE         reduce using rule 82 (init_var_rs -> literal SEMI .)
    ID              reduce using rule 82 (init_var_rs -> literal SEMI .)
    CHAR            reduce using rule 82 (init_var_rs -> literal SEMI .)
    DOUBLE          reduce using rule 82 (init_var_rs -> literal SEMI .)
    FLOAT           reduce using rule 82 (init_var_rs -> literal SEMI .)
    INT             reduce using rule 82 (init_var_rs -> literal SEMI .)
    VOID            reduce using rule 82 (init_var_rs -> literal SEMI .)
    UINT8_T         reduce using rule 82 (init_var_rs -> literal SEMI .)
    UINT16_T        reduce using rule 82 (init_var_rs -> literal SEMI .)
    WHILE           reduce using rule 82 (init_var_rs -> literal SEMI .)
    IF              reduce using rule 82 (init_var_rs -> literal SEMI .)
    ELSE            reduce using rule 82 (init_var_rs -> literal SEMI .)
    FOR             reduce using rule 82 (init_var_rs -> literal SEMI .)
    CONST           reduce using rule 82 (init_var_rs -> literal SEMI .)
    EXTERN          reduce using rule 82 (init_var_rs -> literal SEMI .)
    INLINE          reduce using rule 82 (init_var_rs -> literal SEMI .)
    LONG            reduce using rule 82 (init_var_rs -> literal SEMI .)
    SHORT           reduce using rule 82 (init_var_rs -> literal SEMI .)
    SIGNED          reduce using rule 82 (init_var_rs -> literal SEMI .)
    UNSIGNED        reduce using rule 82 (init_var_rs -> literal SEMI .)
    VOLATILE        reduce using rule 82 (init_var_rs -> literal SEMI .)
    $end            reduce using rule 82 (init_var_rs -> literal SEMI .)
    LPAREN          reduce using rule 82 (init_var_rs -> literal SEMI .)
    NEGATE          reduce using rule 82 (init_var_rs -> literal SEMI .)
    MINUS           reduce using rule 82 (init_var_rs -> literal SEMI .)
    STRING          reduce using rule 82 (init_var_rs -> literal SEMI .)
    NONDECIMAL      reduce using rule 82 (init_var_rs -> literal SEMI .)
    RBRACE          reduce using rule 82 (init_var_rs -> literal SEMI .)


state 77

    (83) init_var_rs -> ID SEMI .

    INCLUDE         reduce using rule 83 (init_var_rs -> ID SEMI .)
    ID              reduce using rule 83 (init_var_rs -> ID SEMI .)
    CHAR            reduce using rule 83 (init_var_rs -> ID SEMI .)
    DOUBLE          reduce using rule 83 (init_var_rs -> ID SEMI .)
    FLOAT           reduce using rule 83 (init_var_rs -> ID SEMI .)
    INT             reduce using rule 83 (init_var_rs -> ID SEMI .)
    VOID            reduce using rule 83 (init_var_rs -> ID SEMI .)
    UINT8_T         reduce using rule 83 (init_var_rs -> ID SEMI .)
    UINT16_T        reduce using rule 83 (init_var_rs -> ID SEMI .)
    WHILE           reduce using rule 83 (init_var_rs -> ID SEMI .)
    IF              reduce using rule 83 (init_var_rs -> ID SEMI .)
    ELSE            reduce using rule 83 (init_var_rs -> ID SEMI .)
    FOR             reduce using rule 83 (init_var_rs -> ID SEMI .)
    CONST           reduce using rule 83 (init_var_rs -> ID SEMI .)
    EXTERN          reduce using rule 83 (init_var_rs -> ID SEMI .)
    INLINE          reduce using rule 83 (init_var_rs -> ID SEMI .)
    LONG            reduce using rule 83 (init_var_rs -> ID SEMI .)
    SHORT           reduce using rule 83 (init_var_rs -> ID SEMI .)
    SIGNED          reduce using rule 83 (init_var_rs -> ID SEMI .)
    UNSIGNED        reduce using rule 83 (init_var_rs -> ID SEMI .)
    VOLATILE        reduce using rule 83 (init_var_rs -> ID SEMI .)
    $end            reduce using rule 83 (init_var_rs -> ID SEMI .)
    LPAREN          reduce using rule 83 (init_var_rs -> ID SEMI .)
    NEGATE          reduce using rule 83 (init_var_rs -> ID SEMI .)
    MINUS           reduce using rule 83 (init_var_rs -> ID SEMI .)
    STRING          reduce using rule 83 (init_var_rs -> ID SEMI .)
    NONDECIMAL      reduce using rule 83 (init_var_rs -> ID SEMI .)
    RBRACE          reduce using rule 83 (init_var_rs -> ID SEMI .)


state 78

    (84) init_var_rs -> LPAREN dtype . RPAREN literal SEMI
    (85) init_var_rs -> LPAREN dtype . RPAREN ID SEMI
    (22) dtype -> dtype . ASTERISK

    RPAREN          shift and go to state 118
    ASTERISK        shift and go to state 39


state 79

    (79) declare_var -> modifier dtype ID . SEMI
    (80) init_var_ls -> modifier dtype ID . assign
    (13) assign -> . SIMPLE_ASSIGN
    (14) assign -> . COMPLEX_ASSIGN

    SEMI            shift and go to state 119
    SIMPLE_ASSIGN   shift and go to state 43
    COMPLEX_ASSIGN  shift and go to state 44

    assign                         shift and go to state 120

state 80

    (47) for_loop -> FOR LPAREN init_var . conditional_expr SEMI ID INCREMENT RPAREN
    (43) conditional_expr -> . ID conditional expression
    (44) conditional_expr -> . expression conditional ID
    (45) conditional_expr -> . expression conditional expression
    (46) conditional_expr -> . ID conditional ID
    (64) expression -> . literal
    (65) expression -> . LPAREN expression RPAREN
    (66) expression -> . NEGATE expression
    (67) expression -> . MINUS expression
    (75) expression -> . expression binop ID
    (76) expression -> . ID binop expression
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    ID              shift and go to state 72
    LPAREN          shift and go to state 67
    NEGATE          shift and go to state 68
    MINUS           shift and go to state 69
    FLOAT           shift and go to state 53
    INT             shift and go to state 54
    CHAR            shift and go to state 55
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    conditional_expr               shift and go to state 121
    expression                     shift and go to state 73
    literal                        shift and go to state 66

state 81

    (80) init_var_ls -> modifier . dtype ID assign
    (15) dtype -> . CHAR
    (16) dtype -> . DOUBLE
    (17) dtype -> . FLOAT
    (18) dtype -> . INT
    (19) dtype -> . VOID
    (20) dtype -> . UINT8_T
    (21) dtype -> . UINT16_T
    (22) dtype -> . dtype ASTERISK

    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    VOID            shift and go to state 21
    UINT8_T         shift and go to state 22
    UINT16_T        shift and go to state 23

    dtype                          shift and go to state 122

state 82

    (81) init_var_ls -> dtype . ID assign
    (22) dtype -> dtype . ASTERISK

    ID              shift and go to state 123
    ASTERISK        shift and go to state 39


state 83

    (58) func_def -> dtype ID LPAREN func_arglist . RPAREN LBRACE node_list RBRACE
    (56) func_arglist -> func_arglist . func_arg
    (57) func_arglist -> func_arglist . func_arg COMMA
    (51) func_arg -> . ID
    (52) func_arg -> . expression
    (53) func_arg -> . dtype ID
    (54) func_arg -> . dtype
    (64) expression -> . literal
    (65) expression -> . LPAREN expression RPAREN
    (66) expression -> . NEGATE expression
    (67) expression -> . MINUS expression
    (75) expression -> . expression binop ID
    (76) expression -> . ID binop expression
    (15) dtype -> . CHAR
    (16) dtype -> . DOUBLE
    (17) dtype -> . FLOAT
    (18) dtype -> . INT
    (19) dtype -> . VOID
    (20) dtype -> . UINT8_T
    (21) dtype -> . UINT16_T
    (22) dtype -> . dtype ASTERISK
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    RPAREN          shift and go to state 124
    ID              shift and go to state 84
    LPAREN          shift and go to state 67
    NEGATE          shift and go to state 68
    MINUS           shift and go to state 69
    CHAR            shift and go to state 89
    DOUBLE          shift and go to state 18
    FLOAT           shift and go to state 90
    INT             shift and go to state 91
    VOID            shift and go to state 21
    UINT8_T         shift and go to state 22
    UINT16_T        shift and go to state 23
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    dtype                          shift and go to state 88
    func_arg                       shift and go to state 86
    expression                     shift and go to state 87
    literal                        shift and go to state 66

state 84

    (51) func_arg -> ID .
    (76) expression -> ID . binop expression
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           reduce using rule 51 (func_arg -> ID .)
    RPAREN          reduce using rule 51 (func_arg -> ID .)
    ID              reduce using rule 51 (func_arg -> ID .)
    LPAREN          reduce using rule 51 (func_arg -> ID .)
    NEGATE          reduce using rule 51 (func_arg -> ID .)
    CHAR            reduce using rule 51 (func_arg -> ID .)
    DOUBLE          reduce using rule 51 (func_arg -> ID .)
    FLOAT           reduce using rule 51 (func_arg -> ID .)
    INT             reduce using rule 51 (func_arg -> ID .)
    VOID            reduce using rule 51 (func_arg -> ID .)
    UINT8_T         reduce using rule 51 (func_arg -> ID .)
    UINT16_T        reduce using rule 51 (func_arg -> ID .)
    STRING          reduce using rule 51 (func_arg -> ID .)
    NONDECIMAL      reduce using rule 51 (func_arg -> ID .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

  ! MINUS           [ reduce using rule 51 (func_arg -> ID .) ]

    binop                          shift and go to state 92

state 85

    (59) func_call -> ID LPAREN func_arglist RPAREN . SEMI

    SEMI            shift and go to state 125


state 86

    (56) func_arglist -> func_arglist func_arg .
    (57) func_arglist -> func_arglist func_arg . COMMA

    RPAREN          reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    ID              reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    LPAREN          reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    NEGATE          reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    MINUS           reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    CHAR            reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    DOUBLE          reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    FLOAT           reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    INT             reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    VOID            reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    UINT8_T         reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    UINT16_T        reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    STRING          reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    NONDECIMAL      reduce using rule 56 (func_arglist -> func_arglist func_arg .)
    COMMA           shift and go to state 126


state 87

    (52) func_arg -> expression .
    (75) expression -> expression . binop ID
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           reduce using rule 52 (func_arg -> expression .)
    RPAREN          reduce using rule 52 (func_arg -> expression .)
    ID              reduce using rule 52 (func_arg -> expression .)
    LPAREN          reduce using rule 52 (func_arg -> expression .)
    NEGATE          reduce using rule 52 (func_arg -> expression .)
    CHAR            reduce using rule 52 (func_arg -> expression .)
    DOUBLE          reduce using rule 52 (func_arg -> expression .)
    FLOAT           reduce using rule 52 (func_arg -> expression .)
    INT             reduce using rule 52 (func_arg -> expression .)
    VOID            reduce using rule 52 (func_arg -> expression .)
    UINT8_T         reduce using rule 52 (func_arg -> expression .)
    UINT16_T        reduce using rule 52 (func_arg -> expression .)
    STRING          reduce using rule 52 (func_arg -> expression .)
    NONDECIMAL      reduce using rule 52 (func_arg -> expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

  ! MINUS           [ reduce using rule 52 (func_arg -> expression .) ]

    binop                          shift and go to state 101

state 88

    (53) func_arg -> dtype . ID
    (54) func_arg -> dtype .
    (22) dtype -> dtype . ASTERISK

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 127
    COMMA           reduce using rule 54 (func_arg -> dtype .)
    RPAREN          reduce using rule 54 (func_arg -> dtype .)
    LPAREN          reduce using rule 54 (func_arg -> dtype .)
    NEGATE          reduce using rule 54 (func_arg -> dtype .)
    MINUS           reduce using rule 54 (func_arg -> dtype .)
    CHAR            reduce using rule 54 (func_arg -> dtype .)
    DOUBLE          reduce using rule 54 (func_arg -> dtype .)
    FLOAT           reduce using rule 54 (func_arg -> dtype .)
    INT             reduce using rule 54 (func_arg -> dtype .)
    VOID            reduce using rule 54 (func_arg -> dtype .)
    UINT8_T         reduce using rule 54 (func_arg -> dtype .)
    UINT16_T        reduce using rule 54 (func_arg -> dtype .)
    STRING          reduce using rule 54 (func_arg -> dtype .)
    NONDECIMAL      reduce using rule 54 (func_arg -> dtype .)
    ASTERISK        shift and go to state 39

  ! ID              [ reduce using rule 54 (func_arg -> dtype .) ]


state 89

    (15) dtype -> CHAR .
    (10) literal -> CHAR .

  ! reduce/reduce conflict for MINUS resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for ASTERISK resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for COMMA resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for RPAREN resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for ID resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for LPAREN resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for NEGATE resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for CHAR resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for FLOAT resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for INT resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for VOID resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for UINT8_T resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for UINT16_T resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for STRING resolved using rule 10 (literal -> CHAR .)
  ! reduce/reduce conflict for NONDECIMAL resolved using rule 10 (literal -> CHAR .)
    PLUS            reduce using rule 10 (literal -> CHAR .)
    MINUS           reduce using rule 10 (literal -> CHAR .)
    ASTERISK        reduce using rule 10 (literal -> CHAR .)
    DIVIDE          reduce using rule 10 (literal -> CHAR .)
    LSHIFT          reduce using rule 10 (literal -> CHAR .)
    RSHIFT          reduce using rule 10 (literal -> CHAR .)
    PERCENT         reduce using rule 10 (literal -> CHAR .)
    COMMA           reduce using rule 10 (literal -> CHAR .)
    RPAREN          reduce using rule 10 (literal -> CHAR .)
    ID              reduce using rule 10 (literal -> CHAR .)
    LPAREN          reduce using rule 10 (literal -> CHAR .)
    NEGATE          reduce using rule 10 (literal -> CHAR .)
    CHAR            reduce using rule 10 (literal -> CHAR .)
    DOUBLE          reduce using rule 10 (literal -> CHAR .)
    FLOAT           reduce using rule 10 (literal -> CHAR .)
    INT             reduce using rule 10 (literal -> CHAR .)
    VOID            reduce using rule 10 (literal -> CHAR .)
    UINT8_T         reduce using rule 10 (literal -> CHAR .)
    UINT16_T        reduce using rule 10 (literal -> CHAR .)
    STRING          reduce using rule 10 (literal -> CHAR .)
    NONDECIMAL      reduce using rule 10 (literal -> CHAR .)

  ! ID              [ reduce using rule 15 (dtype -> CHAR .) ]
  ! ASTERISK        [ reduce using rule 15 (dtype -> CHAR .) ]
  ! COMMA           [ reduce using rule 15 (dtype -> CHAR .) ]
  ! RPAREN          [ reduce using rule 15 (dtype -> CHAR .) ]
  ! LPAREN          [ reduce using rule 15 (dtype -> CHAR .) ]
  ! NEGATE          [ reduce using rule 15 (dtype -> CHAR .) ]
  ! MINUS           [ reduce using rule 15 (dtype -> CHAR .) ]
  ! CHAR            [ reduce using rule 15 (dtype -> CHAR .) ]
  ! DOUBLE          [ reduce using rule 15 (dtype -> CHAR .) ]
  ! FLOAT           [ reduce using rule 15 (dtype -> CHAR .) ]
  ! INT             [ reduce using rule 15 (dtype -> CHAR .) ]
  ! VOID            [ reduce using rule 15 (dtype -> CHAR .) ]
  ! UINT8_T         [ reduce using rule 15 (dtype -> CHAR .) ]
  ! UINT16_T        [ reduce using rule 15 (dtype -> CHAR .) ]
  ! STRING          [ reduce using rule 15 (dtype -> CHAR .) ]
  ! NONDECIMAL      [ reduce using rule 15 (dtype -> CHAR .) ]


state 90

    (17) dtype -> FLOAT .
    (8) literal -> FLOAT .

  ! reduce/reduce conflict for MINUS resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for ASTERISK resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for COMMA resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for ID resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for LPAREN resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for NEGATE resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for CHAR resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for INT resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for VOID resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for UINT8_T resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for UINT16_T resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for STRING resolved using rule 8 (literal -> FLOAT .)
  ! reduce/reduce conflict for NONDECIMAL resolved using rule 8 (literal -> FLOAT .)
    PLUS            reduce using rule 8 (literal -> FLOAT .)
    MINUS           reduce using rule 8 (literal -> FLOAT .)
    ASTERISK        reduce using rule 8 (literal -> FLOAT .)
    DIVIDE          reduce using rule 8 (literal -> FLOAT .)
    LSHIFT          reduce using rule 8 (literal -> FLOAT .)
    RSHIFT          reduce using rule 8 (literal -> FLOAT .)
    PERCENT         reduce using rule 8 (literal -> FLOAT .)
    COMMA           reduce using rule 8 (literal -> FLOAT .)
    RPAREN          reduce using rule 8 (literal -> FLOAT .)
    ID              reduce using rule 8 (literal -> FLOAT .)
    LPAREN          reduce using rule 8 (literal -> FLOAT .)
    NEGATE          reduce using rule 8 (literal -> FLOAT .)
    CHAR            reduce using rule 8 (literal -> FLOAT .)
    DOUBLE          reduce using rule 8 (literal -> FLOAT .)
    FLOAT           reduce using rule 8 (literal -> FLOAT .)
    INT             reduce using rule 8 (literal -> FLOAT .)
    VOID            reduce using rule 8 (literal -> FLOAT .)
    UINT8_T         reduce using rule 8 (literal -> FLOAT .)
    UINT16_T        reduce using rule 8 (literal -> FLOAT .)
    STRING          reduce using rule 8 (literal -> FLOAT .)
    NONDECIMAL      reduce using rule 8 (literal -> FLOAT .)

  ! ID              [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! ASTERISK        [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! COMMA           [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! RPAREN          [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! LPAREN          [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! NEGATE          [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! MINUS           [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! CHAR            [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! DOUBLE          [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! FLOAT           [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! INT             [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! VOID            [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! UINT8_T         [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! UINT16_T        [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! STRING          [ reduce using rule 17 (dtype -> FLOAT .) ]
  ! NONDECIMAL      [ reduce using rule 17 (dtype -> FLOAT .) ]


state 91

    (18) dtype -> INT .
    (9) literal -> INT .

  ! reduce/reduce conflict for MINUS resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for ASTERISK resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for COMMA resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for ID resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for LPAREN resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for NEGATE resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for CHAR resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for INT resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for VOID resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for UINT8_T resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for UINT16_T resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for STRING resolved using rule 9 (literal -> INT .)
  ! reduce/reduce conflict for NONDECIMAL resolved using rule 9 (literal -> INT .)
    PLUS            reduce using rule 9 (literal -> INT .)
    MINUS           reduce using rule 9 (literal -> INT .)
    ASTERISK        reduce using rule 9 (literal -> INT .)
    DIVIDE          reduce using rule 9 (literal -> INT .)
    LSHIFT          reduce using rule 9 (literal -> INT .)
    RSHIFT          reduce using rule 9 (literal -> INT .)
    PERCENT         reduce using rule 9 (literal -> INT .)
    COMMA           reduce using rule 9 (literal -> INT .)
    RPAREN          reduce using rule 9 (literal -> INT .)
    ID              reduce using rule 9 (literal -> INT .)
    LPAREN          reduce using rule 9 (literal -> INT .)
    NEGATE          reduce using rule 9 (literal -> INT .)
    CHAR            reduce using rule 9 (literal -> INT .)
    DOUBLE          reduce using rule 9 (literal -> INT .)
    FLOAT           reduce using rule 9 (literal -> INT .)
    INT             reduce using rule 9 (literal -> INT .)
    VOID            reduce using rule 9 (literal -> INT .)
    UINT8_T         reduce using rule 9 (literal -> INT .)
    UINT16_T        reduce using rule 9 (literal -> INT .)
    STRING          reduce using rule 9 (literal -> INT .)
    NONDECIMAL      reduce using rule 9 (literal -> INT .)

  ! ID              [ reduce using rule 18 (dtype -> INT .) ]
  ! ASTERISK        [ reduce using rule 18 (dtype -> INT .) ]
  ! COMMA           [ reduce using rule 18 (dtype -> INT .) ]
  ! RPAREN          [ reduce using rule 18 (dtype -> INT .) ]
  ! LPAREN          [ reduce using rule 18 (dtype -> INT .) ]
  ! NEGATE          [ reduce using rule 18 (dtype -> INT .) ]
  ! MINUS           [ reduce using rule 18 (dtype -> INT .) ]
  ! CHAR            [ reduce using rule 18 (dtype -> INT .) ]
  ! DOUBLE          [ reduce using rule 18 (dtype -> INT .) ]
  ! FLOAT           [ reduce using rule 18 (dtype -> INT .) ]
  ! INT             [ reduce using rule 18 (dtype -> INT .) ]
  ! VOID            [ reduce using rule 18 (dtype -> INT .) ]
  ! UINT8_T         [ reduce using rule 18 (dtype -> INT .) ]
  ! UINT16_T        [ reduce using rule 18 (dtype -> INT .) ]
  ! STRING          [ reduce using rule 18 (dtype -> INT .) ]
  ! NONDECIMAL      [ reduce using rule 18 (dtype -> INT .) ]


state 92

    (76) expression -> ID binop . expression
    (64) expression -> . literal
    (65) expression -> . LPAREN expression RPAREN
    (66) expression -> . NEGATE expression
    (67) expression -> . MINUS expression
    (75) expression -> . expression binop ID
    (76) expression -> . ID binop expression
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    LPAREN          shift and go to state 67
    NEGATE          shift and go to state 68
    MINUS           shift and go to state 69
    ID              shift and go to state 64
    FLOAT           shift and go to state 53
    INT             shift and go to state 54
    CHAR            shift and go to state 55
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    expression                     shift and go to state 128
    literal                        shift and go to state 66

state 93

    (68) binop -> PLUS .

    LPAREN          reduce using rule 68 (binop -> PLUS .)
    NEGATE          reduce using rule 68 (binop -> PLUS .)
    MINUS           reduce using rule 68 (binop -> PLUS .)
    ID              reduce using rule 68 (binop -> PLUS .)
    FLOAT           reduce using rule 68 (binop -> PLUS .)
    INT             reduce using rule 68 (binop -> PLUS .)
    CHAR            reduce using rule 68 (binop -> PLUS .)
    STRING          reduce using rule 68 (binop -> PLUS .)
    NONDECIMAL      reduce using rule 68 (binop -> PLUS .)


state 94

    (69) binop -> MINUS .

    LPAREN          reduce using rule 69 (binop -> MINUS .)
    NEGATE          reduce using rule 69 (binop -> MINUS .)
    MINUS           reduce using rule 69 (binop -> MINUS .)
    ID              reduce using rule 69 (binop -> MINUS .)
    FLOAT           reduce using rule 69 (binop -> MINUS .)
    INT             reduce using rule 69 (binop -> MINUS .)
    CHAR            reduce using rule 69 (binop -> MINUS .)
    STRING          reduce using rule 69 (binop -> MINUS .)
    NONDECIMAL      reduce using rule 69 (binop -> MINUS .)


state 95

    (70) binop -> ASTERISK .

    LPAREN          reduce using rule 70 (binop -> ASTERISK .)
    NEGATE          reduce using rule 70 (binop -> ASTERISK .)
    MINUS           reduce using rule 70 (binop -> ASTERISK .)
    ID              reduce using rule 70 (binop -> ASTERISK .)
    FLOAT           reduce using rule 70 (binop -> ASTERISK .)
    INT             reduce using rule 70 (binop -> ASTERISK .)
    CHAR            reduce using rule 70 (binop -> ASTERISK .)
    STRING          reduce using rule 70 (binop -> ASTERISK .)
    NONDECIMAL      reduce using rule 70 (binop -> ASTERISK .)


state 96

    (71) binop -> DIVIDE .

    LPAREN          reduce using rule 71 (binop -> DIVIDE .)
    NEGATE          reduce using rule 71 (binop -> DIVIDE .)
    MINUS           reduce using rule 71 (binop -> DIVIDE .)
    ID              reduce using rule 71 (binop -> DIVIDE .)
    FLOAT           reduce using rule 71 (binop -> DIVIDE .)
    INT             reduce using rule 71 (binop -> DIVIDE .)
    CHAR            reduce using rule 71 (binop -> DIVIDE .)
    STRING          reduce using rule 71 (binop -> DIVIDE .)
    NONDECIMAL      reduce using rule 71 (binop -> DIVIDE .)


state 97

    (72) binop -> LSHIFT .

    LPAREN          reduce using rule 72 (binop -> LSHIFT .)
    NEGATE          reduce using rule 72 (binop -> LSHIFT .)
    MINUS           reduce using rule 72 (binop -> LSHIFT .)
    ID              reduce using rule 72 (binop -> LSHIFT .)
    FLOAT           reduce using rule 72 (binop -> LSHIFT .)
    INT             reduce using rule 72 (binop -> LSHIFT .)
    CHAR            reduce using rule 72 (binop -> LSHIFT .)
    STRING          reduce using rule 72 (binop -> LSHIFT .)
    NONDECIMAL      reduce using rule 72 (binop -> LSHIFT .)


state 98

    (73) binop -> RSHIFT .

    LPAREN          reduce using rule 73 (binop -> RSHIFT .)
    NEGATE          reduce using rule 73 (binop -> RSHIFT .)
    MINUS           reduce using rule 73 (binop -> RSHIFT .)
    ID              reduce using rule 73 (binop -> RSHIFT .)
    FLOAT           reduce using rule 73 (binop -> RSHIFT .)
    INT             reduce using rule 73 (binop -> RSHIFT .)
    CHAR            reduce using rule 73 (binop -> RSHIFT .)
    STRING          reduce using rule 73 (binop -> RSHIFT .)
    NONDECIMAL      reduce using rule 73 (binop -> RSHIFT .)


state 99

    (74) binop -> PERCENT .

    LPAREN          reduce using rule 74 (binop -> PERCENT .)
    NEGATE          reduce using rule 74 (binop -> PERCENT .)
    MINUS           reduce using rule 74 (binop -> PERCENT .)
    ID              reduce using rule 74 (binop -> PERCENT .)
    FLOAT           reduce using rule 74 (binop -> PERCENT .)
    INT             reduce using rule 74 (binop -> PERCENT .)
    CHAR            reduce using rule 74 (binop -> PERCENT .)
    STRING          reduce using rule 74 (binop -> PERCENT .)
    NONDECIMAL      reduce using rule 74 (binop -> PERCENT .)


state 100

    (88) assign_var -> ID assign expression SEMI .

    INCLUDE         reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    ID              reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    CHAR            reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    DOUBLE          reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    FLOAT           reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    INT             reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    VOID            reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    UINT8_T         reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    UINT16_T        reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    WHILE           reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    IF              reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    ELSE            reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    FOR             reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    CONST           reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    EXTERN          reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    INLINE          reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    LONG            reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    SHORT           reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    SIGNED          reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    UNSIGNED        reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    VOLATILE        reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    $end            reduce using rule 88 (assign_var -> ID assign expression SEMI .)
    RBRACE          reduce using rule 88 (assign_var -> ID assign expression SEMI .)


state 101

    (75) expression -> expression binop . ID

    ID              shift and go to state 129


state 102

    (65) expression -> LPAREN expression . RPAREN
    (75) expression -> expression . binop ID
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

    RPAREN          shift and go to state 130
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

    binop                          shift and go to state 101

state 103

    (66) expression -> NEGATE expression .
    (75) expression -> expression . binop ID
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
    SEMI            reduce using rule 66 (expression -> NEGATE expression .)
    EQ              reduce using rule 66 (expression -> NEGATE expression .)
    NEQ             reduce using rule 66 (expression -> NEGATE expression .)
    LT              reduce using rule 66 (expression -> NEGATE expression .)
    GT              reduce using rule 66 (expression -> NEGATE expression .)
    LE              reduce using rule 66 (expression -> NEGATE expression .)
    GE              reduce using rule 66 (expression -> NEGATE expression .)
    AND             reduce using rule 66 (expression -> NEGATE expression .)
    OR              reduce using rule 66 (expression -> NEGATE expression .)
    COMMA           reduce using rule 66 (expression -> NEGATE expression .)
    RPAREN          reduce using rule 66 (expression -> NEGATE expression .)
    ID              reduce using rule 66 (expression -> NEGATE expression .)
    LPAREN          reduce using rule 66 (expression -> NEGATE expression .)
    NEGATE          reduce using rule 66 (expression -> NEGATE expression .)
    CHAR            reduce using rule 66 (expression -> NEGATE expression .)
    DOUBLE          reduce using rule 66 (expression -> NEGATE expression .)
    FLOAT           reduce using rule 66 (expression -> NEGATE expression .)
    INT             reduce using rule 66 (expression -> NEGATE expression .)
    VOID            reduce using rule 66 (expression -> NEGATE expression .)
    UINT8_T         reduce using rule 66 (expression -> NEGATE expression .)
    UINT16_T        reduce using rule 66 (expression -> NEGATE expression .)
    STRING          reduce using rule 66 (expression -> NEGATE expression .)
    NONDECIMAL      reduce using rule 66 (expression -> NEGATE expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

  ! PLUS            [ reduce using rule 66 (expression -> NEGATE expression .) ]
  ! MINUS           [ reduce using rule 66 (expression -> NEGATE expression .) ]
  ! ASTERISK        [ reduce using rule 66 (expression -> NEGATE expression .) ]
  ! DIVIDE          [ reduce using rule 66 (expression -> NEGATE expression .) ]
  ! LSHIFT          [ reduce using rule 66 (expression -> NEGATE expression .) ]
  ! RSHIFT          [ reduce using rule 66 (expression -> NEGATE expression .) ]
  ! PERCENT         [ reduce using rule 66 (expression -> NEGATE expression .) ]

    binop                          shift and go to state 101

state 104

    (67) expression -> MINUS expression .
    (75) expression -> expression . binop ID
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
    SEMI            reduce using rule 67 (expression -> MINUS expression .)
    EQ              reduce using rule 67 (expression -> MINUS expression .)
    NEQ             reduce using rule 67 (expression -> MINUS expression .)
    LT              reduce using rule 67 (expression -> MINUS expression .)
    GT              reduce using rule 67 (expression -> MINUS expression .)
    LE              reduce using rule 67 (expression -> MINUS expression .)
    GE              reduce using rule 67 (expression -> MINUS expression .)
    AND             reduce using rule 67 (expression -> MINUS expression .)
    OR              reduce using rule 67 (expression -> MINUS expression .)
    COMMA           reduce using rule 67 (expression -> MINUS expression .)
    RPAREN          reduce using rule 67 (expression -> MINUS expression .)
    ID              reduce using rule 67 (expression -> MINUS expression .)
    LPAREN          reduce using rule 67 (expression -> MINUS expression .)
    NEGATE          reduce using rule 67 (expression -> MINUS expression .)
    CHAR            reduce using rule 67 (expression -> MINUS expression .)
    DOUBLE          reduce using rule 67 (expression -> MINUS expression .)
    FLOAT           reduce using rule 67 (expression -> MINUS expression .)
    INT             reduce using rule 67 (expression -> MINUS expression .)
    VOID            reduce using rule 67 (expression -> MINUS expression .)
    UINT8_T         reduce using rule 67 (expression -> MINUS expression .)
    UINT16_T        reduce using rule 67 (expression -> MINUS expression .)
    STRING          reduce using rule 67 (expression -> MINUS expression .)
    NONDECIMAL      reduce using rule 67 (expression -> MINUS expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

  ! PLUS            [ reduce using rule 67 (expression -> MINUS expression .) ]
  ! MINUS           [ reduce using rule 67 (expression -> MINUS expression .) ]
  ! ASTERISK        [ reduce using rule 67 (expression -> MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 67 (expression -> MINUS expression .) ]
  ! LSHIFT          [ reduce using rule 67 (expression -> MINUS expression .) ]
  ! RSHIFT          [ reduce using rule 67 (expression -> MINUS expression .) ]
  ! PERCENT         [ reduce using rule 67 (expression -> MINUS expression .) ]

    binop                          shift and go to state 101

state 105

    (48) control_expr -> control LPAREN conditional_expr RPAREN . LBRACE node_list RBRACE

    LBRACE          shift and go to state 131


state 106

    (43) conditional_expr -> ID conditional . expression
    (46) conditional_expr -> ID conditional . ID
    (64) expression -> . literal
    (65) expression -> . LPAREN expression RPAREN
    (66) expression -> . NEGATE expression
    (67) expression -> . MINUS expression
    (75) expression -> . expression binop ID
    (76) expression -> . ID binop expression
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    ID              shift and go to state 132
    LPAREN          shift and go to state 67
    NEGATE          shift and go to state 68
    MINUS           shift and go to state 69
    FLOAT           shift and go to state 53
    INT             shift and go to state 54
    CHAR            shift and go to state 55
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    expression                     shift and go to state 133
    literal                        shift and go to state 66

state 107

    (35) conditional -> EQ .

    ID              reduce using rule 35 (conditional -> EQ .)
    LPAREN          reduce using rule 35 (conditional -> EQ .)
    NEGATE          reduce using rule 35 (conditional -> EQ .)
    MINUS           reduce using rule 35 (conditional -> EQ .)
    FLOAT           reduce using rule 35 (conditional -> EQ .)
    INT             reduce using rule 35 (conditional -> EQ .)
    CHAR            reduce using rule 35 (conditional -> EQ .)
    STRING          reduce using rule 35 (conditional -> EQ .)
    NONDECIMAL      reduce using rule 35 (conditional -> EQ .)


state 108

    (36) conditional -> NEQ .

    ID              reduce using rule 36 (conditional -> NEQ .)
    LPAREN          reduce using rule 36 (conditional -> NEQ .)
    NEGATE          reduce using rule 36 (conditional -> NEQ .)
    MINUS           reduce using rule 36 (conditional -> NEQ .)
    FLOAT           reduce using rule 36 (conditional -> NEQ .)
    INT             reduce using rule 36 (conditional -> NEQ .)
    CHAR            reduce using rule 36 (conditional -> NEQ .)
    STRING          reduce using rule 36 (conditional -> NEQ .)
    NONDECIMAL      reduce using rule 36 (conditional -> NEQ .)


state 109

    (37) conditional -> LT .

    ID              reduce using rule 37 (conditional -> LT .)
    LPAREN          reduce using rule 37 (conditional -> LT .)
    NEGATE          reduce using rule 37 (conditional -> LT .)
    MINUS           reduce using rule 37 (conditional -> LT .)
    FLOAT           reduce using rule 37 (conditional -> LT .)
    INT             reduce using rule 37 (conditional -> LT .)
    CHAR            reduce using rule 37 (conditional -> LT .)
    STRING          reduce using rule 37 (conditional -> LT .)
    NONDECIMAL      reduce using rule 37 (conditional -> LT .)


state 110

    (38) conditional -> GT .

    ID              reduce using rule 38 (conditional -> GT .)
    LPAREN          reduce using rule 38 (conditional -> GT .)
    NEGATE          reduce using rule 38 (conditional -> GT .)
    MINUS           reduce using rule 38 (conditional -> GT .)
    FLOAT           reduce using rule 38 (conditional -> GT .)
    INT             reduce using rule 38 (conditional -> GT .)
    CHAR            reduce using rule 38 (conditional -> GT .)
    STRING          reduce using rule 38 (conditional -> GT .)
    NONDECIMAL      reduce using rule 38 (conditional -> GT .)


state 111

    (39) conditional -> LE .

    ID              reduce using rule 39 (conditional -> LE .)
    LPAREN          reduce using rule 39 (conditional -> LE .)
    NEGATE          reduce using rule 39 (conditional -> LE .)
    MINUS           reduce using rule 39 (conditional -> LE .)
    FLOAT           reduce using rule 39 (conditional -> LE .)
    INT             reduce using rule 39 (conditional -> LE .)
    CHAR            reduce using rule 39 (conditional -> LE .)
    STRING          reduce using rule 39 (conditional -> LE .)
    NONDECIMAL      reduce using rule 39 (conditional -> LE .)


state 112

    (40) conditional -> GE .

    ID              reduce using rule 40 (conditional -> GE .)
    LPAREN          reduce using rule 40 (conditional -> GE .)
    NEGATE          reduce using rule 40 (conditional -> GE .)
    MINUS           reduce using rule 40 (conditional -> GE .)
    FLOAT           reduce using rule 40 (conditional -> GE .)
    INT             reduce using rule 40 (conditional -> GE .)
    CHAR            reduce using rule 40 (conditional -> GE .)
    STRING          reduce using rule 40 (conditional -> GE .)
    NONDECIMAL      reduce using rule 40 (conditional -> GE .)


state 113

    (41) conditional -> AND .

    ID              reduce using rule 41 (conditional -> AND .)
    LPAREN          reduce using rule 41 (conditional -> AND .)
    NEGATE          reduce using rule 41 (conditional -> AND .)
    MINUS           reduce using rule 41 (conditional -> AND .)
    FLOAT           reduce using rule 41 (conditional -> AND .)
    INT             reduce using rule 41 (conditional -> AND .)
    CHAR            reduce using rule 41 (conditional -> AND .)
    STRING          reduce using rule 41 (conditional -> AND .)
    NONDECIMAL      reduce using rule 41 (conditional -> AND .)


state 114

    (42) conditional -> OR .

    ID              reduce using rule 42 (conditional -> OR .)
    LPAREN          reduce using rule 42 (conditional -> OR .)
    NEGATE          reduce using rule 42 (conditional -> OR .)
    MINUS           reduce using rule 42 (conditional -> OR .)
    FLOAT           reduce using rule 42 (conditional -> OR .)
    INT             reduce using rule 42 (conditional -> OR .)
    CHAR            reduce using rule 42 (conditional -> OR .)
    STRING          reduce using rule 42 (conditional -> OR .)
    NONDECIMAL      reduce using rule 42 (conditional -> OR .)


state 115

    (44) conditional_expr -> expression conditional . ID
    (45) conditional_expr -> expression conditional . expression
    (64) expression -> . literal
    (65) expression -> . LPAREN expression RPAREN
    (66) expression -> . NEGATE expression
    (67) expression -> . MINUS expression
    (75) expression -> . expression binop ID
    (76) expression -> . ID binop expression
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    ID              shift and go to state 135
    LPAREN          shift and go to state 67
    NEGATE          shift and go to state 68
    MINUS           shift and go to state 69
    FLOAT           shift and go to state 53
    INT             shift and go to state 54
    CHAR            shift and go to state 55
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    expression                     shift and go to state 134
    literal                        shift and go to state 66

state 116

    (49) control_expr -> control LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    ID              reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    CHAR            reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    INT             reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    VOID            reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    WHILE           reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    IF              reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    ELSE            reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    FOR             reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    CONST           reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    INLINE          reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    LONG            reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    SHORT           reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    $end            reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 49 (control_expr -> control LBRACE node_list RBRACE .)


state 117

    (50) control_expr -> for_loop LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    ID              reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    CHAR            reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    INT             reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    VOID            reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    WHILE           reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    IF              reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    ELSE            reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    FOR             reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    CONST           reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    INLINE          reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    LONG            reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    SHORT           reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    $end            reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 50 (control_expr -> for_loop LBRACE node_list RBRACE .)


state 118

    (84) init_var_rs -> LPAREN dtype RPAREN . literal SEMI
    (85) init_var_rs -> LPAREN dtype RPAREN . ID SEMI
    (8) literal -> . FLOAT
    (9) literal -> . INT
    (10) literal -> . CHAR
    (11) literal -> . STRING
    (12) literal -> . NONDECIMAL

    ID              shift and go to state 137
    FLOAT           shift and go to state 53
    INT             shift and go to state 54
    CHAR            shift and go to state 55
    STRING          shift and go to state 56
    NONDECIMAL      shift and go to state 57

    literal                        shift and go to state 136

state 119

    (79) declare_var -> modifier dtype ID SEMI .

    INCLUDE         reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    ID              reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    CHAR            reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    DOUBLE          reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    FLOAT           reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    INT             reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    VOID            reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    UINT8_T         reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    UINT16_T        reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    WHILE           reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    IF              reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    ELSE            reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    FOR             reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    CONST           reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    EXTERN          reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    INLINE          reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    LONG            reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    SHORT           reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    SIGNED          reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    UNSIGNED        reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    VOLATILE        reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    $end            reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)
    RBRACE          reduce using rule 79 (declare_var -> modifier dtype ID SEMI .)


state 120

    (80) init_var_ls -> modifier dtype ID assign .

    ID              reduce using rule 80 (init_var_ls -> modifier dtype ID assign .)
    LPAREN          reduce using rule 80 (init_var_ls -> modifier dtype ID assign .)
    FLOAT           reduce using rule 80 (init_var_ls -> modifier dtype ID assign .)
    INT             reduce using rule 80 (init_var_ls -> modifier dtype ID assign .)
    CHAR            reduce using rule 80 (init_var_ls -> modifier dtype ID assign .)
    STRING          reduce using rule 80 (init_var_ls -> modifier dtype ID assign .)
    NONDECIMAL      reduce using rule 80 (init_var_ls -> modifier dtype ID assign .)


state 121

    (47) for_loop -> FOR LPAREN init_var conditional_expr . SEMI ID INCREMENT RPAREN

    SEMI            shift and go to state 138


state 122

    (80) init_var_ls -> modifier dtype . ID assign
    (22) dtype -> dtype . ASTERISK

    ID              shift and go to state 139
    ASTERISK        shift and go to state 39


state 123

    (81) init_var_ls -> dtype ID . assign
    (13) assign -> . SIMPLE_ASSIGN
    (14) assign -> . COMPLEX_ASSIGN

    SIMPLE_ASSIGN   shift and go to state 43
    COMPLEX_ASSIGN  shift and go to state 44

    assign                         shift and go to state 62

state 124

    (58) func_def -> dtype ID LPAREN func_arglist RPAREN . LBRACE node_list RBRACE

    LBRACE          shift and go to state 140


state 125

    (59) func_call -> ID LPAREN func_arglist RPAREN SEMI .

    INCLUDE         reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    ID              reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    CHAR            reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    DOUBLE          reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    FLOAT           reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    INT             reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    VOID            reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    UINT8_T         reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    UINT16_T        reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    WHILE           reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    IF              reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    ELSE            reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    FOR             reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    CONST           reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    EXTERN          reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    INLINE          reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    LONG            reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    SHORT           reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    SIGNED          reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    UNSIGNED        reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    VOLATILE        reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    $end            reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    LPAREN          reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    NEGATE          reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    MINUS           reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    STRING          reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    NONDECIMAL      reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)
    RBRACE          reduce using rule 59 (func_call -> ID LPAREN func_arglist RPAREN SEMI .)


state 126

    (57) func_arglist -> func_arglist func_arg COMMA .

    RPAREN          reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    ID              reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    LPAREN          reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    NEGATE          reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    MINUS           reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    CHAR            reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    DOUBLE          reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    FLOAT           reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    INT             reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    VOID            reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    UINT8_T         reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    UINT16_T        reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    STRING          reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)
    NONDECIMAL      reduce using rule 57 (func_arglist -> func_arglist func_arg COMMA .)


state 127

    (53) func_arg -> dtype ID .

    COMMA           reduce using rule 53 (func_arg -> dtype ID .)
    RPAREN          reduce using rule 53 (func_arg -> dtype ID .)
    ID              reduce using rule 53 (func_arg -> dtype ID .)
    LPAREN          reduce using rule 53 (func_arg -> dtype ID .)
    NEGATE          reduce using rule 53 (func_arg -> dtype ID .)
    MINUS           reduce using rule 53 (func_arg -> dtype ID .)
    CHAR            reduce using rule 53 (func_arg -> dtype ID .)
    DOUBLE          reduce using rule 53 (func_arg -> dtype ID .)
    FLOAT           reduce using rule 53 (func_arg -> dtype ID .)
    INT             reduce using rule 53 (func_arg -> dtype ID .)
    VOID            reduce using rule 53 (func_arg -> dtype ID .)
    UINT8_T         reduce using rule 53 (func_arg -> dtype ID .)
    UINT16_T        reduce using rule 53 (func_arg -> dtype ID .)
    STRING          reduce using rule 53 (func_arg -> dtype ID .)
    NONDECIMAL      reduce using rule 53 (func_arg -> dtype ID .)


state 128

    (76) expression -> ID binop expression .
    (75) expression -> expression . binop ID
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for PERCENT resolved as shift
    SEMI            reduce using rule 76 (expression -> ID binop expression .)
    EQ              reduce using rule 76 (expression -> ID binop expression .)
    NEQ             reduce using rule 76 (expression -> ID binop expression .)
    LT              reduce using rule 76 (expression -> ID binop expression .)
    GT              reduce using rule 76 (expression -> ID binop expression .)
    LE              reduce using rule 76 (expression -> ID binop expression .)
    GE              reduce using rule 76 (expression -> ID binop expression .)
    AND             reduce using rule 76 (expression -> ID binop expression .)
    OR              reduce using rule 76 (expression -> ID binop expression .)
    COMMA           reduce using rule 76 (expression -> ID binop expression .)
    RPAREN          reduce using rule 76 (expression -> ID binop expression .)
    ID              reduce using rule 76 (expression -> ID binop expression .)
    LPAREN          reduce using rule 76 (expression -> ID binop expression .)
    NEGATE          reduce using rule 76 (expression -> ID binop expression .)
    CHAR            reduce using rule 76 (expression -> ID binop expression .)
    DOUBLE          reduce using rule 76 (expression -> ID binop expression .)
    FLOAT           reduce using rule 76 (expression -> ID binop expression .)
    INT             reduce using rule 76 (expression -> ID binop expression .)
    VOID            reduce using rule 76 (expression -> ID binop expression .)
    UINT8_T         reduce using rule 76 (expression -> ID binop expression .)
    UINT16_T        reduce using rule 76 (expression -> ID binop expression .)
    STRING          reduce using rule 76 (expression -> ID binop expression .)
    NONDECIMAL      reduce using rule 76 (expression -> ID binop expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

  ! PLUS            [ reduce using rule 76 (expression -> ID binop expression .) ]
  ! MINUS           [ reduce using rule 76 (expression -> ID binop expression .) ]
  ! ASTERISK        [ reduce using rule 76 (expression -> ID binop expression .) ]
  ! DIVIDE          [ reduce using rule 76 (expression -> ID binop expression .) ]
  ! LSHIFT          [ reduce using rule 76 (expression -> ID binop expression .) ]
  ! RSHIFT          [ reduce using rule 76 (expression -> ID binop expression .) ]
  ! PERCENT         [ reduce using rule 76 (expression -> ID binop expression .) ]

    binop                          shift and go to state 101

state 129

    (75) expression -> expression binop ID .

    SEMI            reduce using rule 75 (expression -> expression binop ID .)
    PLUS            reduce using rule 75 (expression -> expression binop ID .)
    MINUS           reduce using rule 75 (expression -> expression binop ID .)
    ASTERISK        reduce using rule 75 (expression -> expression binop ID .)
    DIVIDE          reduce using rule 75 (expression -> expression binop ID .)
    LSHIFT          reduce using rule 75 (expression -> expression binop ID .)
    RSHIFT          reduce using rule 75 (expression -> expression binop ID .)
    PERCENT         reduce using rule 75 (expression -> expression binop ID .)
    EQ              reduce using rule 75 (expression -> expression binop ID .)
    NEQ             reduce using rule 75 (expression -> expression binop ID .)
    LT              reduce using rule 75 (expression -> expression binop ID .)
    GT              reduce using rule 75 (expression -> expression binop ID .)
    LE              reduce using rule 75 (expression -> expression binop ID .)
    GE              reduce using rule 75 (expression -> expression binop ID .)
    AND             reduce using rule 75 (expression -> expression binop ID .)
    OR              reduce using rule 75 (expression -> expression binop ID .)
    COMMA           reduce using rule 75 (expression -> expression binop ID .)
    RPAREN          reduce using rule 75 (expression -> expression binop ID .)
    ID              reduce using rule 75 (expression -> expression binop ID .)
    LPAREN          reduce using rule 75 (expression -> expression binop ID .)
    NEGATE          reduce using rule 75 (expression -> expression binop ID .)
    CHAR            reduce using rule 75 (expression -> expression binop ID .)
    DOUBLE          reduce using rule 75 (expression -> expression binop ID .)
    FLOAT           reduce using rule 75 (expression -> expression binop ID .)
    INT             reduce using rule 75 (expression -> expression binop ID .)
    VOID            reduce using rule 75 (expression -> expression binop ID .)
    UINT8_T         reduce using rule 75 (expression -> expression binop ID .)
    UINT16_T        reduce using rule 75 (expression -> expression binop ID .)
    STRING          reduce using rule 75 (expression -> expression binop ID .)
    NONDECIMAL      reduce using rule 75 (expression -> expression binop ID .)


state 130

    (65) expression -> LPAREN expression RPAREN .

    SEMI            reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    ASTERISK        reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    PERCENT         reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    ID              reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    NEGATE          reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    CHAR            reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    DOUBLE          reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    INT             reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    VOID            reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    UINT8_T         reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    UINT16_T        reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    STRING          reduce using rule 65 (expression -> LPAREN expression RPAREN .)
    NONDECIMAL      reduce using rule 65 (expression -> LPAREN expression RPAREN .)


state 131

    (48) control_expr -> control LPAREN conditional_expr RPAREN LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 141

state 132

    (46) conditional_expr -> ID conditional ID .
    (76) expression -> ID . binop expression
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

    RPAREN          reduce using rule 46 (conditional_expr -> ID conditional ID .)
    SEMI            reduce using rule 46 (conditional_expr -> ID conditional ID .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

    binop                          shift and go to state 92

state 133

    (43) conditional_expr -> ID conditional expression .
    (75) expression -> expression . binop ID
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

    RPAREN          reduce using rule 43 (conditional_expr -> ID conditional expression .)
    SEMI            reduce using rule 43 (conditional_expr -> ID conditional expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

    binop                          shift and go to state 101

state 134

    (45) conditional_expr -> expression conditional expression .
    (75) expression -> expression . binop ID
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

    RPAREN          reduce using rule 45 (conditional_expr -> expression conditional expression .)
    SEMI            reduce using rule 45 (conditional_expr -> expression conditional expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

    binop                          shift and go to state 101

state 135

    (44) conditional_expr -> expression conditional ID .
    (76) expression -> ID . binop expression
    (68) binop -> . PLUS
    (69) binop -> . MINUS
    (70) binop -> . ASTERISK
    (71) binop -> . DIVIDE
    (72) binop -> . LSHIFT
    (73) binop -> . RSHIFT
    (74) binop -> . PERCENT

    RPAREN          reduce using rule 44 (conditional_expr -> expression conditional ID .)
    SEMI            reduce using rule 44 (conditional_expr -> expression conditional ID .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    ASTERISK        shift and go to state 95
    DIVIDE          shift and go to state 96
    LSHIFT          shift and go to state 97
    RSHIFT          shift and go to state 98
    PERCENT         shift and go to state 99

    binop                          shift and go to state 92

state 136

    (84) init_var_rs -> LPAREN dtype RPAREN literal . SEMI

    SEMI            shift and go to state 142


state 137

    (85) init_var_rs -> LPAREN dtype RPAREN ID . SEMI

    SEMI            shift and go to state 143


state 138

    (47) for_loop -> FOR LPAREN init_var conditional_expr SEMI . ID INCREMENT RPAREN

    ID              shift and go to state 144


state 139

    (80) init_var_ls -> modifier dtype ID . assign
    (13) assign -> . SIMPLE_ASSIGN
    (14) assign -> . COMPLEX_ASSIGN

    SIMPLE_ASSIGN   shift and go to state 43
    COMPLEX_ASSIGN  shift and go to state 44

    assign                         shift and go to state 120

state 140

    (58) func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE . node_list RBRACE
    (1) node_list -> .
    (2) node_list -> . node_list node

    RBRACE          reduce using rule 1 (node_list -> .)
    INCLUDE         reduce using rule 1 (node_list -> .)
    ID              reduce using rule 1 (node_list -> .)
    CHAR            reduce using rule 1 (node_list -> .)
    DOUBLE          reduce using rule 1 (node_list -> .)
    FLOAT           reduce using rule 1 (node_list -> .)
    INT             reduce using rule 1 (node_list -> .)
    VOID            reduce using rule 1 (node_list -> .)
    UINT8_T         reduce using rule 1 (node_list -> .)
    UINT16_T        reduce using rule 1 (node_list -> .)
    WHILE           reduce using rule 1 (node_list -> .)
    IF              reduce using rule 1 (node_list -> .)
    ELSE            reduce using rule 1 (node_list -> .)
    FOR             reduce using rule 1 (node_list -> .)
    CONST           reduce using rule 1 (node_list -> .)
    EXTERN          reduce using rule 1 (node_list -> .)
    INLINE          reduce using rule 1 (node_list -> .)
    LONG            reduce using rule 1 (node_list -> .)
    SHORT           reduce using rule 1 (node_list -> .)
    SIGNED          reduce using rule 1 (node_list -> .)
    UNSIGNED        reduce using rule 1 (node_list -> .)
    VOLATILE        reduce using rule 1 (node_list -> .)

    node_list                      shift and go to state 145

state 141

    (48) control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . func_def
    (5) node -> . func_call
    (6) node -> . statement
    (7) node -> . control_expr
    (31) include -> . INCLUDE
    (58) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (59) func_call -> . ID LPAREN func_arglist RPAREN SEMI
    (60) statement -> . init_var
    (61) statement -> . assign_var
    (62) statement -> . declare_var
    (63) statement -> . increment
    (48) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (49) control_expr -> . control LBRACE node_list RBRACE
    (50) control_expr -> . for_loop LBRACE node_list RBRACE
    (15) dtype -> . CHAR
    (16) dtype -> . DOUBLE
    (17) dtype -> . FLOAT
    (18) dtype -> . INT
    (19) dtype -> . VOID
    (20) dtype -> . UINT8_T
    (21) dtype -> . UINT16_T
    (22) dtype -> . dtype ASTERISK
    (87) init_var -> . init_var_ls init_var_rs
    (88) assign_var -> . ID assign expression SEMI
    (78) declare_var -> . dtype ID SEMI
    (79) declare_var -> . modifier dtype ID SEMI
    (77) increment -> . ID INCREMENT SEMI
    (32) control -> . WHILE
    (33) control -> . IF
    (34) control -> . ELSE
    (47) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (80) init_var_ls -> . modifier dtype ID assign
    (81) init_var_ls -> . dtype ID assign
    (23) modifier -> . CONST
    (24) modifier -> . EXTERN
    (25) modifier -> . INLINE
    (26) modifier -> . LONG
    (27) modifier -> . SHORT
    (28) modifier -> . SIGNED
    (29) modifier -> . UNSIGNED
    (30) modifier -> . VOLATILE

    RBRACE          shift and go to state 146
    INCLUDE         shift and go to state 8
    ID              shift and go to state 10
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    VOID            shift and go to state 21
    UINT8_T         shift and go to state 22
    UINT16_T        shift and go to state 23
    WHILE           shift and go to state 26
    IF              shift and go to state 27
    ELSE            shift and go to state 28
    FOR             shift and go to state 29
    CONST           shift and go to state 30
    EXTERN          shift and go to state 31
    INLINE          shift and go to state 32
    LONG            shift and go to state 33
    SHORT           shift and go to state 34
    SIGNED          shift and go to state 35
    UNSIGNED        shift and go to state 36
    VOLATILE        shift and go to state 37

    control                        shift and go to state 15
    node                           shift and go to state 2
    include                        shift and go to state 3
    func_def                       shift and go to state 4
    func_call                      shift and go to state 5
    statement                      shift and go to state 6
    control_expr                   shift and go to state 7
    dtype                          shift and go to state 9
    init_var                       shift and go to state 11
    assign_var                     shift and go to state 12
    declare_var                    shift and go to state 13
    increment                      shift and go to state 14
    for_loop                       shift and go to state 16
    init_var_ls                    shift and go to state 24
    modifier                       shift and go to state 25

state 142

    (84) init_var_rs -> LPAREN dtype RPAREN literal SEMI .

    INCLUDE         reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    ID              reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    CHAR            reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    DOUBLE          reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    FLOAT           reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    INT             reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    VOID            reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    UINT8_T         reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    UINT16_T        reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    WHILE           reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    IF              reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    ELSE            reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    FOR             reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    CONST           reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    EXTERN          reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    INLINE          reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    LONG            reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    SHORT           reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    SIGNED          reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    UNSIGNED        reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    VOLATILE        reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    $end            reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    LPAREN          reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    NEGATE          reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    MINUS           reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    STRING          reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    NONDECIMAL      reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)
    RBRACE          reduce using rule 84 (init_var_rs -> LPAREN dtype RPAREN literal SEMI .)


state 143

    (85) init_var_rs -> LPAREN dtype RPAREN ID SEMI .

    INCLUDE         reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    ID              reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    CHAR            reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    DOUBLE          reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    FLOAT           reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    INT             reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    VOID            reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    UINT8_T         reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    UINT16_T        reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    WHILE           reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    IF              reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    ELSE            reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    FOR             reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    CONST           reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    EXTERN          reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    INLINE          reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    LONG            reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    SHORT           reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    SIGNED          reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    UNSIGNED        reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    VOLATILE        reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    $end            reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    LPAREN          reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    NEGATE          reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    MINUS           reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    STRING          reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    NONDECIMAL      reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)
    RBRACE          reduce using rule 85 (init_var_rs -> LPAREN dtype RPAREN ID SEMI .)


state 144

    (47) for_loop -> FOR LPAREN init_var conditional_expr SEMI ID . INCREMENT RPAREN

    INCREMENT       shift and go to state 147


state 145

    (58) func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list . RBRACE
    (2) node_list -> node_list . node
    (3) node -> . include
    (4) node -> . func_def
    (5) node -> . func_call
    (6) node -> . statement
    (7) node -> . control_expr
    (31) include -> . INCLUDE
    (58) func_def -> . dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE
    (59) func_call -> . ID LPAREN func_arglist RPAREN SEMI
    (60) statement -> . init_var
    (61) statement -> . assign_var
    (62) statement -> . declare_var
    (63) statement -> . increment
    (48) control_expr -> . control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE
    (49) control_expr -> . control LBRACE node_list RBRACE
    (50) control_expr -> . for_loop LBRACE node_list RBRACE
    (15) dtype -> . CHAR
    (16) dtype -> . DOUBLE
    (17) dtype -> . FLOAT
    (18) dtype -> . INT
    (19) dtype -> . VOID
    (20) dtype -> . UINT8_T
    (21) dtype -> . UINT16_T
    (22) dtype -> . dtype ASTERISK
    (87) init_var -> . init_var_ls init_var_rs
    (88) assign_var -> . ID assign expression SEMI
    (78) declare_var -> . dtype ID SEMI
    (79) declare_var -> . modifier dtype ID SEMI
    (77) increment -> . ID INCREMENT SEMI
    (32) control -> . WHILE
    (33) control -> . IF
    (34) control -> . ELSE
    (47) for_loop -> . FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN
    (80) init_var_ls -> . modifier dtype ID assign
    (81) init_var_ls -> . dtype ID assign
    (23) modifier -> . CONST
    (24) modifier -> . EXTERN
    (25) modifier -> . INLINE
    (26) modifier -> . LONG
    (27) modifier -> . SHORT
    (28) modifier -> . SIGNED
    (29) modifier -> . UNSIGNED
    (30) modifier -> . VOLATILE

    RBRACE          shift and go to state 148
    INCLUDE         shift and go to state 8
    ID              shift and go to state 10
    CHAR            shift and go to state 17
    DOUBLE          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    VOID            shift and go to state 21
    UINT8_T         shift and go to state 22
    UINT16_T        shift and go to state 23
    WHILE           shift and go to state 26
    IF              shift and go to state 27
    ELSE            shift and go to state 28
    FOR             shift and go to state 29
    CONST           shift and go to state 30
    EXTERN          shift and go to state 31
    INLINE          shift and go to state 32
    LONG            shift and go to state 33
    SHORT           shift and go to state 34
    SIGNED          shift and go to state 35
    UNSIGNED        shift and go to state 36
    VOLATILE        shift and go to state 37

    dtype                          shift and go to state 9
    node                           shift and go to state 2
    include                        shift and go to state 3
    func_def                       shift and go to state 4
    func_call                      shift and go to state 5
    statement                      shift and go to state 6
    control_expr                   shift and go to state 7
    init_var                       shift and go to state 11
    assign_var                     shift and go to state 12
    declare_var                    shift and go to state 13
    increment                      shift and go to state 14
    control                        shift and go to state 15
    for_loop                       shift and go to state 16
    init_var_ls                    shift and go to state 24
    modifier                       shift and go to state 25

state 146

    (48) control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    ID              reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    CHAR            reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    INT             reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    VOID            reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    WHILE           reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    IF              reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    ELSE            reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    FOR             reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    CONST           reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    INLINE          reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    LONG            reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    SHORT           reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    $end            reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 48 (control_expr -> control LPAREN conditional_expr RPAREN LBRACE node_list RBRACE .)


state 147

    (47) for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT . RPAREN

    RPAREN          shift and go to state 149


state 148

    (58) func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .

    INCLUDE         reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    ID              reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    CHAR            reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    DOUBLE          reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    FLOAT           reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    INT             reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    VOID            reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UINT8_T         reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UINT16_T        reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    WHILE           reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    IF              reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    ELSE            reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    FOR             reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    CONST           reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    EXTERN          reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    INLINE          reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    LONG            reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    SHORT           reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    SIGNED          reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    UNSIGNED        reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    VOLATILE        reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    $end            reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)
    RBRACE          reduce using rule 58 (func_def -> dtype ID LPAREN func_arglist RPAREN LBRACE node_list RBRACE .)


state 149

    (47) for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN .

    LBRACE          reduce using rule 47 (for_loop -> FOR LPAREN init_var conditional_expr SEMI ID INCREMENT RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 87 resolved as shift
WARNING: shift/reduce conflict for ID in state 88 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 103 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 103 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 103 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 103 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 103 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 103 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 103 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 104 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 104 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 104 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 104 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 104 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 104 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 104 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 128 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 128 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 128 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 128 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 128 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 128 resolved as shift
WARNING: shift/reduce conflict for PERCENT in state 128 resolved as shift
WARNING: reduce/reduce conflict in state 89 resolved using rule (literal -> CHAR)
WARNING: rejected rule (dtype -> CHAR) in state 89
WARNING: reduce/reduce conflict in state 90 resolved using rule (literal -> FLOAT)
WARNING: rejected rule (dtype -> FLOAT) in state 90
WARNING: reduce/reduce conflict in state 91 resolved using rule (literal -> INT)
WARNING: rejected rule (dtype -> INT) in state 91
